{"version":3,"sources":["webpack:///asciizer.min.js","webpack:///webpack/bootstrap 1c323d4a2a86b279f14b","webpack:///./asciizer-browser.js","webpack:///./equalize.js","webpack:///./assignCharacters.js","webpack:///./readSums-browser.js","webpack:///../~/ndarray/ndarray.js","webpack:///../~/iota-array/iota.js","webpack:///../~/is-buffer/index.js","webpack:///./vendor/dom-pixels.js","webpack:///../~/process/browser.js","webpack:///../~/buffer/index.js","webpack:///../~/base64-js/lib/b64.js","webpack:///../~/ieee754/index.js","webpack:///../~/buffer/~/isarray/index.js","webpack:///../~/path-browserify/index.js","webpack:///../~/omggif/omggif.js","webpack:///../~/ndarray-pack/convert.js","webpack:///../~/ndarray-pack/doConvert.js","webpack:///../~/cwise-compiler/compiler.js","webpack:///../~/cwise-compiler/lib/thunk.js","webpack:///../~/cwise-compiler/lib/compile.js","webpack:///../~/uniq/uniq.js","webpack:///../~/through/index.js","webpack:///../~/stream-browserify/index.js","webpack:///../~/events/events.js","webpack:///../~/inherits/inherits_browser.js","webpack:///../~/stream-browserify/~/readable-stream/readable.js","webpack:///../~/stream-browserify/~/readable-stream/lib/_stream_readable.js","webpack:///../~/isarray/index.js","webpack:///../~/core-util-is/lib/util.js","webpack:///../~/stream-browserify/~/readable-stream/lib/_stream_duplex.js","webpack:///../~/stream-browserify/~/readable-stream/lib/_stream_writable.js","webpack:///../~/string_decoder/index.js","webpack:///../~/stream-browserify/~/readable-stream/lib/_stream_transform.js","webpack:///../~/stream-browserify/~/readable-stream/lib/_stream_passthrough.js","webpack:///../~/stream-browserify/~/readable-stream/writable.js","webpack:///../~/stream-browserify/~/readable-stream/duplex.js","webpack:///../~/stream-browserify/~/readable-stream/transform.js","webpack:///../~/stream-browserify/~/readable-stream/passthrough.js","webpack:///../~/data-uri-to-buffer/index.js","webpack:///./getRows.js"],"names":["asciizer","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_toConsumableArray","arr","Array","isArray","i","arr2","length","from","equalizeHistogram","assignCharacters","readSums","getRows","asciize","options","cb","src","chars","x","y","sum","meta","equalizedData","concat","data","maxval","asciized","formatted","sizeX","sizeY","inMax","outMax","step","map","n","Math","floor","counts","val","charAt","ndarray","getPixels","img","err","pixels","picX","shape","picY","ratio","Uint16Array","stepX","stepY","count","py","px","R","get","G","B","set","compare1st","a","b","order","stride","this","terms","abs","sort","result","compileConstructor","dtype","dimension","className","join","useGetters","code","procedure","Function","CACHED_CONSTRUCTORS","indices","iota","args","index_str","shapeArg","strideArg","push","a_vars","c_vars","tShape","tStride","idx","arrayDType","isBuffer","hasTypedArrays","Object","prototype","toString","wrappedNDArrayCtor","offset","undefined","ctor","array","d","sz","ctor_list","Float64Array","float32","float64","int8","int16","int32","uint8","uint16","uint32","uint8_clamped","buffer","generic","obj","_isBuffer","constructor","process","Buffer","defaultImage","url","Image","crossOrigin","onload","canvas","document","createElement","width","height","context","getContext","drawImage","getImageData","Uint8Array","onerror","handleGif","reader","GifReader","numFrames","nshape","ndata","decodeAndBlitFrameRGBA","subarray","index","transpose","httpGif","xhr","XMLHttpRequest","open","responseType","overrideMimeType","readyState","response","send","copyBuffer","dataGif","nextTick","parseDataURI","Error","path","type","ext","extname","toUpperCase","indexOf","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","timeout","setTimeout","len","run","clearTimeout","Item","fun","noop","arguments","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","name","cwd","chdir","dir","umask","global","typedArraySupport","Bar","foo","byteLength","e","kMaxLength","TYPED_ARRAY_SUPPORT","arg","parent","fromNumber","fromString","fromObject","that","allocate","checked","string","encoding","write","object","fromBuffer","fromArray","TypeError","ArrayBuffer","fromTypedArray","fromArrayBuffer","fromArrayLike","fromJsonObject","copy","_augment","__proto__","fromPool","poolSize","rootParent","RangeError","SlowBuffer","subject","buf","loweredCase","utf8ToBytes","base64ToBytes","toLowerCase","slowToString","start","end","Infinity","hexSlice","utf8Slice","asciiSlice","binarySlice","base64Slice","utf16leSlice","hexWrite","Number","remaining","strLen","parsed","parseInt","substr","isNaN","utf8Write","blitBuffer","asciiWrite","asciiToBytes","binaryWrite","base64Write","ucs2Write","utf16leToBytes","base64","fromByteArray","slice","min","res","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","decodeCodePointsArray","codePoints","MAX_ARGUMENTS_LENGTH","String","fromCharCode","ret","out","toHex","bytes","checkOffset","checkInt","value","max","objectWriteUInt16","littleEndian","j","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","ieee754","writeDouble","base64clean","str","stringtrim","replace","INVALID_BASE64_RE","trim","units","leadSurrogate","charCodeAt","byteArray","hi","lo","toByteArray","dst","INSPECT_MAX_BYTES","compare","isEncoding","list","pos","item","equals","inspect","match","byteOffset","arrayIndexOf","foundIndex","console","log","readUInt8","v","writeUInt8","isFinite","swap","toJSON","_arr","newBuf","sliceLen","readUIntLE","mul","readUIntBE","readUInt16LE","readUInt16BE","readUInt32LE","readUInt32BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","read","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","writeUIntBE","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","target","targetStart","_set","fill","toArrayBuffer","BP","toLocaleString","lookup","decode","elt","PLUS","PLUS_URL_SAFE","SLASH","SLASH_URL_SAFE","NUMBER","UPPER","LOWER","b64ToByteArray","b64","L","l","tmp","placeHolders","Arr","uint8ToBase64","encode","num","tripletToBase64","temp","extraBytes","output","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","s","NaN","rt","LN2","normalizeArray","parts","allowAboveRoot","up","last","splice","unshift","filter","xs","f","splitPathRe","splitPath","filename","exec","resolve","resolvedPath","resolvedAbsolute","split","normalize","isAbsolute","trailingSlash","paths","relative","to","fromParts","toParts","samePartsLength","outputParts","sep","delimiter","dirname","root","basename","GifWriter","gopts","check_palette_and_num_colors","palette","num_colors","loop_count","loop","global_palette","gp_num_colors_pow2","background","gp_num_colors","il","rgb","ended","addFrame","w","h","indexed_pixels","opts","using_local_palette","min_code_size","delay","disposal","use_transparency","transparent_index","transparent","GifWriterOutputLZWCodeStream","index_stream","emit_bytes_to_buffer","bit_block_size","cur_shift","cur","cur_subblock","emit_code","cur_code_size","clear_code","code_mask","eoi_code","next_code","ib_code","code_table","k","cur_key","cur_code","pf0","global_palette_flag","num_global_colors_pow2","num_global_colors","global_palette_offset","no_eof","frames","block_size","pf1","pf2","local_palette_flag","interlace_flag","num_local_colors_pow2","num_local_colors","palette_offset","has_local_palette","data_offset","data_length","interlaced","loopCount","frameInfo","frame_num","decodeAndBlitFrameBGRA","frame","num_pixels","GifReaderLZWOutputIndexStream","trans","framewidth","framestride","xleft","opbeg","opend","op","scanstride","interlaceskip","r","g","code_stream","output_length","subblock_size","Int32Array","prev_code","chase_code","chase_length","chase","op_end","do_convert","pre","body","thisVars","localVars","lvalue","rvalue","post","funcName","blockSize","Procedure","argTypes","shimArgs","arrayArgs","scalarArgs","offsetArgs","offsetArgIndex","indexArgs","shapeArgs","debug","compileCwise","user_args","proc","proc_args","arg_type","printCode","createThunk","vars","thunkName","typesig","string_typesig","thunk","compile","bind","innerFill","nargs","has_index","pidx","outerFill","matched","indexStr","countMatches","orders","processBlock","block","dtypes","carg","re","RegExp","ptrStr","arrNum","offArgIndex","offArg","localStr","arrStr","typeSummary","summary","allEqual","t","digits","generateCWiseOp","arglist","zeros","off_arg","init_string","uniq","loopName","unique_pred","ptr","unique_eq","unique","sorted","through","drain","stream","paused","shift","_end","writable","readable","autoDestroy","destroy","destroyed","_ended","Stream","pause","resume","EE","EventEmitter","inherits","Readable","Writable","Duplex","Transform","PassThrough","pipe","dest","ondata","chunk","source","ondrain","onend","didOnEnd","onclose","er","cleanup","listenerCount","_isStdio","_events","_maxListeners","isFunction","isNumber","isObject","isUndefined","defaultMaxListeners","setMaxListeners","handler","listeners","error","listener","newListener","warned","trace","fired","position","key","evlistener","emitter","create","superCtor","super_","enumerable","configurable","TempCtor","ReadableState","hwm","highWaterMark","defaultHwm","objectMode","pipes","pipesCount","flowing","endEmitted","reading","sync","needReadable","emittedReadable","readableListening","readableObjectMode","defaultEncoding","ranOut","awaitDrain","readingMore","decoder","StringDecoder","_readableState","readableAddChunk","state","addToFront","chunkInvalid","util","isNullOrUndefined","onEofChunk","emitReadable","maybeReadMore","needMoreData","roundUpToNextPowerOf2","MAX_HWM","howMuchToRead","isNull","isString","emitReadable_","flow","maybeReadMore_","pipeOnDrain","resumeScheduled","resume_","fromList","stringMode","cpy","endReadable","forEach","debuglog","setEncoding","enc","nOrig","doRead","_read","pipeOpts","onunpipe","onfinish","_writableState","needDrain","unpipe","doEnd","stdout","stderr","endFn","dests","ev","fn","self","wrap","method","events","_fromList","objectToString","isBoolean","isSymbol","isRegExp","isDate","isError","isPrimitive","o","allowHalfOpen","objectKeys","keys","WriteReq","callback","WritableState","writableObjectMode","ending","finished","noDecode","decodeStrings","writing","corked","bufferProcessing","onwrite","writecb","writelen","pendingcb","prefinished","errorEmitted","writeAfterEnd","validChunk","valid","decodeChunk","writeOrBuffer","doWrite","writev","_writev","_write","onwriteError","onwriteStateUpdate","needFinish","clearBuffer","afterWrite","onwriteDrain","finishMaybe","cbs","entry","prefinish","need","endWritable","cork","uncork","assertEncoding","isBufferEncoding","passThroughWrite","utf16DetectIncompleteChar","charReceived","charLength","base64DetectIncompleteChar","surrogateSize","detectIncompleteChar","charBuffer","charStr","available","charCode","size","substring","cr","TransformState","afterTransform","needTransform","transforming","writechunk","ts","_transformState","rs","_flush","done","ws","_transform","writeencoding","dataUriToBuffer","uri","test","firstComma","charset","unescape","X","Y","row"],"mappings":"AAAA,GAAIA,UACK,SAAUC,GCGnB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAE,WACAE,GAAAJ,EACAK,QAAA,EAUA,OANAP,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,QAAA,EAGAF,EAAAD,QAvBA,GAAAD,KAqCA,OATAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,GAGAV,EAAA,KDOM,SAASI,EAAQD,EAASH,GAE/BI,EAAOD,QAAUH,EAAoB,IAKhC,SAASI,EAAQD,EAASH,GEpDhC,YFwDC,SAASW,GAAmBC,GAAO,GAAIC,MAAMC,QAAQF,GAAM,CAAE,IAAK,GAAIG,GAAI,EAAGC,EAAOH,MAAMD,EAAIK,QAASF,EAAIH,EAAIK,OAAQF,IAAOC,EAAKD,GAAKH,EAAIG,EAAM,OAAOC,GAAe,MAAOH,OAAMK,KAAKN,GEtD3L,GAAMO,GAAoBnB,EAAQ,GAC5BoB,EAAmBpB,EAAQ,GAC3BqB,EAAWrB,EAAQ,GACnBsB,EAAUtB,EAAQ,IAGlBuB,EAAU,SAACC,EAASC,GACxB,IAAKD,EAAQE,IACX,KAAM,aACRF,GAAQG,MAAQH,EAAQG,OAAS,aAEjCN,EACEG,EAAQE,IACRF,EAAQI,EACRJ,EAAQK,EACR,SAACC,EAAKC,GACJ,GAAMC,GAAgBb,KAAiBc,OAAAtB,EAAKmB,EAAII,OAAOH,EAAKI,OAAQX,EAAQG,MAAMV,OAAS,GACrFmB,EAAWhB,EAAiBY,EAAeR,EAAQG,OACnDU,EAAYf,EAAQc,EAAWL,EAAKO,MAAOP,EAAKQ,MAEtDd,GAAGY,KAKTjC,GAAOD,QAAUoB,GFsDX,SAASnB,EAAQD,GAEtB,YGnFD,IAAMgB,GAAoB,SAASO,EAAKc,EAAOC,GAC7C,GAAMC,IAAQF,EAAQ,IAAOC,EAAS,EAEtC,OAAOf,GAAIiB,IAAK,SAAAC,GHsFb,MGtFkBC,MAAKC,MAAMF,EAAIF,KAGtCtC,GAAOD,QAAUgB,GH2FX,SAASf,EAAQD,GAEtB,YInGD,IAAMiB,GACJ,SAAC2B,EAAQpB,GJqGR,MIrGkBoB,GAAOJ,IACxB,SAAAK,GJqGC,MIrGMnC,OAAMC,QAAQa,GAASA,EAAMkB,KAAKC,MAAME,IAAQrB,EAAMsB,OAAOJ,KAAKC,MAAME,MAGnF5C,GAAOD,QAAUiB,GJ0GX,SAAShB,EAAQD,EAASH,GK/GhC,YAGA,IAAMkD,GAAUlD,EAAQ,GAClBmD,EAAYnD,EAAQ,GAEpBqB,EAAW,SAAU+B,EAAKd,EAAOC,EAAOd,GAC5C0B,EAAUC,EAAK,SAAWC,EAAKC,GAC7B,GAAMC,GAAOD,EAAOE,MAAM,GACpBC,EAAOH,EAAOE,MAAM,GACpBE,EAAQH,EAAOE,CAErBnB,IAASA,GAASC,EAAQM,KAAKC,MAAMP,EAAQmB,GAASpB,EACtDC,GAASA,GAASD,EAAQO,KAAKC,MAAMR,EAAQoB,GAASnB,CAStD,KAAK,GANDT,GAAMoB,EAAQ,GAAIS,aAAYrB,EAAMC,IAASD,EAAOC,IAClDqB,EAAQf,KAAKC,MAAMS,EAAOjB,GAC1BuB,EAAQhB,KAAKC,MAAMW,EAAOlB,GAC1BJ,EAASyB,EAAMC,EAAM,IAAI,EAGtBhC,EAAI,EAAO4B,EAAOI,EAAXhC,EAAkBA,IAChC,IAAK,GAAID,GAAI,EAAO2B,EAAOK,EAAXhC,EAAkBA,IAAK,CAErC,IAAK,GADDkC,GAAQ,EACHC,EAAK,EAAQF,EAALE,EAAYA,IAC3B,IAAK,GAAIC,GAAK,EAAQJ,EAALI,EAAYA,IAAM,CACjC,GAAMC,GAAIX,EAAOY,IAAItC,EAAIgC,EAAQI,EAAInC,EAAIgC,EAAQE,EAAI,GAC/CI,EAAIb,EAAOY,IAAItC,EAAIgC,EAAQI,EAAInC,EAAIgC,EAAQE,EAAI,GAC/CK,EAAId,EAAOY,IAAItC,EAAIgC,EAAQI,EAAInC,EAAIgC,EAAQE,EAAI,EAErDD,IAASG,EAAIE,EAAIC,EAGrBtC,EAAIuC,IAAIzC,EAAGC,EAAGiC,GAGlBrC,EAAGK,GAAMK,SAAQG,QAAOC,YAI5BnC,GAAOD,QAAUkB,GLoHX,SAASjB,EAAQD,EAASH,GMxJhC,QAAAsE,GAAAC,EAAAC,GACA,MAAAD,GAAA,GAAAC,EAAA,GAGA,QAAAC,KACA,GAEA1D,GAFA2D,EAAAC,KAAAD,OACAE,EAAA,GAAA/D,OAAA6D,EAAAzD,OAEA,KAAAF,EAAA,EAAUA,EAAA6D,EAAA3D,SAAgBF,EAC1B6D,EAAA7D,IAAA8B,KAAAgC,IAAAH,EAAA3D,MAEA6D,GAAAE,KAAAR,EACA,IAAAS,GAAA,GAAAlE,OAAA+D,EAAA3D,OACA,KAAAF,EAAA,EAAUA,EAAAgE,EAAA9D,SAAiBF,EAC3BgE,EAAAhE,GAAA6D,EAAA7D,GAAA,EAEA,OAAAgE,GAGA,QAAAC,GAAAC,EAAAC,GACA,GAAAC,IAAA,OAAAD,EAAA,IAAAD,GAAAG,KAAA,GACA,GAAAF,IACAC,EAAA,WAAAF,EAEA,IAAAI,GAAA,YAAAJ,CAEA,SAAAC,EAAA,CAEA,GAAAI,GACA,YAAAH,EAAA,gCACAA,EAAA,4BACAF,EAAA,wLAMWE,EAAA,kHAGXA,EAAA,kBAA2CA,EAAA,QAC3CI,EAAA,GAAAC,UAAAF,EACA,OAAAC,KACG,OAAAL,EAAA,CAEH,GAAAI,GACA,YAAAH,EAAA,uDAIAA,EAAA,4BACAF,EAAA,uLAUAE,EAAA,wBACAA,EAAA,kDAEAA,EAAA,gFAGAA,EAAA,mBACAE,EAAA,uDACA,yBACAF,EAAA,oBACAE,EAAA,4FAEAF,EAAA,wBAAiDA,EAAA,SACjDI,EAAA,GAAAC,UAAA,eAAAF,EACA,OAAAC,GAAAE,EAAAR,GAAA,IAGA,GAAAK,IAAA,gBAGAI,EAAAC,EAAAT,GACAU,EAAAF,EAAA/C,IAAA,SAAA5B,GAAsC,UAAAA,IACtC8E,EAAA,eAAAH,EAAA/C,IAAA,SAAA5B,GACA,qBAAAA,EAAA,MAAAA,IACOqE,KAAA,KACPU,EAAAJ,EAAA/C,IAAA,SAAA5B,GACA,UAAAA,IACKqE,KAAA,KACLW,EAAAL,EAAA/C,IAAA,SAAA5B,GACA,UAAAA,IACKqE,KAAA,IACLE,GAAAU,KACA,YAAAb,EAAA,MAAAW,EAAA,IAAAC,EAAA,kBACA,eAAAD,EAAA,IACA,gBAAAC,EAAA,IACA,mBACA,aAAAZ,EAAA,aACA,gBAAAF,EAAA,IACA,mBAAAC,GAGAI,EAAAU,KAAA,oDAAiDb,EAAA,mBACjDO,EAAA/C,IAAA,SAAA5B,GAAkC,oBAAAA,EAAA,MAA6BqE,KAAA,KAC/D,OAGA,IAAAF,EACAI,EAAAU,KAAA,oBAEAV,EAAAU,KAAA,6CACA,EAAAd,GACAI,EAAAU,KAAA,YAAAb,EAAA,aACA,IAAAD,EACAI,EAAAU,KAAA,6EACO,IAAAd,GACPI,EAAAU,KACA,2RAkBAV,EAAAU,KAAA,YAKAV,EAAAU,KACA,sBAAAb,EAAA,QAAAS,EAAAR,KAAA,aACAC,EACAC,EAAAU,KAAA,wBAAAH,EAAA,QAEAP,EAAAU,KAAA,oBAAAH,EAAA,QAIAP,EAAAU,KAAA,sBAAAb,EAAA,QAAAS,EAAAR,KAAA,WACAC,EACAC,EAAAU,KAAA,wBAAAH,EAAA,MAEAP,EAAAU,KAAA,oBAAAH,EAAA,MAIAP,EAAAU,KACA,wBAAAb,EAAA,UAAAS,EAAAR,OAAA,YAAiES,EAAA,KAGjEP,EAAAU,KAAA,qBAAAb,EAAA,OAAAS,EAAAR,KAAA,qBAAoED,EAAA,cACpEO,EAAA/C,IAAA,SAAA5B,GACA,mBAAAA,EAAA,iBAAAA,EAAA,kBAAAA,EAAA,MAAAA,EAAA,MAAAqE,KAAA,MACKA,KAAA,SACLM,EAAA/C,IAAA,SAAA5B,GACA,qBAAAA,EAAA,MACKqE,KAAA,sBAGL,IAAAa,GAAAP,EAAA/C,IAAA,SAAA5B,GAAwC,UAAAA,EAAA,eAAAA,EAAA,MACxCmF,EAAAR,EAAA/C,IAAA,SAAA5B,GAAwC,UAAAA,EAAA,gBAAAA,EAAA,KACxCuE,GAAAU,KAAA,qBAAAb,EAAA,OAAAS,EAAAR,KAAA,gCAAoEa,EAAAb,KAAA,SAAAc,EAAAd,KAAA,KACpE,QAAArE,GAAA,EAAcmE,EAAAnE,IAAaA,EAC3BuE,EAAAU,KACA,cAAAjF,EAAA,iBAAAA,EAAA,YACAA,EAAA,WACAA,EAAA,QACAA,EAAA,OAEAuE,GAAAU,KAAA,cAAAb,EAAA,cACAO,EAAA/C,IAAA,SAAA5B,GACA,UAAAA,IACKqE,KAAA,SACLM,EAAA/C,IAAA,SAAA5B,GACA,UAAAA,IACKqE,KAAA,aAGLE,EAAAU,KAAA,uBAAAb,EAAA,SAAAS,EAAAR,KAAA,cACAM,EAAA/C,IAAA,SAAA5B,GACA,UAAAA,EAAA,eAAAA,EAAA,MACKqE,KAAA,SACLM,EAAA/C,IAAA,SAAA5B,GACA,UAAAA,EAAA,gBAAAA,EAAA,MACKqE,KAAA,yCACL,QAAArE,GAAA,EAAcmE,EAAAnE,IAAaA,EAC3BuE,EAAAU,KACA,cAAAjF,EAAA,oBACAA,EAAA,oBAEAA,EAAA,MAAAA,EAAA,SACAA,EAAA,WAAAA,EAAA,eAEAA,EAAA,UAAAA,EAAA,UAEAA,EAAA,QAGAuE,GAAAU,KAAA,cAAAb,EAAA,cACAO,EAAA/C,IAAA,SAAA5B,GACA,UAAAA,IACKqE,KAAA,SACLM,EAAA/C,IAAA,SAAA5B,GACA,UAAAA,IACKqE,KAAA,YAKL,QAFAe,GAAA,GAAAtF,OAAAqE,GACAkB,EAAA,GAAAvF,OAAAqE,GACAnE,EAAA,EAAcmE,EAAAnE,IAAaA,EAC3BoF,EAAApF,GAAA,MAAAA,EAAA,IACAqF,EAAArF,GAAA,MAAAA,EAAA,GAEAuE,GAAAU,KAAA,4BAAAb,EAAA,cAAAS,EAAA,KACAA,EAAAjD,IAAA,SAAAC,EAAAyD,GAA8B,MAAAzD,GAAA,KAAAA,EAAA,gBAAAyD,EAAA,IAAAzD,EAAA,QAA+DwC,KAAA,KAC7F,6CAAoCD,EAAA,cAAAgB,EAAAf,KAAA,SAAAgB,EAAAhB,KAAA,uBAGpCE,EAAAU,KAAA,uBAAAb,EAAA,SAAAS,EAAA,gCACA,QAAA7E,GAAA,EAAcmE,EAAAnE,IAAaA,EAC3BuE,EAAAU,KAAA,cAAAjF,EAAA,iBAAAA,EAAA,yBAAuDA,EAAA,MAAAA,EAAA,8BAAuCA,EAAA,yBAA0BA,EAAA,MAExHuE,GAAAU,KAAA,gEAGAV,EAAAU,KAAA,6BAAAb,EAAA,yCAA+EA,EAAA,SAC/EO,EAAA/C,IAAA,SAAA5B,GACA,eAAAA,EAAA,MACKqE,KAAA,SACLM,EAAA/C,IAAA,SAAA5B,GACA,gBAAAA,EAAA,MACKqE,KAAA,iBAGL,IAAAG,GAAA,GAAAC,UAAA,oBAAAF,EAAAF,KAAA,MACA,OAAAG,GAAAE,EAAAR,GAAAR,GAGA,QAAA6B,GAAApE,GACA,GAAAqE,EAAArE,GACA,cAEA,IAAAsE,EACA,OAAAC,OAAAC,UAAAC,SAAApG,KAAA2B,IACA,4BACA,eACA,6BACA,eACA,0BACA,YACA,2BACA,aACA,2BACA,aACA,2BACA,aACA,4BACA,cACA,4BACA,cACA,kCACA,sBAGA,MAAArB,OAAAC,QAAAoB,GACA,QAEA,UAwBA,QAAA0E,GAAA1E,EAAAsB,EAAAkB,EAAAmC,GACA,GAAAC,SAAA5E,EAAA,CACA,GAAA6E,GAAAtB,EAAAuB,MAAA,EACA,OAAAD,OACG,gBAAA7E,KACHA,OAEA4E,SAAAtD,IACAA,GAAAtB,EAAAjB,QAEA,IAAAgG,GAAAzD,EAAAvC,MACA,IAAA6F,SAAApC,EAAA,CACAA,EAAA,GAAA7D,OAAAoG,EACA,QAAAlG,GAAAkG,EAAA,EAAAC,EAAA,EAAwBnG,GAAA,IAAMA,EAC9B2D,EAAA3D,GAAAmG,EACAA,GAAA1D,EAAAzC,GAGA,GAAA+F,SAAAD,EAAA,CACAA,EAAA,CACA,QAAA9F,GAAA,EAAgBkG,EAAAlG,IAAKA,EACrB2D,EAAA3D,GAAA,IACA8F,IAAArD,EAAAzC,GAAA,GAAA2D,EAAA3D,IAMA,IAFA,GAAAkE,GAAAqB,EAAApE,GACAiF,EAAA1B,EAAAR,GACAkC,EAAAlG,QAAAgG,EAAA,GACAE,EAAAnB,KAAAhB,EAAAC,EAAAkC,EAAAlG,OAAA,GAEA,IAAA8F,GAAAI,EAAAF,EAAA,EACA,OAAAF,GAAA7E,EAAAsB,EAAAkB,EAAAmC,GAnVA,GAAAlB,GAAA3F,EAAA,GACAuG,EAAAvG,EAAA,GAEAwG,EAAA,mBAAAY,cA2RA3B,GACA4B,WACAC,WACAC,QACAC,SACAC,SACAC,SACAC,UACAC,UACAZ,SACAa,iBACAC,UACAC,WA4CA3H,GAAAD,QAAAyG,GNoKM,SAASxG,EAAQD,GO1fvB,YAEA,SAAAwF,GAAA/C,GAEA,OADAmC,GAAA,GAAAlE,OAAA+B,GACA7B,EAAA,EAAc6B,EAAA7B,IAAKA,EACnBgE,EAAAhE,IAEA,OAAAgE,GAGA3E,EAAAD,QAAAwF,GPggBM,SAASvF,EAAQD,GQjgBvBC,EAAAD,QAAA,SAAA6H,GACA,cAAAA,KACAA,EAAAC,WACAD,EAAAE,aACA,kBAAAF,GAAAE,YAAA3B,UACAyB,EAAAE,YAAA3B,SAAAyB,ORmhBM,SAAS5H,EAAQD,EAASH,IAEH,SAASmI,EAASC,GSliB/C,YASA,SAASC,GAAaC,EAAK7G,GACzB,GAAI2B,GAAM,GAAImF,MACdnF,GAAIoF,YAAc,YAClBpF,EAAIqF,OAAS,WACX,GAAIC,GAASC,SAASC,cAAc,SACpCF,GAAOG,MAAQzF,EAAIyF,MACnBH,EAAOI,OAAS1F,EAAI0F,MACpB,IAAIC,GAAUL,EAAOM,WAAW,KAChCD,GAAQE,UAAU7F,EAAK,EAAG,EAC1B,IAAIE,GAASyF,EAAQG,aAAa,EAAG,EAAG9F,EAAIyF,MAAOzF,EAAI0F,OACvDrH,GAAG,KAAMyB,EAAQ,GAAIiG,YAAW7F,EAAOpB,OAAQkB,EAAIyF,MAAOzF,EAAI0F,OAAQ,IAAK,EAAG,EAAE1F,EAAIyF,MAAO,GAAI,KAEjGzF,EAAIgG,QAAU,SAAS/F,GACrB5B,EAAG4B,IAELD,EAAI1B,IAAM4G,EAIZ,QAASe,GAAUnH,EAAMT,GACvB,GAAI6H,EACJ,KACEA,EAAS,GAAIC,GAAUrH,GACvB,MAAMmB,GAEN,WADA5B,GAAG4B,GAGL,GAAGiG,EAAOE,YAAc,EAAG,CACzB,GAAIC,IAAUH,EAAOE,YAAaF,EAAOR,OAAQQ,EAAOT,MAAO,GAC3Da,EAAQ,GAAIP,YAAWM,EAAO,GAAKA,EAAO,GAAKA,EAAO,GAAKA,EAAO,IAClE1E,EAAS7B,EAAQwG,EAAOD,EAC5B,KACE,IAAI,GAAI1I,GAAE,EAAGA,EAAEuI,EAAOE,cAAezI,EACnCuI,EAAOK,uBAAuB5I,EAAG2I,EAAME,SACrC7E,EAAO8E,MAAM9I,EAAG,EAAG,EAAG,GACtBgE,EAAO8E,MAAM9I,EAAE,EAAG,EAAG,EAAG,KAE5B,MAAMsC,GAEN,WADA5B,GAAG4B,GAGL5B,EAAG,KAAMsD,EAAO+E,UAAU,EAAE,EAAE,QACzB,CACL,GAAIL,IAAUH,EAAOR,OAAQQ,EAAOT,MAAO,GACvCa,EAAQ,GAAIP,YAAWM,EAAO,GAAKA,EAAO,GAAKA,EAAO,IACtD1E,EAAS7B,EAAQwG,EAAOD,EAC5B,KACEH,EAAOK,uBAAuB,EAAGD,GACjC,MAAMrG,GAEN,WADA5B,GAAG4B,GAGL5B,EAAG,KAAMsD,EAAO+E,UAAU,EAAE,KAIhC,QAASC,GAAQzB,EAAK7G,GACpB,GAAIuI,GAAe,GAAIC,eACvBD,GAAIE,KAAK,MAAO5B,GAAK,GACrB0B,EAAIG,aAAe,cAChBH,EAAII,kBACLJ,EAAII,iBAAiB,sBAEvBJ,EAAIZ,QAAU,SAAS/F,GACrB5B,EAAG4B,IAEL2G,EAAIvB,OAAS,WACX,GAAsB,IAAnBuB,EAAIK,WAAP,CAGA,GAAInI,GAAO,GAAIiH,YAAWa,EAAIM,SAC9BjB,GAAUnH,EAAMT,KAGlBuI,EAAIO,OAGN,QAASC,GAAW1C,GAClB,GAAiBhB,SAAdgB,EAAO,GAAkB,CAG1B,IAAI,GAFAlF,GAAIkF,EAAO7G,OACX8D,EAAS,GAAIoE,YAAWvG,GACpB7B,EAAE,EAAK6B,EAAF7B,IAAOA,EAClBgE,EAAOhE,GAAK+G,EAAO5D,IAAInD,EAEzB,OAAOgE,GAEP,MAAO,IAAIoE,YAAWrB,GAI1B,QAAS2C,GAAQnC,EAAK7G,GACpB0G,EAAQuC,SAAS,WACf,IACE,GAAI5C,GAAS6C,EAAarC,EACvBR,GACDuB,EAAUmB,EAAW1C,GAASrG,GAE9BA,EAAG,GAAImJ,OAAM,2BAEf,MAAMvH,GACN5B,EAAG4B,MA3GT,GAAIwH,GAAgB7K,EAAQ,IACxBkD,EAAgBlD,EAAQ,GACxBuJ,EAAgBvJ,EAAQ,IAAUuJ,UAGlCoB,GAFgB3K,EAAQ,IACRA,EAAQ,IACRA,EAAQ,IA2G5BI,GAAOD,QAAU,SAAmBmI,EAAKwC,EAAMrJ,GACzCA,IACFA,EAAKqJ,EACLA,EAAO,GAET,IAAIC,GAAMF,EAAKG,QAAQ1C,EACvB,QAAOwC,GAAQC,EAAIE,eACjB,IAAK,OACHlB,EAAQzB,EAAK7G,EACf,MACA,SACK2G,EAAO7B,SAAS+B,KACjBA,EAAM,QAAUwC,EAAO,WAAaxC,EAAI3B,SAAS,WAEb,IAAnC2B,EAAI4C,QAAQ,mBACbT,EAAQnC,EAAK7G,GAEb4G,EAAaC,EAAK7G,OTqiBIlB,KAAKJ,EAASH,EAAoB,GAAIA,EAAoB,IAAIoI,SAItF,SAAShI,EAAQD,GUrqBvB,QAAAgL,KACAC,GAAA,EACAC,EAAApK,OACAqK,EAAAD,EAAApJ,OAAAqJ,GAEAC,EAAA,GAEAD,EAAArK,QACAuK,IAIA,QAAAA,KACA,IAAAJ,EAAA,CAGA,GAAAK,GAAAC,WAAAP,EACAC,IAAA,CAGA,KADA,GAAAO,GAAAL,EAAArK,OACA0K,GAAA,CAGA,IAFAN,EAAAC,EACAA,OACAC,EAAAI,GACAN,GACAA,EAAAE,GAAAK,KAGAL,GAAA,GACAI,EAAAL,EAAArK,OAEAoK,EAAA,KACAD,GAAA,EACAS,aAAAJ,IAiBA,QAAAK,GAAAC,EAAA/E,GACArC,KAAAoH,MACApH,KAAAqC,QAYA,QAAAgF,MAtEA,GAGAX,GAHAlD,EAAA/H,EAAAD,WACAmL,KACAF,GAAA,EAEAG,EAAA,EAsCApD,GAAAuC,SAAA,SAAAqB,GACA,GAAAnG,GAAA,GAAA/E,OAAAoL,UAAAhL,OAAA,EACA,IAAAgL,UAAAhL,OAAA,EACA,OAAAF,GAAA,EAAuBA,EAAAkL,UAAAhL,OAAsBF,IAC7C6E,EAAA7E,EAAA,GAAAkL,UAAAlL,EAGAuK,GAAAtF,KAAA,GAAA8F,GAAAC,EAAAnG,IACA,IAAA0F,EAAArK,QAAAmK,GACAM,WAAAF,EAAA,IASAM,EAAApF,UAAAkF,IAAA,WACAjH,KAAAoH,IAAAG,MAAA,KAAAvH,KAAAqC,QAEAmB,EAAAgE,MAAA,UACAhE,EAAAiE,SAAA,EACAjE,EAAAkE,OACAlE,EAAAmE,QACAnE,EAAAoE,QAAA,GACApE,EAAAqE,YAIArE,EAAAsE,GAAAT,EACA7D,EAAAuE,YAAAV,EACA7D,EAAAwE,KAAAX,EACA7D,EAAAyE,IAAAZ,EACA7D,EAAA0E,eAAAb,EACA7D,EAAA2E,mBAAAd,EACA7D,EAAA4E,KAAAf,EAEA7D,EAAA6E,QAAA,SAAAC,GACA,SAAArC,OAAA,qCAGAzC,EAAA+E,IAAA,WAA2B,WAC3B/E,EAAAgF,MAAA,SAAAC,GACA,SAAAxC,OAAA,mCAEAzC,EAAAkF,MAAA,WAA4B,WVorBtB,SAASjN,EAAQD,EAASH,IW9wBhC,SAAAoI,EAAAkF,GAkDA,QAAAC,KACA,QAAAC,MACA,IACA,GAAA5M,GAAA,GAAAuI,YAAA,EAGA,OAFAvI,GAAA6M,IAAA,WAA2B,WAC3B7M,EAAAsH,YAAAsF,EACA,KAAA5M,EAAA6M,OACA7M,EAAAsH,cAAAsF,GACA,kBAAA5M,GAAAgJ,UACA,IAAAhJ,EAAAgJ,SAAA,KAAA8D,WACG,MAAAC,GACH,UAIA,QAAAC,KACA,MAAAxF,GAAAyF,oBACA,WACA,WAeA,QAAAzF,GAAA0F,GACA,MAAAnJ,gBAAAyD,IAMAzD,KAAA1D,OAAA,EACA0D,KAAAoJ,OAAAjH,OAGA,gBAAAgH,GACAE,EAAArJ,KAAAmJ,GAIA,gBAAAA,GACAG,EAAAtJ,KAAAmJ,EAAA7B,UAAAhL,OAAA,EAAAgL,UAAA,WAIAiC,EAAAvJ,KAAAmJ,IAlBA7B,UAAAhL,OAAA,KAAAmH,GAAA0F,EAAA7B,UAAA,IACA,GAAA7D,GAAA0F,GAoBA,QAAAE,GAAAG,EAAAlN,GAEA,GADAkN,EAAAC,EAAAD,EAAA,EAAAlN,EAAA,IAAAoN,EAAApN,KACAmH,EAAAyF,oBACA,OAAA9M,GAAA,EAAmBE,EAAAF,EAAYA,IAC/BoN,EAAApN,GAAA,CAGA,OAAAoN,GAGA,QAAAF,GAAAE,EAAAG,EAAAC,IACA,gBAAAA,IAAA,KAAAA,OAAA,OAGA,IAAAtN,GAAA,EAAAyM,EAAAY,EAAAC,EAIA,OAHAJ,GAAAC,EAAAD,EAAAlN,GAEAkN,EAAAK,MAAAF,EAAAC,GACAJ,EAGA,QAAAD,GAAAC,EAAAM,GACA,GAAArG,EAAA7B,SAAAkI,GAAA,MAAAC,GAAAP,EAAAM,EAEA,IAAA3N,EAAA2N,GAAA,MAAAE,GAAAR,EAAAM,EAEA,UAAAA,EACA,SAAAG,WAAA,kDAGA,uBAAAC,aAAA,CACA,GAAAJ,EAAA3G,iBAAA+G,aACA,MAAAC,GAAAX,EAAAM,EAEA,IAAAA,YAAAI,aACA,MAAAE,GAAAZ,EAAAM,GAIA,MAAAA,GAAAxN,OAAA+N,EAAAb,EAAAM,GAEAQ,EAAAd,EAAAM,GAGA,QAAAC,GAAAP,EAAArG,GACA,GAAA7G,GAAA,EAAAoN,EAAAvG,EAAA7G,OAGA,OAFAkN,GAAAC,EAAAD,EAAAlN,GACA6G,EAAAoH,KAAAf,EAAA,IAAAlN,GACAkN,EAGA,QAAAQ,GAAAR,EAAAnH,GACA,GAAA/F,GAAA,EAAAoN,EAAArH,EAAA/F,OACAkN,GAAAC,EAAAD,EAAAlN,EACA,QAAAF,GAAA,EAAiBE,EAAAF,EAAYA,GAAA,EAC7BoN,EAAApN,GAAA,IAAAiG,EAAAjG,EAEA,OAAAoN,GAIA,QAAAW,GAAAX,EAAAnH,GACA,GAAA/F,GAAA,EAAAoN,EAAArH,EAAA/F,OACAkN,GAAAC,EAAAD,EAAAlN,EAIA,QAAAF,GAAA,EAAiBE,EAAAF,EAAYA,GAAA,EAC7BoN,EAAApN,GAAA,IAAAiG,EAAAjG,EAEA,OAAAoN,GAGA,QAAAY,GAAAZ,EAAAnH,GASA,MARAoB,GAAAyF,qBAEA7G,EAAA0G,WACAS,EAAA/F,EAAA+G,SAAA,GAAAhG,YAAAnC,KAGAmH,EAAAW,EAAAX,EAAA,GAAAhF,YAAAnC,IAEAmH,EAGA,QAAAa,GAAAb,EAAAnH,GACA,GAAA/F,GAAA,EAAAoN,EAAArH,EAAA/F,OACAkN,GAAAC,EAAAD,EAAAlN,EACA,QAAAF,GAAA,EAAiBE,EAAAF,EAAYA,GAAA,EAC7BoN,EAAApN,GAAA,IAAAiG,EAAAjG,EAEA,OAAAoN,GAKA,QAAAc,GAAAd,EAAAM,GACA,GAAAzH,GACA/F,EAAA,CAEA,YAAAwN,EAAA3D,MAAAhK,EAAA2N,EAAAvM,QACA8E,EAAAyH,EAAAvM,KACAjB,EAAA,EAAAoN,EAAArH,EAAA/F,SAEAkN,EAAAC,EAAAD,EAAAlN,EAEA,QAAAF,GAAA,EAAiBE,EAAAF,EAAYA,GAAA,EAC7BoN,EAAApN,GAAA,IAAAiG,EAAAjG,EAEA,OAAAoN,GAQA,QAAAC,GAAAD,EAAAlN,GACAmH,EAAAyF,qBAEAM,EAAA/F,EAAA+G,SAAA,GAAAhG,YAAAlI,IACAkN,EAAAiB,UAAAhH,EAAA1B,YAGAyH,EAAAlN,SACAkN,EAAAlG,WAAA,EAGA,IAAAoH,GAAA,IAAApO,MAAAmH,EAAAkH,WAAA,CAGA,OAFAD,KAAAlB,EAAAJ,OAAAwB,GAEApB,EAGA,QAAAE,GAAApN,GAGA,GAAAA,GAAA2M,IACA,SAAA4B,YAAA,0DACA5B,IAAAjH,SAAA,aAEA,UAAA1F,EAGA,QAAAwO,GAAAC,EAAAnB,GACA,KAAA5J,eAAA8K,IAAA,UAAAA,GAAAC,EAAAnB,EAEA,IAAAoB,GAAA,GAAAvH,GAAAsH,EAAAnB,EAEA,cADAoB,GAAA5B,OACA4B,EA+EA,QAAAjC,GAAAY,EAAAC,GACA,gBAAAD,OAAA,GAAAA,EAEA,IAAA3C,GAAA2C,EAAArN,MACA,QAAA0K,EAAA,QAIA,KADA,GAAAiE,IAAA,IAEA,OAAArB,GACA,YACA,aAEA,UACA,WACA,MAAA5C,EACA,YACA,YACA,MAAAkE,GAAAvB,GAAArN,MACA,YACA,YACA,cACA,eACA,SAAA0K,CACA,WACA,MAAAA,KAAA,CACA,cACA,MAAAmE,GAAAxB,GAAArN,MACA,SACA,GAAA2O,EAAA,MAAAC,GAAAvB,GAAArN,MACAsN,IAAA,GAAAA,GAAAwB,cACAH,GAAA,GAUA,QAAAI,GAAAzB,EAAA0B,EAAAC,GACA,GAAAN,IAAA,CAQA,IANAK,EAAA,EAAAA,EACAC,EAAApJ,SAAAoJ,OAAAC,IAAAxL,KAAA1D,OAAA,EAAAiP,EAEA3B,MAAA,QACA,EAAA0B,MAAA,GACAC,EAAAvL,KAAA1D,SAAAiP,EAAAvL,KAAA1D,QACAgP,GAAAC,EAAA,QAEA,QACA,OAAA3B,GACA,UACA,MAAA6B,GAAAzL,KAAAsL,EAAAC,EAEA,YACA,YACA,MAAAG,GAAA1L,KAAAsL,EAAAC,EAEA,aACA,MAAAI,GAAA3L,KAAAsL,EAAAC,EAEA,cACA,MAAAK,GAAA5L,KAAAsL,EAAAC,EAEA,cACA,MAAAM,GAAA7L,KAAAsL,EAAAC,EAEA,YACA,YACA,cACA,eACA,MAAAO,GAAA9L,KAAAsL,EAAAC,EAEA,SACA,GAAAN,EAAA,SAAAhB,WAAA,qBAAAL,EACAA,MAAA,IAAAwB,cACAH,GAAA,GAuFA,QAAAc,GAAAf,EAAArB,EAAAzH,EAAA5F,GACA4F,EAAA8J,OAAA9J,IAAA,CACA,IAAA+J,GAAAjB,EAAA1O,OAAA4F,CACA5F,IAGAA,EAAA0P,OAAA1P,GACAA,EAAA2P,IACA3P,EAAA2P,IAJA3P,EAAA2P,CASA,IAAAC,GAAAvC,EAAArN,MACA,IAAA4P,EAAA,eAAAjG,OAAA,qBAEA3J,GAAA4P,EAAA,IACA5P,EAAA4P,EAAA,EAEA,QAAA9P,GAAA,EAAiBE,EAAAF,EAAYA,IAAA,CAC7B,GAAA+P,GAAAC,SAAAzC,EAAA0C,OAAA,EAAAjQ,EAAA,MACA,IAAAkQ,MAAAH,GAAA,SAAAlG,OAAA,qBACA+E,GAAA9I,EAAA9F,GAAA+P,EAEA,MAAA/P,GAGA,QAAAmQ,GAAAvB,EAAArB,EAAAzH,EAAA5F,GACA,MAAAkQ,GAAAtB,EAAAvB,EAAAqB,EAAA1O,OAAA4F,GAAA8I,EAAA9I,EAAA5F,GAGA,QAAAmQ,GAAAzB,EAAArB,EAAAzH,EAAA5F,GACA,MAAAkQ,GAAAE,EAAA/C,GAAAqB,EAAA9I,EAAA5F,GAGA,QAAAqQ,GAAA3B,EAAArB,EAAAzH,EAAA5F,GACA,MAAAmQ,GAAAzB,EAAArB,EAAAzH,EAAA5F,GAGA,QAAAsQ,GAAA5B,EAAArB,EAAAzH,EAAA5F,GACA,MAAAkQ,GAAArB,EAAAxB,GAAAqB,EAAA9I,EAAA5F,GAGA,QAAAuQ,GAAA7B,EAAArB,EAAAzH,EAAA5F,GACA,MAAAkQ,GAAAM,EAAAnD,EAAAqB,EAAA1O,OAAA4F,GAAA8I,EAAA9I,EAAA5F,GAkFA,QAAAuP,GAAAb,EAAAM,EAAAC,GACA,WAAAD,GAAAC,IAAAP,EAAA1O,OACAyQ,EAAAC,cAAAhC,GAEA+B,EAAAC,cAAAhC,EAAAiC,MAAA3B,EAAAC,IAIA,QAAAG,GAAAV,EAAAM,EAAAC,GACAA,EAAArN,KAAAgP,IAAAlC,EAAA1O,OAAAiP,EAIA,KAHA,GAAA4B,MAEA/Q,EAAAkP,EACAC,EAAAnP,GAAA,CACA,GAAAgR,GAAApC,EAAA5O,GACAiR,EAAA,KACAC,EAAAF,EAAA,MACAA,EAAA,MACAA,EAAA,MACA,CAEA,IAAA7B,GAAAnP,EAAAkR,EAAA,CACA,GAAAC,GAAAC,EAAAC,EAAAC,CAEA,QAAAJ,GACA,OACA,IAAAF,IACAC,EAAAD,EAEA,MACA,QACAG,EAAAvC,EAAA5O,EAAA,GACA,WAAAmR,KACAG,GAAA,GAAAN,IAAA,KAAAG,EACAG,EAAA,MACAL,EAAAK,GAGA,MACA,QACAH,EAAAvC,EAAA5O,EAAA,GACAoR,EAAAxC,EAAA5O,EAAA,GACA,WAAAmR,IAAA,WAAAC,KACAE,GAAA,GAAAN,IAAA,OAAAG,IAAA,KAAAC,EACAE,EAAA,aAAAA,KAAA,SACAL,EAAAK,GAGA,MACA,QACAH,EAAAvC,EAAA5O,EAAA,GACAoR,EAAAxC,EAAA5O,EAAA,GACAqR,EAAAzC,EAAA5O,EAAA,GACA,WAAAmR,IAAA,WAAAC,IAAA,WAAAC,KACAC,GAAA,GAAAN,IAAA,OAAAG,IAAA,OAAAC,IAAA,KAAAC,EACAC,EAAA,eAAAA,IACAL,EAAAK,KAMA,OAAAL,GAGAA,EAAA,MACAC,EAAA,GACKD,EAAA,QAELA,GAAA,MACAF,EAAA9L,KAAAgM,IAAA,eACAA,EAAA,WAAAA,GAGAF,EAAA9L,KAAAgM,GACAjR,GAAAkR,EAGA,MAAAK,GAAAR,GAQA,QAAAQ,GAAAC,GACA,GAAA5G,GAAA4G,EAAAtR,MACA,IAAAuR,GAAA7G,EACA,MAAA8G,QAAAC,aAAAxG,MAAAuG,OAAAF,EAMA,KAFA,GAAAT,GAAA,GACA/Q,EAAA,EACA4K,EAAA5K,GACA+Q,GAAAW,OAAAC,aAAAxG,MACAuG,OACAF,EAAAX,MAAA7Q,KAAAyR,GAGA,OAAAV,GAGA,QAAAxB,GAAAX,EAAAM,EAAAC,GACA,GAAAyC,GAAA,EACAzC,GAAArN,KAAAgP,IAAAlC,EAAA1O,OAAAiP,EAEA,QAAAnP,GAAAkP,EAAqBC,EAAAnP,EAASA,IAC9B4R,GAAAF,OAAAC,aAAA,IAAA/C,EAAA5O,GAEA,OAAA4R,GAGA,QAAApC,GAAAZ,EAAAM,EAAAC,GACA,GAAAyC,GAAA,EACAzC,GAAArN,KAAAgP,IAAAlC,EAAA1O,OAAAiP,EAEA,QAAAnP,GAAAkP,EAAqBC,EAAAnP,EAASA,IAC9B4R,GAAAF,OAAAC,aAAA/C,EAAA5O,GAEA,OAAA4R,GAGA,QAAAvC,GAAAT,EAAAM,EAAAC,GACA,GAAAvE,GAAAgE,EAAA1O,SAEAgP,GAAA,EAAAA,OAAA,KACAC,GAAA,EAAAA,KAAAvE,KAAAuE,EAAAvE,EAGA,QADAiH,GAAA,GACA7R,EAAAkP,EAAqBC,EAAAnP,EAASA,IAC9B6R,GAAAC,EAAAlD,EAAA5O,GAEA,OAAA6R,GAGA,QAAAnC,GAAAd,EAAAM,EAAAC,GAGA,OAFA4C,GAAAnD,EAAAiC,MAAA3B,EAAAC,GACA4B,EAAA,GACA/Q,EAAA,EAAiBA,EAAA+R,EAAA7R,OAAkBF,GAAA,EACnC+Q,GAAAW,OAAAC,aAAAI,EAAA/R,GAAA,IAAA+R,EAAA/R,EAAA,GAEA,OAAA+Q,GA2CA,QAAAiB,GAAAlM,EAAAkE,EAAA9J,GACA,GAAA4F,EAAA,SAAAA,EAAA,SAAA2I,YAAA,qBACA,IAAA3I,EAAAkE,EAAA9J,EAAA,SAAAuO,YAAA,yCA+JA,QAAAwD,GAAArD,EAAAsD,EAAApM,EAAAkE,EAAAmI,EAAArB,GACA,IAAAzJ,EAAA7B,SAAAoJ,GAAA,SAAAf,WAAA,mCACA,IAAAqE,EAAAC,GAAArB,EAAAoB,EAAA,SAAAzD,YAAA,yBACA,IAAA3I,EAAAkE,EAAA4E,EAAA1O,OAAA,SAAAuO,YAAA,sBA4CA,QAAA2D,GAAAxD,EAAAsD,EAAApM,EAAAuM,GACA,EAAAH,MAAA,MAAAA,EAAA,EACA,QAAAlS,GAAA,EAAAsS,EAAAxQ,KAAAgP,IAAAlC,EAAA1O,OAAA4F,EAAA,GAAuDwM,EAAAtS,EAAOA,IAC9D4O,EAAA9I,EAAA9F,IAAAkS,EAAA,QAAAG,EAAArS,EAAA,EAAAA,MACA,GAAAqS,EAAArS,EAAA,EAAAA,GA8BA,QAAAuS,GAAA3D,EAAAsD,EAAApM,EAAAuM,GACA,EAAAH,MAAA,WAAAA,EAAA,EACA,QAAAlS,GAAA,EAAAsS,EAAAxQ,KAAAgP,IAAAlC,EAAA1O,OAAA4F,EAAA,GAAuDwM,EAAAtS,EAAOA,IAC9D4O,EAAA9I,EAAA9F,GAAAkS,IAAA,GAAAG,EAAArS,EAAA,EAAAA,GAAA,IA6IA,QAAAwS,GAAA5D,EAAAsD,EAAApM,EAAAkE,EAAAmI,EAAArB,GACA,GAAAoB,EAAAC,GAAArB,EAAAoB,EAAA,SAAAzD,YAAA,yBACA,IAAA3I,EAAAkE,EAAA4E,EAAA1O,OAAA,SAAAuO,YAAA,qBACA,MAAA3I,EAAA,SAAA2I,YAAA,sBAGA,QAAAgE,GAAA7D,EAAAsD,EAAApM,EAAAuM,EAAAK,GAKA,MAJAA,IACAF,EAAA5D,EAAAsD,EAAApM,EAAA,gDAEA6M,EAAAlF,MAAAmB,EAAAsD,EAAApM,EAAAuM,EAAA,MACAvM,EAAA,EAWA,QAAA8M,GAAAhE,EAAAsD,EAAApM,EAAAuM,EAAAK,GAKA,MAJAA,IACAF,EAAA5D,EAAAsD,EAAApM,EAAA,kDAEA6M,EAAAlF,MAAAmB,EAAAsD,EAAApM,EAAAuM,EAAA,MACAvM,EAAA,EAoLA,QAAA+M,GAAAC,GAIA,GAFAA,EAAAC,EAAAD,GAAAE,QAAAC,GAAA,IAEAH,EAAA5S,OAAA,UAEA,MAAA4S,EAAA5S,OAAA,OACA4S,GAAA,GAEA,OAAAA,GAGA,QAAAC,GAAAD,GACA,MAAAA,GAAAI,KAAAJ,EAAAI,OACAJ,EAAAE,QAAA,iBAGA,QAAAlB,GAAAjQ,GACA,UAAAA,EAAA,IAAAA,EAAA+D,SAAA,IACA/D,EAAA+D,SAAA,IAGA,QAAAkJ,GAAAvB,EAAA4F,GACAA,KAAA/D,GAMA,QALA6B,GACA/Q,EAAAqN,EAAArN,OACAkT,EAAA,KACArB,KAEA/R,EAAA,EAAiBE,EAAAF,EAAYA,IAAA,CAI7B,GAHAiR,EAAA1D,EAAA8F,WAAArT,GAGAiR,EAAA,aAAAA,EAAA,CAEA,IAAAmC,EAAA,CAEA,GAAAnC,EAAA,QAEAkC,GAAA,OAAApB,EAAA9M,KAAA,YACA,UACS,GAAAjF,EAAA,IAAAE,EAAA,EAETiT,GAAA,OAAApB,EAAA9M,KAAA,YACA,UAIAmO,EAAAnC,CAEA,UAIA,SAAAA,EAAA,EACAkC,GAAA,OAAApB,EAAA9M,KAAA,aACAmO,EAAAnC,CACA,UAIAA,GAAAmC,EAAA,UAAAnC,EAAA,iBACKmC,KAELD,GAAA,OAAApB,EAAA9M,KAAA,YAMA,IAHAmO,EAAA,KAGA,IAAAnC,EAAA,CACA,IAAAkC,GAAA,UACApB,GAAA9M,KAAAgM,OACK,SAAAA,EAAA,CACL,IAAAkC,GAAA,UACApB,GAAA9M,KACAgM,GAAA,MACA,GAAAA,EAAA,SAEK,UAAAA,EAAA,CACL,IAAAkC,GAAA,UACApB,GAAA9M,KACAgM,GAAA,OACAA,GAAA,SACA,GAAAA,EAAA,SAEK,cAAAA,GASL,SAAApH,OAAA,qBARA,KAAAsJ,GAAA,UACApB,GAAA9M,KACAgM,GAAA,OACAA,GAAA,UACAA,GAAA,SACA,GAAAA,EAAA,MAOA,MAAAc,GAGA,QAAAzB,GAAAwC,GAEA,OADAQ,MACAtT,EAAA,EAAiBA,EAAA8S,EAAA5S,OAAgBF,IAEjCsT,EAAArO,KAAA,IAAA6N,EAAAO,WAAArT,GAEA,OAAAsT,GAGA,QAAA5C,GAAAoC,EAAAK,GAGA,OAFAzT,GAAA6T,EAAAC,EACAF,KACAtT,EAAA,EAAiBA,EAAA8S,EAAA5S,WACjBiT,GAAA,MADiCnT,IAGjCN,EAAAoT,EAAAO,WAAArT,GACAuT,EAAA7T,GAAA,EACA8T,EAAA9T,EAAA,IACA4T,EAAArO,KAAAuO,GACAF,EAAArO,KAAAsO,EAGA,OAAAD,GAGA,QAAAvE,GAAA+D,GACA,MAAAnC,GAAA8C,YAAAZ,EAAAC,IAGA,QAAA1C,GAAAzP,EAAA+S,EAAA5N,EAAA5F,GACA,OAAAF,GAAA,EAAiBE,EAAAF,KACjBA,EAAA8F,GAAA4N,EAAAxT,QAAAF,GAAAW,EAAAT,QAD6BF,IAE7B0T,EAAA1T,EAAA8F,GAAAnF,EAAAX,EAEA,OAAAA;;;;;;AA9/CA,GAAA2Q,GAAA1R,EAAA,IACA0T,EAAA1T,EAAA,IACAc,EAAAd,EAAA,GAEAG,GAAAiI,SACAjI,EAAAsP,aACAtP,EAAAuU,kBAAA,GACAtM,EAAAkH,SAAA,IAEA,IAAAC,KA6BAnH,GAAAyF,oBAAA/G,SAAAwG,EAAAO,oBACAP,EAAAO,oBACAN,IA2KAnF,EAAAyF,sBACAzF,EAAA1B,UAAA0I,UAAAjG,WAAAzC,UACA0B,EAAAgH,UAAAjG,YAsCAf,EAAA7B,SAAA,SAAA/B,GACA,cAAAA,MAAAyD,YAGAG,EAAAuM,QAAA,SAAApQ,EAAAC,GACA,IAAA4D,EAAA7B,SAAAhC,KAAA6D,EAAA7B,SAAA/B,GACA,SAAAoK,WAAA,4BAGA,IAAArK,IAAAC,EAAA,QAOA,KALA,GAAA5C,GAAA2C,EAAAtD,OACAY,EAAA2C,EAAAvD,OAEAF,EAAA,EACA4K,EAAA9I,KAAAgP,IAAAjQ,EAAAC,GACA8J,EAAA5K,GACAwD,EAAAxD,KAAAyD,EAAAzD,MAEAA,CAQA,OALAA,KAAA4K,IACA/J,EAAA2C,EAAAxD,GACAc,EAAA2C,EAAAzD,IAGAc,EAAAD,EAAA,GACAA,EAAAC,EAAA,EACA,GAGAuG,EAAAwM,WAAA,SAAArG,GACA,OAAAkE,OAAAlE,GAAAwB,eACA,UACA,WACA,YACA,YACA,aACA,aACA,UACA,WACA,YACA,cACA,eACA,QACA,SACA,WAIA3H,EAAAnG,OAAA,SAAA4S,EAAA5T,GACA,IAAAH,EAAA+T,GAAA,SAAAjG,WAAA,6CAEA,QAAAiG,EAAA5T,OACA,UAAAmH,GAAA,EAGA,IAAArH,EACA,IAAA+F,SAAA7F,EAEA,IADAA,EAAA,EACAF,EAAA,EAAeA,EAAA8T,EAAA5T,OAAiBF,IAChCE,GAAA4T,EAAA9T,GAAAE,MAIA,IAAA0O,GAAA,GAAAvH,GAAAnH,GACA6T,EAAA,CACA,KAAA/T,EAAA,EAAaA,EAAA8T,EAAA5T,OAAiBF,IAAA,CAC9B,GAAAgU,GAAAF,EAAA9T,EACAgU,GAAA7F,KAAAS,EAAAmF,GACAA,GAAAC,EAAA9T,OAEA,MAAA0O,IAsCAvH,EAAAsF,aAGAtF,EAAA1B,UAAAzF,OAAA6F,OACAsB,EAAA1B,UAAAqH,OAAAjH,OA6CAsB,EAAA1B,UAAAC,SAAA,WACA,GAAA1F,GAAA,EAAA0D,KAAA1D,MACA,YAAAA,EAAA,GACA,IAAAgL,UAAAhL,OAAAoP,EAAA1L,KAAA,EAAA1D,GACA+O,EAAA9D,MAAAvH,KAAAsH,YAGA7D,EAAA1B,UAAAsO,OAAA,SAAAxQ,GACA,IAAA4D,EAAA7B,SAAA/B,GAAA,SAAAoK,WAAA,4BACA,OAAAjK,QAAAH,GAAA,EACA,IAAA4D,EAAAuM,QAAAhQ,KAAAH,IAGA4D,EAAA1B,UAAAuO,QAAA,WACA,GAAApB,GAAA,GACAX,EAAA/S,EAAAuU,iBAKA,OAJA/P,MAAA1D,OAAA,IACA4S,EAAAlP,KAAAgC,SAAA,QAAAuM,GAAAgC,MAAA,SAAkD9P,KAAA,KAClDT,KAAA1D,OAAAiS,IAAAW,GAAA,UAEA,WAAAA,EAAA,KAGAzL,EAAA1B,UAAAiO,QAAA,SAAAnQ,GACA,IAAA4D,EAAA7B,SAAA/B,GAAA,SAAAoK,WAAA,4BACA,OAAAjK,QAAAH,EAAA,EACA4D,EAAAuM,QAAAhQ,KAAAH,IAGA4D,EAAA1B,UAAAwE,QAAA,SAAAlI,EAAAmS,GAyBA,QAAAC,GAAAxU,EAAAoC,EAAAmS,GAEA,OADAE,GAAA,GACAtU,EAAA,EAAmBoU,EAAApU,EAAAH,EAAAK,OAA6BF,IAChD,GAAAH,EAAAuU,EAAApU,KAAAiC,EAAA,KAAAqS,EAAA,EAAAtU,EAAAsU,IAEA,GADA,KAAAA,MAAAtU,GACAA,EAAAsU,EAAA,IAAArS,EAAA/B,OAAA,MAAAkU,GAAAE,MAEAA,GAAA,EAGA,UA9BA,GAJAF,EAAA,WAAAA,EAAA,WACA,YAAAA,MAAA,aACAA,IAAA,EAEA,IAAAxQ,KAAA1D,OAAA,QACA,IAAAkU,GAAAxQ,KAAA1D,OAAA,QAKA,IAFA,EAAAkU,MAAAtS,KAAAqQ,IAAAvO,KAAA1D,OAAAkU,EAAA,IAEA,gBAAAnS,GACA,WAAAA,EAAA/B,OAAA,GACAwR,OAAA/L,UAAAwE,QAAA3K,KAAAoE,KAAA3B,EAAAmS,EAEA,IAAA/M,EAAA7B,SAAAvD,GACA,MAAAoS,GAAAzQ,KAAA3B,EAAAmS,EAEA,oBAAAnS,GACA,MAAAoF,GAAAyF,qBAAA,aAAA1E,WAAAzC,UAAAwE,QACA/B,WAAAzC,UAAAwE,QAAA3K,KAAAoE,KAAA3B,EAAAmS,GAEAC,EAAAzQ,MAAA3B,GAAAmS,EAgBA,UAAAvG,WAAA,yCAIAxG,EAAA1B,UAAAxC,IAAA,SAAA2C,GAEA,MADAyO,SAAAC,IAAA,6DACA5Q,KAAA6Q,UAAA3O,IAIAuB,EAAA1B,UAAArC,IAAA,SAAAoR,EAAA5O,GAEA,MADAyO,SAAAC,IAAA,6DACA5Q,KAAA+Q,WAAAD,EAAA5O,IAkDAuB,EAAA1B,UAAA8H,MAAA,SAAAF,EAAAzH,EAAA5F,EAAAsN,GAEA,GAAAzH,SAAAD,EACA0H,EAAA,OACAtN,EAAA0D,KAAA1D,OACA4F,EAAA,MAEG,IAAAC,SAAA7F,GAAA,gBAAA4F,GACH0H,EAAA1H,EACA5F,EAAA0D,KAAA1D,OACA4F,EAAA,MAEG,IAAA8O,SAAA9O,GACHA,EAAA,EAAAA,EACA8O,SAAA1U,IACAA,EAAA,EAAAA,EACA6F,SAAAyH,MAAA,UAEAA,EAAAtN,EACAA,EAAA6F,YAGG,CACH,GAAA8O,GAAArH,CACAA,GAAA1H,EACAA,EAAA,EAAA5F,EACAA,EAAA2U,EAGA,GAAAhF,GAAAjM,KAAA1D,OAAA4F,CAGA,KAFAC,SAAA7F,KAAA2P,KAAA3P,EAAA2P,GAEAtC,EAAArN,OAAA,MAAAA,GAAA,EAAA4F,MAAAlC,KAAA1D,OACA,SAAAuO,YAAA,yCAGAjB,OAAA,OAGA,KADA,GAAAqB,IAAA,IAEA,OAAArB,GACA,UACA,MAAAmC,GAAA/L,KAAA2J,EAAAzH,EAAA5F,EAEA,YACA,YACA,MAAAiQ,GAAAvM,KAAA2J,EAAAzH,EAAA5F,EAEA,aACA,MAAAmQ,GAAAzM,KAAA2J,EAAAzH,EAAA5F,EAEA,cACA,MAAAqQ,GAAA3M,KAAA2J,EAAAzH,EAAA5F,EAEA,cAEA,MAAAsQ,GAAA5M,KAAA2J,EAAAzH,EAAA5F,EAEA,YACA,YACA,cACA,eACA,MAAAuQ,GAAA7M,KAAA2J,EAAAzH,EAAA5F,EAEA,SACA,GAAA2O,EAAA,SAAAhB,WAAA,qBAAAL,EACAA,IAAA,GAAAA,GAAAwB,cACAH,GAAA,IAKAxH,EAAA1B,UAAAmP,OAAA,WACA,OACA/K,KAAA,SACA5I,KAAArB,MAAA6F,UAAAkL,MAAArR,KAAAoE,KAAAmR,MAAAnR,KAAA,IAwFA,IAAA6N,GAAA,IA8DApK,GAAA1B,UAAAkL,MAAA,SAAA3B,EAAAC,GACA,GAAAvE,GAAAhH,KAAA1D,MACAgP,OACAC,EAAApJ,SAAAoJ,EAAAvE,IAAAuE,EAEA,EAAAD,GACAA,GAAAtE,EACA,EAAAsE,MAAA,IACGA,EAAAtE,IACHsE,EAAAtE,GAGA,EAAAuE,GACAA,GAAAvE,EACA,EAAAuE,MAAA,IACGA,EAAAvE,IACHuE,EAAAvE,GAGAsE,EAAAC,MAAAD,EAEA,IAAA8F,EACA,IAAA3N,EAAAyF,oBACAkI,EAAA3N,EAAA+G,SAAAxK,KAAAiF,SAAAqG,EAAAC,QACG,CACH,GAAA8F,GAAA9F,EAAAD,CACA8F,GAAA,GAAA3N,GAAA4N,EAAAlP,OACA,QAAA/F,GAAA,EAAmBiV,EAAAjV,EAAcA,IACjCgV,EAAAhV,GAAA4D,KAAA5D,EAAAkP,GAMA,MAFA8F,GAAA9U,SAAA8U,EAAAhI,OAAApJ,KAAAoJ,QAAApJ,MAEAoR,GAWA3N,EAAA1B,UAAAuP,WAAA,SAAApP,EAAA6G,EAAA+F,GACA5M,EAAA,EAAAA,EACA6G,EAAA,EAAAA,EACA+F,GAAAV,EAAAlM,EAAA6G,EAAA/I,KAAA1D,OAKA,KAHA,GAAA+B,GAAA2B,KAAAkC,GACAqP,EAAA,EACAnV,EAAA,IACAA,EAAA2M,IAAAwI,GAAA,MACAlT,GAAA2B,KAAAkC,EAAA9F,GAAAmV,CAGA,OAAAlT,IAGAoF,EAAA1B,UAAAyP,WAAA,SAAAtP,EAAA6G,EAAA+F,GACA5M,EAAA,EAAAA,EACA6G,EAAA,EAAAA,EACA+F,GACAV,EAAAlM,EAAA6G,EAAA/I,KAAA1D,OAKA,KAFA,GAAA+B,GAAA2B,KAAAkC,IAAA6G,GACAwI,EAAA,EACAxI,EAAA,IAAAwI,GAAA,MACAlT,GAAA2B,KAAAkC,IAAA6G,GAAAwI,CAGA,OAAAlT,IAGAoF,EAAA1B,UAAA8O,UAAA,SAAA3O,EAAA4M,GAEA,MADAA,IAAAV,EAAAlM,EAAA,EAAAlC,KAAA1D,QACA0D,KAAAkC,IAGAuB,EAAA1B,UAAA0P,aAAA,SAAAvP,EAAA4M,GAEA,MADAA,IAAAV,EAAAlM,EAAA,EAAAlC,KAAA1D,QACA0D,KAAAkC,GAAAlC,KAAAkC,EAAA,OAGAuB,EAAA1B,UAAA2P,aAAA,SAAAxP,EAAA4M,GAEA,MADAA,IAAAV,EAAAlM,EAAA,EAAAlC,KAAA1D,QACA0D,KAAAkC,IAAA,EAAAlC,KAAAkC,EAAA,IAGAuB,EAAA1B,UAAA4P,aAAA,SAAAzP,EAAA4M,GAGA,MAFAA,IAAAV,EAAAlM,EAAA,EAAAlC,KAAA1D,SAEA0D,KAAAkC,GACAlC,KAAAkC,EAAA,MACAlC,KAAAkC,EAAA,QACA,SAAAlC,KAAAkC,EAAA,IAGAuB,EAAA1B,UAAA6P,aAAA,SAAA1P,EAAA4M,GAGA,MAFAA,IAAAV,EAAAlM,EAAA,EAAAlC,KAAA1D,QAEA,SAAA0D,KAAAkC,IACAlC,KAAAkC,EAAA,OACAlC,KAAAkC,EAAA,MACAlC,KAAAkC,EAAA,KAGAuB,EAAA1B,UAAA8P,UAAA,SAAA3P,EAAA6G,EAAA+F,GACA5M,EAAA,EAAAA,EACA6G,EAAA,EAAAA,EACA+F,GAAAV,EAAAlM,EAAA6G,EAAA/I,KAAA1D,OAKA,KAHA,GAAA+B,GAAA2B,KAAAkC,GACAqP,EAAA,EACAnV,EAAA,IACAA,EAAA2M,IAAAwI,GAAA,MACAlT,GAAA2B,KAAAkC,EAAA9F,GAAAmV,CAMA,OAJAA,IAAA,IAEAlT,GAAAkT,IAAAlT,GAAAH,KAAA4T,IAAA,IAAA/I,IAEA1K,GAGAoF,EAAA1B,UAAAgQ,UAAA,SAAA7P,EAAA6G,EAAA+F,GACA5M,EAAA,EAAAA,EACA6G,EAAA,EAAAA,EACA+F,GAAAV,EAAAlM,EAAA6G,EAAA/I,KAAA1D,OAKA,KAHA,GAAAF,GAAA2M,EACAwI,EAAA,EACAlT,EAAA2B,KAAAkC,IAAA9F,GACAA,EAAA,IAAAmV,GAAA,MACAlT,GAAA2B,KAAAkC,IAAA9F,GAAAmV,CAMA,OAJAA,IAAA,IAEAlT,GAAAkT,IAAAlT,GAAAH,KAAA4T,IAAA,IAAA/I,IAEA1K,GAGAoF,EAAA1B,UAAAiQ,SAAA,SAAA9P,EAAA4M,GAEA,MADAA,IAAAV,EAAAlM,EAAA,EAAAlC,KAAA1D,QACA,IAAA0D,KAAAkC,GACA,QAAAlC,KAAAkC,GAAA,GADAlC,KAAAkC,IAIAuB,EAAA1B,UAAAkQ,YAAA,SAAA/P,EAAA4M,GACAA,GAAAV,EAAAlM,EAAA,EAAAlC,KAAA1D,OACA,IAAA+B,GAAA2B,KAAAkC,GAAAlC,KAAAkC,EAAA,KACA,cAAA7D,EAAA,WAAAA,KAGAoF,EAAA1B,UAAAmQ,YAAA,SAAAhQ,EAAA4M,GACAA,GAAAV,EAAAlM,EAAA,EAAAlC,KAAA1D,OACA,IAAA+B,GAAA2B,KAAAkC,EAAA,GAAAlC,KAAAkC,IAAA,CACA,cAAA7D,EAAA,WAAAA,KAGAoF,EAAA1B,UAAAoQ,YAAA,SAAAjQ,EAAA4M,GAGA,MAFAA,IAAAV,EAAAlM,EAAA,EAAAlC,KAAA1D,QAEA0D,KAAAkC,GACAlC,KAAAkC,EAAA,MACAlC,KAAAkC,EAAA,OACAlC,KAAAkC,EAAA,QAGAuB,EAAA1B,UAAAqQ,YAAA,SAAAlQ,EAAA4M,GAGA,MAFAA,IAAAV,EAAAlM,EAAA,EAAAlC,KAAA1D,QAEA0D,KAAAkC,IAAA,GACAlC,KAAAkC,EAAA,OACAlC,KAAAkC,EAAA,MACAlC,KAAAkC,EAAA,IAGAuB,EAAA1B,UAAAsQ,YAAA,SAAAnQ,EAAA4M,GAEA,MADAA,IAAAV,EAAAlM,EAAA,EAAAlC,KAAA1D,QACAyS,EAAAuD,KAAAtS,KAAAkC,GAAA,SAGAuB,EAAA1B,UAAAwQ,YAAA,SAAArQ,EAAA4M,GAEA,MADAA,IAAAV,EAAAlM,EAAA,EAAAlC,KAAA1D,QACAyS,EAAAuD,KAAAtS,KAAAkC,GAAA,SAGAuB,EAAA1B,UAAAyQ,aAAA,SAAAtQ,EAAA4M,GAEA,MADAA,IAAAV,EAAAlM,EAAA,EAAAlC,KAAA1D,QACAyS,EAAAuD,KAAAtS,KAAAkC,GAAA,SAGAuB,EAAA1B,UAAA0Q,aAAA,SAAAvQ,EAAA4M,GAEA,MADAA,IAAAV,EAAAlM,EAAA,EAAAlC,KAAA1D,QACAyS,EAAAuD,KAAAtS,KAAAkC,GAAA,SASAuB,EAAA1B,UAAA2Q,YAAA,SAAApE,EAAApM,EAAA6G,EAAA+F,GACAR,KACApM,EAAA,EAAAA,EACA6G,EAAA,EAAAA,EACA+F,GAAAT,EAAArO,KAAAsO,EAAApM,EAAA6G,EAAA7K,KAAA4T,IAAA,IAAA/I,GAAA,EAEA,IAAAwI,GAAA,EACAnV,EAAA,CAEA,KADA4D,KAAAkC,GAAA,IAAAoM,IACAlS,EAAA2M,IAAAwI,GAAA,MACAvR,KAAAkC,EAAA9F,GAAAkS,EAAAiD,EAAA,GAGA,OAAArP,GAAA6G,GAGAtF,EAAA1B,UAAA4Q,YAAA,SAAArE,EAAApM,EAAA6G,EAAA+F,GACAR,KACApM,EAAA,EAAAA,EACA6G,EAAA,EAAAA,EACA+F,GAAAT,EAAArO,KAAAsO,EAAApM,EAAA6G,EAAA7K,KAAA4T,IAAA,IAAA/I,GAAA,EAEA,IAAA3M,GAAA2M,EAAA,EACAwI,EAAA,CAEA,KADAvR,KAAAkC,EAAA9F,GAAA,IAAAkS,IACAlS,GAAA,IAAAmV,GAAA,MACAvR,KAAAkC,EAAA9F,GAAAkS,EAAAiD,EAAA,GAGA,OAAArP,GAAA6G,GAGAtF,EAAA1B,UAAAgP,WAAA,SAAAzC,EAAApM,EAAA4M,GAMA,MALAR,MACApM,EAAA,EAAAA,EACA4M,GAAAT,EAAArO,KAAAsO,EAAApM,EAAA,SACAuB,EAAAyF,sBAAAoF,EAAApQ,KAAAC,MAAAmQ,IACAtO,KAAAkC,GAAA,IAAAoM,EACApM,EAAA,GAWAuB,EAAA1B,UAAA6Q,cAAA,SAAAtE,EAAApM,EAAA4M,GAUA,MATAR,MACApM,EAAA,EAAAA,EACA4M,GAAAT,EAAArO,KAAAsO,EAAApM,EAAA,WACAuB,EAAAyF,qBACAlJ,KAAAkC,GAAA,IAAAoM,EACAtO,KAAAkC,EAAA,GAAAoM,IAAA,GAEAE,EAAAxO,KAAAsO,EAAApM,GAAA,GAEAA,EAAA,GAGAuB,EAAA1B,UAAA8Q,cAAA,SAAAvE,EAAApM,EAAA4M,GAUA,MATAR,MACApM,EAAA,EAAAA,EACA4M,GAAAT,EAAArO,KAAAsO,EAAApM,EAAA,WACAuB,EAAAyF,qBACAlJ,KAAAkC,GAAAoM,IAAA,EACAtO,KAAAkC,EAAA,OAAAoM,GAEAE,EAAAxO,KAAAsO,EAAApM,GAAA,GAEAA,EAAA,GAUAuB,EAAA1B,UAAA+Q,cAAA,SAAAxE,EAAApM,EAAA4M,GAYA,MAXAR,MACApM,EAAA,EAAAA,EACA4M,GAAAT,EAAArO,KAAAsO,EAAApM,EAAA,gBACAuB,EAAAyF,qBACAlJ,KAAAkC,EAAA,GAAAoM,IAAA,GACAtO,KAAAkC,EAAA,GAAAoM,IAAA,GACAtO,KAAAkC,EAAA,GAAAoM,IAAA,EACAtO,KAAAkC,GAAA,IAAAoM,GAEAK,EAAA3O,KAAAsO,EAAApM,GAAA,GAEAA,EAAA,GAGAuB,EAAA1B,UAAAgR,cAAA,SAAAzE,EAAApM,EAAA4M,GAYA,MAXAR,MACApM,EAAA,EAAAA,EACA4M,GAAAT,EAAArO,KAAAsO,EAAApM,EAAA,gBACAuB,EAAAyF,qBACAlJ,KAAAkC,GAAAoM,IAAA,GACAtO,KAAAkC,EAAA,GAAAoM,IAAA,GACAtO,KAAAkC,EAAA,GAAAoM,IAAA,EACAtO,KAAAkC,EAAA,OAAAoM,GAEAK,EAAA3O,KAAAsO,EAAApM,GAAA,GAEAA,EAAA,GAGAuB,EAAA1B,UAAAiR,WAAA,SAAA1E,EAAApM,EAAA6G,EAAA+F,GAGA,GAFAR,KACApM,EAAA,EAAAA,GACA4M,EAAA,CACA,GAAAmE,GAAA/U,KAAA4T,IAAA,IAAA/I,EAAA,EAEAsF,GAAArO,KAAAsO,EAAApM,EAAA6G,EAAAkK,EAAA,GAAAA,GAGA,GAAA7W,GAAA,EACAmV,EAAA,EACA2B,EAAA,EAAA5E,EAAA,GAEA,KADAtO,KAAAkC,GAAA,IAAAoM,IACAlS,EAAA2M,IAAAwI,GAAA,MACAvR,KAAAkC,EAAA9F,IAAAkS,EAAAiD,GAAA,GAAA2B,EAAA,GAGA,OAAAhR,GAAA6G,GAGAtF,EAAA1B,UAAAoR,WAAA,SAAA7E,EAAApM,EAAA6G,EAAA+F,GAGA,GAFAR,KACApM,EAAA,EAAAA,GACA4M,EAAA,CACA,GAAAmE,GAAA/U,KAAA4T,IAAA,IAAA/I,EAAA,EAEAsF,GAAArO,KAAAsO,EAAApM,EAAA6G,EAAAkK,EAAA,GAAAA,GAGA,GAAA7W,GAAA2M,EAAA,EACAwI,EAAA,EACA2B,EAAA,EAAA5E,EAAA,GAEA,KADAtO,KAAAkC,EAAA9F,GAAA,IAAAkS,IACAlS,GAAA,IAAAmV,GAAA,MACAvR,KAAAkC,EAAA9F,IAAAkS,EAAAiD,GAAA,GAAA2B,EAAA,GAGA,OAAAhR,GAAA6G,GAGAtF,EAAA1B,UAAAqR,UAAA,SAAA9E,EAAApM,EAAA4M,GAOA,MANAR,MACApM,EAAA,EAAAA,EACA4M,GAAAT,EAAArO,KAAAsO,EAAApM,EAAA,YACAuB,EAAAyF,sBAAAoF,EAAApQ,KAAAC,MAAAmQ,IACA,EAAAA,MAAA,IAAAA,EAAA,GACAtO,KAAAkC,GAAA,IAAAoM,EACApM,EAAA,GAGAuB,EAAA1B,UAAAsR,aAAA,SAAA/E,EAAApM,EAAA4M,GAUA,MATAR,MACApM,EAAA,EAAAA,EACA4M,GAAAT,EAAArO,KAAAsO,EAAApM,EAAA,gBACAuB,EAAAyF,qBACAlJ,KAAAkC,GAAA,IAAAoM,EACAtO,KAAAkC,EAAA,GAAAoM,IAAA,GAEAE,EAAAxO,KAAAsO,EAAApM,GAAA,GAEAA,EAAA,GAGAuB,EAAA1B,UAAAuR,aAAA,SAAAhF,EAAApM,EAAA4M,GAUA,MATAR,MACApM,EAAA,EAAAA,EACA4M,GAAAT,EAAArO,KAAAsO,EAAApM,EAAA,gBACAuB,EAAAyF,qBACAlJ,KAAAkC,GAAAoM,IAAA,EACAtO,KAAAkC,EAAA,OAAAoM,GAEAE,EAAAxO,KAAAsO,EAAApM,GAAA,GAEAA,EAAA,GAGAuB,EAAA1B,UAAAwR,aAAA,SAAAjF,EAAApM,EAAA4M,GAYA,MAXAR,MACApM,EAAA,EAAAA,EACA4M,GAAAT,EAAArO,KAAAsO,EAAApM,EAAA,0BACAuB,EAAAyF,qBACAlJ,KAAAkC,GAAA,IAAAoM,EACAtO,KAAAkC,EAAA,GAAAoM,IAAA,EACAtO,KAAAkC,EAAA,GAAAoM,IAAA,GACAtO,KAAAkC,EAAA,GAAAoM,IAAA,IAEAK,EAAA3O,KAAAsO,EAAApM,GAAA,GAEAA,EAAA,GAGAuB,EAAA1B,UAAAyR,aAAA,SAAAlF,EAAApM,EAAA4M,GAaA,MAZAR,MACApM,EAAA,EAAAA,EACA4M,GAAAT,EAAArO,KAAAsO,EAAApM,EAAA,0BACA,EAAAoM,MAAA,WAAAA,EAAA,GACA7K,EAAAyF,qBACAlJ,KAAAkC,GAAAoM,IAAA,GACAtO,KAAAkC,EAAA,GAAAoM,IAAA,GACAtO,KAAAkC,EAAA,GAAAoM,IAAA,EACAtO,KAAAkC,EAAA,OAAAoM,GAEAK,EAAA3O,KAAAsO,EAAApM,GAAA,GAEAA,EAAA,GAiBAuB,EAAA1B,UAAA0R,aAAA,SAAAnF,EAAApM,EAAA4M,GACA,MAAAD,GAAA7O,KAAAsO,EAAApM,GAAA,EAAA4M,IAGArL,EAAA1B,UAAA2R,aAAA,SAAApF,EAAApM,EAAA4M,GACA,MAAAD,GAAA7O,KAAAsO,EAAApM,GAAA,EAAA4M,IAWArL,EAAA1B,UAAA4R,cAAA,SAAArF,EAAApM,EAAA4M,GACA,MAAAE,GAAAhP,KAAAsO,EAAApM,GAAA,EAAA4M,IAGArL,EAAA1B,UAAA6R,cAAA,SAAAtF,EAAApM,EAAA4M,GACA,MAAAE,GAAAhP,KAAAsO,EAAApM,GAAA,EAAA4M,IAIArL,EAAA1B,UAAAwI,KAAA,SAAAsJ,EAAAC,EAAAxI,EAAAC,GAQA,GAPAD,MAAA,GACAC,GAAA,IAAAA,MAAAvL,KAAA1D,QACAwX,GAAAD,EAAAvX,SAAAwX,EAAAD,EAAAvX,QACAwX,MAAA,GACAvI,EAAA,GAAAD,EAAAC,MAAAD,GAGAC,IAAAD,EAAA,QACA,QAAAuI,EAAAvX,QAAA,IAAA0D,KAAA1D,OAAA,QAGA,MAAAwX,EACA,SAAAjJ,YAAA,4BAEA,MAAAS,MAAAtL,KAAA1D,OAAA,SAAAuO,YAAA,4BACA,MAAAU,EAAA,SAAAV,YAAA,0BAGAU,GAAAvL,KAAA1D,SAAAiP,EAAAvL,KAAA1D,QACAuX,EAAAvX,OAAAwX,EAAAvI,EAAAD,IACAC,EAAAsI,EAAAvX,OAAAwX,EAAAxI,EAGA,IACAlP,GADA4K,EAAAuE,EAAAD,CAGA,IAAAtL,OAAA6T,GAAAC,EAAAxI,GAAAC,EAAAuI,EAEA,IAAA1X,EAAA4K,EAAA,EAAqB5K,GAAA,EAAQA,IAC7ByX,EAAAzX,EAAA0X,GAAA9T,KAAA5D,EAAAkP,OAEG,QAAAtE,IAAAvD,EAAAyF,oBAEH,IAAA9M,EAAA,EAAe4K,EAAA5K,EAASA,IACxByX,EAAAzX,EAAA0X,GAAA9T,KAAA5D,EAAAkP,OAGAuI,GAAAE,KAAA/T,KAAAiF,SAAAqG,IAAAtE,GAAA8M,EAGA,OAAA9M,IAIAvD,EAAA1B,UAAAiS,KAAA,SAAA1F,EAAAhD,EAAAC,GAKA,GAJA+C,MAAA,GACAhD,MAAA,GACAC,MAAAvL,KAAA1D,QAEAgP,EAAAC,EAAA,SAAAV,YAAA,cAGA,IAAAU,IAAAD,GACA,IAAAtL,KAAA1D,OAAA,CAEA,KAAAgP,MAAAtL,KAAA1D,OAAA,SAAAuO,YAAA,sBACA,MAAAU,KAAAvL,KAAA1D,OAAA,SAAAuO,YAAA,oBAEA,IAAAzO,EACA,oBAAAkS,GACA,IAAAlS,EAAAkP,EAAmBC,EAAAnP,EAASA,IAC5B4D,KAAA5D,GAAAkS,MAEG,CACH,GAAAH,GAAAjD,EAAAoD,EAAAtM,YACAgF,EAAAmH,EAAA7R,MACA,KAAAF,EAAAkP,EAAmBC,EAAAnP,EAASA,IAC5B4D,KAAA5D,GAAA+R,EAAA/R,EAAA4K,GAIA,MAAAhH,QAOAyD,EAAA1B,UAAAkS,cAAA,WACA,sBAAAzP,YAAA,CACA,GAAAf,EAAAyF,oBACA,UAAAzF,GAAAzD,MAAAmD,MAGA,QADA6H,GAAA,GAAAxG,YAAAxE,KAAA1D,QACAF,EAAA,EAAA4K,EAAAgE,EAAA1O,OAAuC0K,EAAA5K,EAASA,GAAA,EAChD4O,EAAA5O,GAAA4D,KAAA5D,EAEA,OAAA4O,GAAA7H,OAGA,SAAA8G,WAAA,sDAOA,IAAAiK,GAAAzQ,EAAA1B,SAKA0B,GAAA+G,SAAA,SAAAvO,GA4DA,MA3DAA,GAAAsH,YAAAE,EACAxH,EAAAqH,WAAA,EAGArH,EAAA8X,KAAA9X,EAAAyD,IAGAzD,EAAAsD,IAAA2U,EAAA3U,IACAtD,EAAAyD,IAAAwU,EAAAxU,IAEAzD,EAAA4N,MAAAqK,EAAArK,MACA5N,EAAA+F,SAAAkS,EAAAlS,SACA/F,EAAAkY,eAAAD,EAAAlS,SACA/F,EAAAiV,OAAAgD,EAAAhD,OACAjV,EAAAoU,OAAA6D,EAAA7D,OACApU,EAAA+T,QAAAkE,EAAAlE,QACA/T,EAAAsK,QAAA2N,EAAA3N,QACAtK,EAAAsO,KAAA2J,EAAA3J,KACAtO,EAAAgR,MAAAiH,EAAAjH,MACAhR,EAAAqV,WAAA4C,EAAA5C,WACArV,EAAAuV,WAAA0C,EAAA1C,WACAvV,EAAA4U,UAAAqD,EAAArD,UACA5U,EAAAwV,aAAAyC,EAAAzC,aACAxV,EAAAyV,aAAAwC,EAAAxC,aACAzV,EAAA0V,aAAAuC,EAAAvC,aACA1V,EAAA2V,aAAAsC,EAAAtC,aACA3V,EAAA4V,UAAAqC,EAAArC,UACA5V,EAAA8V,UAAAmC,EAAAnC,UACA9V,EAAA+V,SAAAkC,EAAAlC,SACA/V,EAAAgW,YAAAiC,EAAAjC,YACAhW,EAAAiW,YAAAgC,EAAAhC,YACAjW,EAAAkW,YAAA+B,EAAA/B,YACAlW,EAAAmW,YAAA8B,EAAA9B,YACAnW,EAAAoW,YAAA6B,EAAA7B,YACApW,EAAAsW,YAAA2B,EAAA3B,YACAtW,EAAAuW,aAAA0B,EAAA1B,aACAvW,EAAAwW,aAAAyB,EAAAzB,aACAxW,EAAA8U,WAAAmD,EAAAnD,WACA9U,EAAAyW,YAAAwB,EAAAxB,YACAzW,EAAA0W,YAAAuB,EAAAvB,YACA1W,EAAA2W,cAAAsB,EAAAtB,cACA3W,EAAA4W,cAAAqB,EAAArB,cACA5W,EAAA6W,cAAAoB,EAAApB,cACA7W,EAAA8W,cAAAmB,EAAAnB,cACA9W,EAAA+W,WAAAkB,EAAAlB,WACA/W,EAAAkX,WAAAe,EAAAf,WACAlX,EAAAmX,UAAAc,EAAAd,UACAnX,EAAAoX,aAAAa,EAAAb,aACApX,EAAAqX,aAAAY,EAAAZ,aACArX,EAAAsX,aAAAW,EAAAX,aACAtX,EAAAuX,aAAAU,EAAAV,aACAvX,EAAAwX,aAAAS,EAAAT,aACAxX,EAAAyX,aAAAQ,EAAAR,aACAzX,EAAA0X,cAAAO,EAAAP,cACA1X,EAAA2X,cAAAM,EAAAN,cACA3X,EAAA+X,KAAAE,EAAAF,KACA/X,EAAAqU,QAAA4D,EAAA5D,QACArU,EAAAgY,cAAAC,EAAAD,cAEAhY,EAGA,IAAAoT,IAAA,uBX65B8BzT,KAAKJ,EAASH,EAAoB,IAAIoI,OAAS,WAAa,MAAOzD,WAI3F,SAASvE,EAAQD,EAASH,GY7xEhC,GAAA+Y,GAAA,oEAEC,SAAA5Y,GACD,YAcA,SAAA6Y,GAAAC,GACA,GAAA3T,GAAA2T,EAAA7E,WAAA,EACA,OAAA9O,KAAA4T,GACA5T,IAAA6T,EACA,GACA7T,IAAA8T,GACA9T,IAAA+T,EACA,GACAC,EAAAhU,EACA,GACAgU,EAAA,GAAAhU,EACAA,EAAAgU,EAAA,MACAC,EAAA,GAAAjU,EACAA,EAAAiU,EACAC,EAAA,GAAAlU,EACAA,EAAAkU,EAAA,GADA,OAIA,QAAAC,GAAAC,GAuBA,QAAA1T,GAAAyP,GACA7U,EAAA+Y,KAAAlE,EAvBA,GAAA1U,GAAAsS,EAAAuG,EAAAC,EAAAC,EAAAlZ,CAEA,IAAA8Y,EAAAzY,OAAA,IACA,SAAA2J,OAAA,iDAQA,IAAAe,GAAA+N,EAAAzY,MACA6Y,GAAA,MAAAJ,EAAAzW,OAAA0I,EAAA,WAAA+N,EAAAzW,OAAA0I,EAAA,OAGA/K,EAAA,GAAAmZ,GAAA,EAAAL,EAAAzY,OAAA,EAAA6Y,GAGAF,EAAAE,EAAA,EAAAJ,EAAAzY,OAAA,EAAAyY,EAAAzY,MAEA,IAAA0Y,GAAA,CAMA,KAAA5Y,EAAA,EAAAsS,EAAA,EAAoBuG,EAAA7Y,EAAOA,GAAA,EAAAsS,GAAA,EAC3BwG,EAAAb,EAAAU,EAAAzW,OAAAlC,KAAA,GAAAiY,EAAAU,EAAAzW,OAAAlC,EAAA,QAAAiY,EAAAU,EAAAzW,OAAAlC,EAAA,OAAAiY,EAAAU,EAAAzW,OAAAlC,EAAA,IACAiF,GAAA,SAAA6T,IAAA,IACA7T,GAAA,MAAA6T,IAAA,GACA7T,EAAA,IAAA6T,EAYA,OATA,KAAAC,GACAD,EAAAb,EAAAU,EAAAzW,OAAAlC,KAAA,EAAAiY,EAAAU,EAAAzW,OAAAlC,EAAA,OACAiF,EAAA,IAAA6T,IACG,IAAAC,IACHD,EAAAb,EAAAU,EAAAzW,OAAAlC,KAAA,GAAAiY,EAAAU,EAAAzW,OAAAlC,EAAA,OAAAiY,EAAAU,EAAAzW,OAAAlC,EAAA,OACAiF,EAAA6T,GAAA,OACA7T,EAAA,IAAA6T,IAGAjZ,EAGA,QAAAoZ,GAAAtS,GAMA,QAAAuS,GAAAC,GACA,MAAAnB,GAAA9V,OAAAiX,GAGA,QAAAC,GAAAD,GACA,MAAAD,GAAAC,GAAA,OAAAD,EAAAC,GAAA,OAAAD,EAAAC,GAAA,MAAAD,EAAA,GAAAC,GAVA,GAAAnZ,GAGAqZ,EAAAnZ,EAFAoZ,EAAA3S,EAAAzG,OAAA,EACAqZ,EAAA,EAYA,KAAAvZ,EAAA,EAAAE,EAAAyG,EAAAzG,OAAAoZ,EAAiDpZ,EAAAF,EAAYA,GAAA,EAC7DqZ,GAAA1S,EAAA3G,IAAA,KAAA2G,EAAA3G,EAAA,OAAA2G,EAAA3G,EAAA,GACAuZ,GAAAH,EAAAC,EAIA,QAAAC,GACA,OACAD,EAAA1S,IAAAzG,OAAA,GACAqZ,GAAAL,EAAAG,GAAA,GACAE,GAAAL,EAAAG,GAAA,MACAE,GAAA,IACA,MACA,QACAF,GAAA1S,IAAAzG,OAAA,OAAAyG,IAAAzG,OAAA,GACAqZ,GAAAL,EAAAG,GAAA,IACAE,GAAAL,EAAAG,GAAA,MACAE,GAAAL,EAAAG,GAAA,MACAE,GAAA,IAIA,MAAAA,GAjHA,GAAAP,GAAA,mBAAA5Q,YACAA,WACAtI,MAEAqY,EAAA,IAAA9E,WAAA,GACAgF,EAAA,IAAAhF,WAAA,GACAkF,EAAA,IAAAlF,WAAA,GACAoF,EAAA,IAAApF,WAAA,GACAmF,EAAA,IAAAnF,WAAA,GACA+E,EAAA,IAAA/E,WAAA,GACAiF,EAAA,IAAAjF,WAAA,EA0GAjU,GAAAqU,YAAAiF,EACAtZ,EAAAwR,cAAAqI,GACsD7Z,IZoyEhD,SAASC,EAAQD,Ga/5EvBA,EAAA8W,KAAA,SAAAnP,EAAAjB,EAAA0T,EAAAC,EAAAC,GACA,GAAA9M,GAAAnN,EACAka,EAAA,EAAAD,EAAAD,EAAA,EACAG,GAAA,GAAAD,GAAA,EACAE,EAAAD,GAAA,EACAE,EAAA,GACA9Z,EAAAwZ,EAAAE,EAAA,IACAxT,EAAAsT,EAAA,KACAO,EAAAhT,EAAAjB,EAAA9F,EAOA,KALAA,GAAAkG,EAEA0G,EAAAmN,GAAA,IAAAD,GAAA,EACAC,KAAAD,EACAA,GAAAH,EACQG,EAAA,EAAWlN,EAAA,IAAAA,EAAA7F,EAAAjB,EAAA9F,MAAAkG,EAAA4T,GAAA,GAKnB,IAHAra,EAAAmN,GAAA,IAAAkN,GAAA,EACAlN,KAAAkN,EACAA,GAAAL,EACQK,EAAA,EAAWra,EAAA,IAAAA,EAAAsH,EAAAjB,EAAA9F,MAAAkG,EAAA4T,GAAA,GAEnB,OAAAlN,EACAA,EAAA,EAAAiN,MACG,IAAAjN,IAAAgN,EACH,MAAAna,GAAAua,KAAAD,EAAA,OAAA3K,IAEA3P,IAAAqC,KAAA4T,IAAA,EAAA+D,GACA7M,GAAAiN,EAEA,OAAAE,EAAA,MAAAta,EAAAqC,KAAA4T,IAAA,EAAA9I,EAAA6M,IAGAra,EAAAqO,MAAA,SAAA1G,EAAAmL,EAAApM,EAAA0T,EAAAC,EAAAC,GACA,GAAA9M,GAAAnN,EAAAC,EACAia,EAAA,EAAAD,EAAAD,EAAA,EACAG,GAAA,GAAAD,GAAA,EACAE,EAAAD,GAAA,EACAK,EAAA,KAAAR,EAAA3X,KAAA4T,IAAA,OAAA5T,KAAA4T,IAAA,SACA1V,EAAAwZ,EAAA,EAAAE,EAAA,EACAxT,EAAAsT,EAAA,KACAO,EAAA,EAAA7H,GAAA,IAAAA,GAAA,IAAAA,EAAA,GAmCA,KAjCAA,EAAApQ,KAAAgC,IAAAoO,GAEAhC,MAAAgC,QAAA9C,KACA3P,EAAAyQ,MAAAgC,GAAA,IACAtF,EAAAgN,IAEAhN,EAAA9K,KAAAC,MAAAD,KAAA0S,IAAAtC,GAAApQ,KAAAoY,KACAhI,GAAAxS,EAAAoC,KAAA4T,IAAA,GAAA9I,IAAA,IACAA,IACAlN,GAAA,GAGAwS,GADAtF,EAAAiN,GAAA,EACAI,EAAAva,EAEAua,EAAAnY,KAAA4T,IAAA,IAAAmE,GAEA3H,EAAAxS,GAAA,IACAkN,IACAlN,GAAA,GAGAkN,EAAAiN,GAAAD,GACAna,EAAA,EACAmN,EAAAgN,GACKhN,EAAAiN,GAAA,GACLpa,GAAAyS,EAAAxS,EAAA,GAAAoC,KAAA4T,IAAA,EAAA+D,GACA7M,GAAAiN,IAEApa,EAAAyS,EAAApQ,KAAA4T,IAAA,EAAAmE,EAAA,GAAA/X,KAAA4T,IAAA,EAAA+D,GACA7M,EAAA,IAIQ6M,GAAA,EAAW1S,EAAAjB,EAAA9F,GAAA,IAAAP,EAAAO,GAAAkG,EAAAzG,GAAA,IAAAga,GAAA,GAInB,IAFA7M,KAAA6M,EAAAha,EACAka,GAAAF,EACQE,EAAA,EAAU5S,EAAAjB,EAAA9F,GAAA,IAAA4M,EAAA5M,GAAAkG,EAAA0G,GAAA,IAAA+M,GAAA,GAElB5S,EAAAjB,EAAA9F,EAAAkG,IAAA,IAAA6T,Ibu6EM,SAAS1a,EAAQD,Gcz/EvB,GAAAwG,MAAiBA,QAEjBvG,GAAAD,QAAAU,MAAAC,SAAA,SAAAF,GACA,wBAAA+F,EAAApG,KAAAK,KdigFM,SAASR,EAAQD,EAASH,IepgFhC,SAAAmI,GAyBA,QAAA+S,GAAAC,EAAAC,GAGA,OADAC,GAAA,EACAta,EAAAoa,EAAAla,OAAA,EAAgCF,GAAA,EAAQA,IAAA,CACxC,GAAAua,GAAAH,EAAApa,EACA,OAAAua,EACAH,EAAAI,OAAAxa,EAAA,GACK,OAAAua,GACLH,EAAAI,OAAAxa,EAAA,GACAsa,KACKA,IACLF,EAAAI,OAAAxa,EAAA,GACAsa,KAKA,GAAAD,EACA,KAAUC,IAAMA,EAChBF,EAAAK,QAAA,KAIA,OAAAL,GA+JA,QAAAM,GAAAC,EAAAC,GACA,GAAAD,EAAAD,OAAA,MAAAC,GAAAD,OAAAE,EAEA,QADA7J,MACA/Q,EAAA,EAAmBA,EAAA2a,EAAAza,OAAeF,IAClC4a,EAAAD,EAAA3a,KAAA2a,IAAA5J,EAAA9L,KAAA0V,EAAA3a,GAEA,OAAA+Q,GAhKA,GAAA8J,GACA,gEACAC,EAAA,SAAAC,GACA,MAAAF,GAAAG,KAAAD,GAAAlK,MAAA,GAKAzR,GAAA6b,QAAA,WAIA,OAHAC,GAAA,GACAC,GAAA,EAEAnb,EAAAkL,UAAAhL,OAAA,EAAoCF,GAAA,KAAAmb,EAA8Bnb,IAAA,CAClE,GAAA8J,GAAA9J,GAAA,EAAAkL,UAAAlL,GAAAoH,EAAA+E,KAGA,oBAAArC,GACA,SAAA+D,WAAA,4CACK/D,KAILoR,EAAApR,EAAA,IAAAoR,EACAC,EAAA,MAAArR,EAAA5H,OAAA,IAWA,MAJAgZ,GAAAf,EAAAO,EAAAQ,EAAAE,MAAA,cAAAzb,GACA,QAAAA,KACGwb,GAAA9W,KAAA,MAEH8W,EAAA,QAAAD,GAAA,KAKA9b,EAAAic,UAAA,SAAAvR,GACA,GAAAwR,GAAAlc,EAAAkc,WAAAxR,GACAyR,EAAA,MAAAtL,EAAAnG,EAAA,GAcA,OAXAA,GAAAqQ,EAAAO,EAAA5Q,EAAAsR,MAAA,cAAAzb,GACA,QAAAA,KACG2b,GAAAjX,KAAA,KAEHyF,GAAAwR,IACAxR,EAAA,KAEAA,GAAAyR,IACAzR,GAAA,MAGAwR,EAAA,QAAAxR,GAIA1K,EAAAkc,WAAA,SAAAxR,GACA,YAAAA,EAAA5H,OAAA,IAIA9C,EAAAiF,KAAA,WACA,GAAAmX,GAAA1b,MAAA6F,UAAAkL,MAAArR,KAAA0L,UAAA,EACA,OAAA9L,GAAAic,UAAAX,EAAAc,EAAA,SAAA7b,EAAAmJ,GACA,mBAAAnJ,GACA,SAAAkO,WAAA,yCAEA,OAAAlO,KACG0E,KAAA,OAMHjF,EAAAqc,SAAA,SAAAtb,EAAAub,GAIA,QAAAxI,GAAArT,GAEA,IADA,GAAAqP,GAAA,EACUA,EAAArP,EAAAK,QACV,KAAAL,EAAAqP,GAD8BA,KAK9B,IADA,GAAAC,GAAAtP,EAAAK,OAAA,EACUiP,GAAA,GACV,KAAAtP,EAAAsP,GADoBA,KAIpB,MAAAD,GAAAC,KACAtP,EAAAgR,MAAA3B,EAAAC,EAAAD,EAAA,GAfA/O,EAAAf,EAAA6b,QAAA9a,GAAA8P,OAAA,GACAyL,EAAAtc,EAAA6b,QAAAS,GAAAzL,OAAA,EAsBA,QALA0L,GAAAzI,EAAA/S,EAAAib,MAAA,MACAQ,EAAA1I,EAAAwI,EAAAN,MAAA,MAEAlb,EAAA4B,KAAAgP,IAAA6K,EAAAzb,OAAA0b,EAAA1b,QACA2b,EAAA3b,EACAF,EAAA,EAAiBE,EAAAF,EAAYA,IAC7B,GAAA2b,EAAA3b,KAAA4b,EAAA5b,GAAA,CACA6b,EAAA7b,CACA,OAKA,OADA8b,MACA9b,EAAA6b,EAA+B7b,EAAA2b,EAAAzb,OAAsBF,IACrD8b,EAAA7W,KAAA,KAKA,OAFA6W,KAAA5a,OAAA0a,EAAA/K,MAAAgL,IAEAC,EAAAzX,KAAA,MAGAjF,EAAA2c,IAAA,IACA3c,EAAA4c,UAAA,IAEA5c,EAAA6c,QAAA,SAAAnS,GACA,GAAA9F,GAAA8W,EAAAhR,GACAoS,EAAAlY,EAAA,GACAqI,EAAArI,EAAA,EAEA,OAAAkY,IAAA7P,GAKAA,IAEAA,IAAA4D,OAAA,EAAA5D,EAAAnM,OAAA,IAGAgc,EAAA7P,GARA,KAYAjN,EAAA+c,SAAA,SAAArS,EAAAE,GACA,GAAA4Q,GAAAE,EAAAhR,GAAA,EAKA,OAHAE,IAAA4Q,EAAA3K,OAAA,GAAAjG,EAAA9J,UAAA8J,IACA4Q,IAAA3K,OAAA,EAAA2K,EAAA1a,OAAA8J,EAAA9J,SAEA0a,GAIAxb,EAAA6K,QAAA,SAAAH,GACA,MAAAgR,GAAAhR,GAAA,GAaA,IAAAmG,GAAA,WAAAA,OAAA,IACA,SAAA6C,EAAA5D,EAAAtE,GAAkC,MAAAkI,GAAA7C,OAAAf,EAAAtE,IAClC,SAAAkI,EAAA5D,EAAAtE,GAEA,MADA,GAAAsE,MAAA4D,EAAA5S,OAAAgP,GACA4D,EAAA7C,OAAAf,EAAAtE,Mf0gF8BpL,KAAKJ,EAASH,EAAoB,KAI1D,SAASI,EAAQD,GgBjtFvB,QAAAgd,GAAAxN,EAAA9G,EAAAC,EAAAsU,GAUA,QAAAC,GAAAC,GACA,GAAAC,GAAAD,EAAArc,MACA,MAAAsc,KAAA,KAAAA,IAAA,EACA,kEACA,OAAAA,GAbA,GAAA7c,GAAA,EAEA0c,EAAAtW,SAAAsW,KAAuCA,EACvCI,EAAA1W,SAAAsW,EAAAK,KAAA,KAAAL,EAAAK,KACAC,EAAA5W,SAAAsW,EAAAE,QAAA,KAAAF,EAAAE,OAEA,OAAAzU,GAAA,GAAAC,GAAAD,EAAA,OAAAC,EAAA,MACA,4BAUA6G,GAAAjP,KAAA,GAAkBiP,EAAAjP,KAAA,GAAiBiP,EAAAjP,KAAA,GACnCiP,EAAAjP,KAAA,GAAkBiP,EAAAjP,KAAA,GAAiBiP,EAAAjP,KAAA,EAGnC,IAAAid,GAAA,EACAC,EAAA,CACA,WAAAF,EAAA,CAEA,IADA,GAAAG,GAAAR,EAAAK,GACAG,IAAA,KAAAF,CAGA,IAFAE,EAAA,GAAAF,IACAA,EACA7W,SAAAsW,EAAAQ,WAAA,CAEA,GADAA,EAAAR,EAAAQ,WACAA,GAAAC,EAAA,qCAKA,QAAAD,EACA,iDAeA,GATAjO,EAAAjP,KAAA,IAAAmI,EAA0B8G,EAAAjP,KAAAmI,GAAA,MAC1B8G,EAAAjP,KAAA,IAAAoI,EAA2B6G,EAAAjP,KAAAoI,GAAA,MAE3B6G,EAAAjP,MAAA,OAAAgd,EAAA,OACAC,EACAhO,EAAAjP,KAAAkd,EACAjO,EAAAjP,KAAA,EAGA,OAAAgd,EACA,OAAA3c,GAAA,EAAA+c,EAAAJ,EAAAzc,OAA+C6c,EAAA/c,IAAQA,EAAA,CACvD,GAAAgd,GAAAL,EAAA3c,EACA4O,GAAAjP,KAAAqd,GAAA,OACApO,EAAAjP,KAAAqd,GAAA,MACApO,EAAAjP,KAAA,IAAAqd,EAIA,UAAAP,EAAA,CACA,KAAAA,KAAA,MACA,0BAEA7N,GAAAjP,KAAA,GAAoBiP,EAAAjP,KAAA,IAAiBiP,EAAAjP,KAAA,GAErCiP,EAAAjP,KAAA,GAAoBiP,EAAAjP,KAAA,GAAiBiP,EAAAjP,KAAA,GAAiBiP,EAAAjP,KAAA,GACtDiP,EAAAjP,KAAA,GAAoBiP,EAAAjP,KAAA,GAAiBiP,EAAAjP,KAAA,GAAiBiP,EAAAjP,KAAA,GACtDiP,EAAAjP,KAAA,GAAoBiP,EAAAjP,KAAA,GAAiBiP,EAAAjP,KAAA,GAErCiP,EAAAjP,KAAA,EAAoBiP,EAAAjP,KAAA,EACpBiP,EAAAjP,KAAA,IAAA8c,EAAiC7N,EAAAjP,KAAA8c,GAAA,MACjC7N,EAAAjP,KAAA,EAIA,GAAAsd,IAAA,CAEArZ,MAAAsZ,SAAA,SAAArc,EAAAC,EAAAqc,EAAAC,EAAAC,EAAAC,GAOA,GANAL,KAAA,MAAyBtd,EAAKsd,GAAA,GAE9BK,EAAAvX,SAAAuX,KAAmCA,EAInC,EAAAzc,GAAA,EAAAC,GAAAD,EAAA,OAAAC,EAAA,MACA,mBAEA,OAAAqc,GAAA,GAAAC,GAAAD,EAAA,OAAAC,EAAA,MACA,4BAEA,IAAAC,EAAAnd,OAAAid,EAAAC,EACA,4CAEA,IAAAG,IAAA,EACAhB,EAAAe,EAAAf,OAMA,KALAxW,SAAAwW,GAAA,OAAAA,KACAgB,GAAA,EACAhB,EAAAI,GAGA5W,SAAAwW,GAAA,OAAAA,EACA,oDAMA,KAJA,GAAAC,GAAAF,EAAAC,GAGAiB,EAAA,EACAhB,IAAA,KAAAgB,CACAhB,GAAA,GAAAgB,CAEA,IAAAC,GAAA1X,SAAAuX,EAAAG,MAAA,EAAAH,EAAAG,MAeAC,EAAA3X,SAAAuX,EAAAI,SAAA,EAAAJ,EAAAI,QACA,MAAAA,KAAA,EACA,6BAEA,IAAAC,IAAA,EACAC,EAAA,CACA,IAAA7X,SAAAuX,EAAAO,aAAA,OAAAP,EAAAO,cACAF,GAAA,EACAC,EAAAN,EAAAO,YACA,EAAAD,MAAApB,GACA,+BAyBA,KAtBA,IAAAkB,GAAAC,GAAA,IAAAF,KAEA7O,EAAAjP,KAAA,GAAsBiP,EAAAjP,KAAA,IACtBiP,EAAAjP,KAAA,EAEAiP,EAAAjP,KAAA+d,GAAA,GAAAC,KAAA,OACA/O,EAAAjP,KAAA,IAAA8d,EAA8B7O,EAAAjP,KAAA8d,GAAA,MAC9B7O,EAAAjP,KAAAie,EACAhP,EAAAjP,KAAA,GAIAiP,EAAAjP,KAAA,GACAiP,EAAAjP,KAAA,IAAAkB,EAAwB+N,EAAAjP,KAAAkB,GAAA,MACxB+N,EAAAjP,KAAA,IAAAmB,EAAwB8N,EAAAjP,KAAAmB,GAAA,MACxB8N,EAAAjP,KAAA,IAAAwd,EAAwBvO,EAAAjP,KAAAwd,GAAA,MACxBvO,EAAAjP,KAAA,IAAAyd,EAAwBxO,EAAAjP,KAAAyd,GAAA,MAGxBxO,EAAAjP,KAAA4d,KAAA,MAAAC,EAAA,IAGAD,KAAA,EACA,OAAAvd,GAAA,EAAA+c,EAAAR,EAAArc,OAA0C6c,EAAA/c,IAAQA,EAAA,CAClD,GAAAgd,GAAAT,EAAAvc,EACA4O,GAAAjP,KAAAqd,GAAA,OACApO,EAAAjP,KAAAqd,GAAA,MACApO,EAAAjP,KAAA,IAAAqd,EAIArd,EAAAme,EACAlP,EAAAjP,EAAA,EAAA6d,EAAA,EAAAA,EAAAH,IAGAzZ,KAAAuL,IAAA,WAKA,MAJA8N,MAAA,IACArO,EAAAjP,KAAA,GACAsd,GAAA,GAEAtd,GAMA,QAAAme,GAAAlP,EAAAjP,EAAA6d,EAAAO,GAeA,QAAAC,GAAAC,GACA,KAAAC,GAAAD,GACArP,EAAAjP,KAAA,IAAAwe,EACAA,IAAA,EAAgBD,GAAA,EAChBve,IAAAye,EAAA,MACAxP,EAAAwP,GAAA,IACAA,EAAAze,KAKA,QAAA0e,GAAA3e,GACAye,GAAAze,GAAAwe,EACAA,GAAAI,EACAN,EAAA,GA5BApP,EAAAjP,KAAA6d,CACA,IAAAY,GAAAze,IAEA4e,EAAA,GAAAf,EACAgB,EAAAD,EAAA,EACAE,EAAAF,EAAA,EACAG,EAAAD,EAAA,EAEAH,EAAAd,EAAA,EACAU,EAAA,EAGAC,EAAA,EAyDAQ,EAAAZ,EAAA,GAAAS,EACAI,IAEAP,GAAAE,EAGA,QAAAve,GAAA,EAAA+c,EAAAgB,EAAA7d,OAA2C6c,EAAA/c,IAAQA,EAAA,CACnD,GAAA6e,GAAAd,EAAA/d,GAAAwe,EACAM,EAAAH,GAAA,EAAAE,EACAE,EAAAH,EAAAE,EAGA,IAAA/Y,SAAAgZ,EAAA,CAWA,IAFAZ,GAAAQ,GAAAT,EACAA,GAAAI,EACAJ,GAAA,GACAtP,EAAAjP,KAAA,IAAAwe,EACAA,IAAA,EAAkBD,GAAA,EAClBve,IAAAye,EAAA,MACAxP,EAAAwP,GAAA,IACAA,EAAAze,IAIA,QAAA+e,GACAL,EAAAE,GACAG,EAAAD,EAAA,EACAH,EAAAd,EAAA,EACAoB,OAOAF,GAAA,GAAAJ,OACAM,EAAAE,GAAAJ,KAGAC,EAAAE,MAEAF,GAAAI,EAmBA,MAfAV,GAAAM,GACAN,EAAAI,GAGAT,EAAA,GAKAI,EAAA,IAAAze,EACAiP,EAAAwP,GAAA,GAEAxP,EAAAwP,GAAAze,EAAAye,EAAA,EACAxP,EAAAjP,KAAA,GAEAA,EAGA,QAAA6I,GAAAoG,GACA,GAAAjP,GAAA,CAGA,SAAAiP,EAAAjP,MAAA,KAAAiP,EAAAjP,MAAA,KAAAiP,EAAAjP,MACA,KAAAiP,EAAAjP,MAAA,MAAAiP,EAAAjP,KAAA,aAAAiP,EAAAjP,KACA,kCAIA,IAAAmI,GAAA8G,EAAAjP,KAAAiP,EAAAjP,MAAA,EACAoI,EAAA6G,EAAAjP,KAAAiP,EAAAjP,MAAA,EACAqf,EAAApQ,EAAAjP,KACAsf,EAAAD,GAAA,EACAE,EAAA,EAAAF,EACAG,EAAA,GAAAD,EAAA,CACAtQ,GAAAjP,IACAiP,GAAAjP,IAEA,IAAAyf,GAAA,IAEAH,KACAG,EAAAzf,EACAA,GAAA,EAAAwf,EAGA,IAAAE,IAAA,EAEAC,KAEA7B,EAAA,EACAG,EAAA,KACAF,EAAA,EACAjB,EAAA,IAKA,KAHA7Y,KAAAkE,QACAlE,KAAAmE,SAEAsX,GAAA1f,EAAAiP,EAAA1O,QACA,OAAA0O,EAAAjP,MACA,QACA,OAAAiP,EAAAjP,MACA,SAEA,QAAAiP,EAAAjP,IAEA,IAAAiP,EAAAjP,EAAA,QAAAiP,EAAAjP,EAAA,QAAAiP,EAAAjP,EAAA,IACA,IAAAiP,EAAAjP,EAAA,QAAAiP,EAAAjP,EAAA,QAAAiP,EAAAjP,EAAA,IACA,IAAAiP,EAAAjP,EAAA,QAAAiP,EAAAjP,EAAA,QAAAiP,EAAAjP,EAAA,IACA,IAAAiP,EAAAjP,EAAA,SAAAiP,EAAAjP,EAAA,KAEA,GAAAiP,EAAAjP,EAAA,QAAAiP,EAAAjP,EAAA,QAAAiP,EAAAjP,EAAA,IACAA,GAAA,GACA8c,EAAA7N,EAAAjP,KAAAiP,EAAAjP,MAAA,EACAA,QAGA,KADAA,GAAA,KACA,CACA,GAAA4f,GAAA3Q,EAAAjP,IACA,QAAA4f,EAAA,KACA5f,IAAA4f,EAGA,KAEA,UACA,OAAA3Q,EAAAjP,MAAA,IAAAiP,EAAAjP,EAAA,GACA,wCACA,IAAA6f,GAAA5Q,EAAAjP,IACA8d,GAAA7O,EAAAjP,KAAAiP,EAAAjP,MAAA,EACAie,EAAAhP,EAAAjP,KACA,OAAA6f,KAAA5B,EAAA,MACAF,EAAA8B,GAAA,IACA7f,GACA,MAEA,UACA,QACA,GAAA4f,GAAA3Q,EAAAjP,IACA,QAAA4f,EAAA,KAEA5f,IAAA4f,EAEA,KAEA,SACA,yCAAA3Q,EAAAjP,EAAA,GAAAiG,SAAA,IAEA,KAEA,SACA,GAAA/E,GAAA+N,EAAAjP,KAAAiP,EAAAjP,MAAA,EACAmB,EAAA8N,EAAAjP,KAAAiP,EAAAjP,MAAA,EACAwd,EAAAvO,EAAAjP,KAAAiP,EAAAjP,MAAA,EACAyd,EAAAxO,EAAAjP,KAAAiP,EAAAjP,MAAA,EACA8f,EAAA7Q,EAAAjP,KACA+f,EAAAD,GAAA,EACAE,EAAAF,GAAA,IACAG,EAAA,EAAAH,EACAI,EAAA,GAAAD,EAAA,EACAE,EAAAV,EACAW,GAAA,CACA,IAAAL,EAAA,CACA,GAAAK,IAAA,CACAD,GAAAngB,EACAA,GAAA,EAAAkgB,EAGA,GAAAG,GAAArgB,CAGA,KADAA,MACA,CACA,GAAA4f,GAAA3Q,EAAAjP,IACA,QAAA4f,EAAA,KACA5f,IAAA4f,EAGAD,EAAAra,MAAqBpE,IAAAC,IAAAgH,MAAAqV,EAAApV,OAAAqV,EACrB2C,oBACAD,iBACAE,cACAC,YAAAtgB,EAAAqgB,EACApC,oBACAsC,aAAAP,EACAlC,QACAC,YACA,MAEA,SACA2B,GAAA,CACA,MAEA,SACA,6BAAAzQ,EAAAjP,EAAA,GAAAiG,SAAA,IAKAhC,KAAA6E,UAAA,WACA,MAAA6W,GAAApf,QAGA0D,KAAAuc,UAAA,WACA,MAAA1D,IAGA7Y,KAAAwc,UAAA,SAAAC,GACA,KAAAA,MAAAf,EAAApf,OACA,gCACA,OAAAof,GAAAe,IAGAzc,KAAA0c,uBAAA,SAAAD,EAAA9d,GACA,GAAAge,GAAA3c,KAAAwc,UAAAC,GACAG,EAAAD,EAAAzY,MAAAyY,EAAAxY,OACAgW,EAAA,GAAA3V,YAAAoY,EACAC,GACA7R,EAAA2R,EAAAP,YAAAjC,EAAAyC,EACA,IAAAV,GAAAS,EAAAT,eAKAY,EAAAH,EAAA3C,iBACA,QAAA8C,MAAA,IAKA,IAAAC,GAAAJ,EAAAzY,MACA8Y,EAAA9Y,EAAA6Y,EACAE,EAAAF,EAGAG,EAAA,GAAAP,EAAAzf,EAAAgH,EAAAyY,EAAA1f,GACAkgB,EAAA,IAAAR,EAAAzf,EAAAyf,EAAAxY,QAAAD,EAAAyY,EAAA1f,GACAmgB,EAAAF,EAEAG,EAAA,EAAAL,CAIAL,GAAAL,cAAA,IACAe,GAAA,EAAAnZ,EAAA,EAKA,QAFAoZ,GAAA,EAEAlhB,EAAA,EAAA+c,EAAAgB,EAAA7d,OAA6C6c,EAAA/c,IAAQA,EAAA,CACrD,GAAA8I,GAAAiV,EAAA/d,EAaA,IAXA,IAAA6gB,IACAG,GAAAC,EACAJ,EAAAF,EACAK,GAAAD,IACAE,EAAA,EAAAL,EAAA,EAAA9Y,GAAAoZ,EAAA,GAEAF,EAAAF,GAAAH,EAAAC,IAAAM,GAAA,GACAA,IAAA,IAIApY,IAAA4X,EACAM,GAAA,MACO,CACP,GAAAG,GAAAvS,EAAAkR,EAAA,EAAAhX,GACAsY,EAAAxS,EAAAkR,EAAA,EAAAhX,EAAA,GACArF,EAAAmL,EAAAkR,EAAA,EAAAhX,EAAA,EACAvG,GAAAye,KAAAvd,EACAlB,EAAAye,KAAAI,EACA7e,EAAAye,KAAAG,EACA5e,EAAAye,KAAA,MAEAH,IAKAjd,KAAAgF,uBAAA,SAAAyX,EAAA9d,GACA,GAAAge,GAAA3c,KAAAwc,UAAAC,GACAG,EAAAD,EAAAzY,MAAAyY,EAAAxY,OACAgW,EAAA,GAAA3V,YAAAoY,EACAC,GACA7R,EAAA2R,EAAAP,YAAAjC,EAAAyC,EACA,IAAAV,GAAAS,EAAAT,eAKAY,EAAAH,EAAA3C,iBACA,QAAA8C,MAAA,IAKA,IAAAC,GAAAJ,EAAAzY,MACA8Y,EAAA9Y,EAAA6Y,EACAE,EAAAF,EAGAG,EAAA,GAAAP,EAAAzf,EAAAgH,EAAAyY,EAAA1f,GACAkgB,EAAA,IAAAR,EAAAzf,EAAAyf,EAAAxY,QAAAD,EAAAyY,EAAA1f,GACAmgB,EAAAF,EAEAG,EAAA,EAAAL,CAIAL,GAAAL,cAAA,IACAe,GAAA,EAAAnZ,EAAA,EAKA,QAFAoZ,GAAA,EAEAlhB,EAAA,EAAA+c,EAAAgB,EAAA7d,OAA6C6c,EAAA/c,IAAQA,EAAA,CACrD,GAAA8I,GAAAiV,EAAA/d,EAaA,IAXA,IAAA6gB,IACAG,GAAAC,EACAJ,EAAAF,EACAK,GAAAD,IACAE,EAAA,EAAAL,EAAA,EAAA9Y,GAAAoZ,EAAA,GAEAF,EAAAF,GAAAH,EAAAC,IAAAM,GAAA,GACAA,IAAA,IAIApY,IAAA4X,EACAM,GAAA,MACO,CACP,GAAAG,GAAAvS,EAAAkR,EAAA,EAAAhX,GACAsY,EAAAxS,EAAAkR,EAAA,EAAAhX,EAAA,GACArF,EAAAmL,EAAAkR,EAAA,EAAAhX,EAAA,EACAvG,GAAAye,KAAAG,EACA5e,EAAAye,KAAAI,EACA7e,EAAAye,KAAAvd,EACAlB,EAAAye,KAAA,MAEAH,IAKA,QAAAJ,GAAAY,EAAA1hB,EAAA4Z,EAAA+H,GAyBA,IAxBA,GAAA9D,GAAA6D,EAAA1hB,KAEA4e,EAAA,GAAAf,EACAiB,EAAAF,EAAA,EACAG,EAAAD,EAAA,EAEAH,EAAAd,EAAA,EAGAgB,GAAA,GAAAF,GAAA,EACAJ,EAAA,EACAC,EAAA,EAEA6C,EAAA,EAEAO,EAAAF,EAAA1hB,KAKAif,EAAA,GAAA4C,YAAA,MAEAC,EAAA,OAEA,CAEA,QAAAvD,GACA,IAAAqD,GAEApD,GAAAkD,EAAA1hB,MAAAue,EACAA,GAAA,EAEA,IAAAqD,EACAA,EAAAF,EAAA1hB,OAEA4hB,CAMA,IAAAjD,EAAAJ,EACA,KAEA,IAAA3Z,GAAA4Z,EAAAK,CAOA,IANAL,IAAAG,EACAJ,GAAAI,EAKA/Z,IAAAga,EAAA,CAYK,GAAAha,IAAAka,EACL,KA2BA,KALA,GAAAiD,GAAAhD,EAAAna,IAAAkd,EAGAE,EAAA,EACAC,EAAAF,EACAE,EAAArD,GACAqD,EAAAhD,EAAAgD,IAAA,IACAD,CAGA,IAAA9C,GAAA+C,EAEAC,EAAAb,EAAAW,GAAAD,IAAAnd,EAAA,IACA,IAAAsd,EAAAP,EAEA,WADA/M,SAAAC,IAAA,4CAKA+E,GAAAyH,KAAAnC,EAEAmC,GAAAW,CACA,IAAAle,GAAAud,CAMA,KAJAU,IAAAnd,IACAgV,EAAAyH,KAAAnC,GAEA+C,EAAAF,EACAC,KACAC,EAAAhD,EAAAgD,GACArI,IAAA9V,GAAA,IAAAme,EACAA,IAAA,CAGA,QAAAH,GAAA,KAAA/C,IACAE,EAAAF,KAAA+C,GAAA,EAAA5C,EAMAH,GAAAF,EAAA,MAAAF,MACAA,EACAE,KAAA,MAIAiD,EAAAld,MA7EAma,GAAAD,EAAA,EACAH,EAAAd,EAAA,EACAgB,GAAA,GAAAF,GAAA,EAGAmD,EAAA,KA+EA,MAJAT,KAAAM,GACA/M,QAAAC,IAAA,8CAGA+E,EAGA,IAAKna,EAAAgd,YAA+Bhd,EAAAoJ,YAAgC,MAAAoE,MhBkvF9D,SAASvN,EAAQD,EAASH,GiB//GhC,YAEA,IAAAkD,GAAAlD,EAAA,GACA6iB,EAAA7iB,EAAA,GAEAI,GAAAD,QAAA,SAAAS,EAAAmE,GAEA,IADA,GAAAvB,MAAA/C,EAAAG,EAAAsG,EAAA,EACAzG,YAAAI,QACA2C,EAAAwC,KAAAvF,EAAAQ,QACAiG,GAAAzG,EAAAQ,OACAR,IAAA,EAEA,YAAA+C,EAAAvC,OACAiC,KAEA6B,IACAA,EAAA7B,EAAA,GAAAkE,cAAAF,GAAA1D,IAEAqf,EAAA9d,EAAAnE,GACAmE,KjBugHM,SAAS3E,EAAQD,EAASH,GkB1hHhCI,EAAAD,QAAAH,EAAA,KAA0C4F,MAAA,0BAAAkd,KAAyCC,KAAA,KAAUnd,QAAAod,YAAAC,cAAyCF,MAASA,KAAA,+PAAoQnd,OAAWqH,KAAA,kBAAAiW,QAAA,EAAAC,QAAA,EAAArf,MAAA,IAAkEmJ,KAAA,kBAAAiW,QAAA,EAAAC,QAAA,EAAArf,MAAA,IAAkEmJ,KAAA,kBAAAiW,QAAA,EAAAC,QAAA,EAAArf,MAAA,IAAgEkf,YAAAC,WAAA,8BAA0DG,MAASL,KAAA,KAAUnd,QAAAod,YAAAC,cAAyCI,SAAA,UAAAC,UAAA,MlBiiHltB,SAASljB,EAAQD,EAASH,GmBjiHhC,YAIA,SAAAujB,KACA5e,KAAA6e,YACA7e,KAAA8e,YACA9e,KAAA+e,aACA/e,KAAAgf,cACAhf,KAAAif,cACAjf,KAAAkf,kBACAlf,KAAAmf,aACAnf,KAAAof,aACApf,KAAA0e,SAAA,GACA1e,KAAAme,IAAA,KACAne,KAAAoe,KAAA,KACApe,KAAAye,KAAA,KACAze,KAAAqf,OAAA,EAGA,QAAAC,GAAAC,GAEA,GAAAC,GAAA,GAAAZ,EAGAY,GAAArB,IAAAoB,EAAApB,IACAqB,EAAApB,KAAAmB,EAAAnB,KACAoB,EAAAf,KAAAc,EAAAd,IAGA,IAAAgB,GAAAF,EAAAte,KAAAgM,MAAA,EACAuS,GAAAX,SAAAY,EAAAxS,MAAA,EACA,QAAA7Q,GAAA,EAAcA,EAAAqjB,EAAAnjB,SAAoBF,EAAA,CAClC,GAAAsjB,GAAAD,EAAArjB,EACA,cAAAsjB,EAAA,CAGA,GAFAF,EAAAT,UAAA1d,KAAAjF,GACAojB,EAAAV,SAAAzd,KAAA,QAAAjF,GACAA,EAAAojB,EAAArB,IAAAld,KAAA3E,QAAAkjB,EAAArB,IAAAld,KAAA7E,GAAA+C,MAAA,EACA,SAAA8G,OAAA,kDAEA,IAAA7J,EAAAojB,EAAAf,KAAAxd,KAAA3E,QAAAkjB,EAAAf,KAAAxd,KAAA7E,GAAA+C,MAAA,EACA,SAAA8G,OAAA,wDAEK,eAAAyZ,EACLF,EAAAR,WAAA3d,KAAAjF,GACAojB,EAAAV,SAAAzd,KAAA,SAAAjF,OACK,cAAAsjB,EAAA,CAEL,GADAF,EAAAL,UAAA9d,KAAAjF,GACAA,EAAAojB,EAAArB,IAAAld,KAAA3E,QAAAkjB,EAAArB,IAAAld,KAAA7E,GAAA+C,MAAA,EACA,SAAA8G,OAAA,mDAEA,IAAA7J,EAAAojB,EAAApB,KAAAnd,KAAA3E,QAAAkjB,EAAApB,KAAAnd,KAAA7E,GAAAmiB,OACA,SAAAtY,OAAA,mDAEA,IAAA7J,EAAAojB,EAAAf,KAAAxd,KAAA3E,QAAAkjB,EAAAf,KAAAxd,KAAA7E,GAAA+C,MAAA,EACA,SAAA8G,OAAA,yDAEK,cAAAyZ,EAAA,CAEL,GADAF,EAAAJ,UAAA/d,KAAAjF,GACAA,EAAAojB,EAAArB,IAAAld,KAAA3E,QAAAkjB,EAAArB,IAAAld,KAAA7E,GAAAmiB,OACA,SAAAtY,OAAA,kDAEA,IAAA7J,EAAAojB,EAAApB,KAAAnd,KAAA3E,QAAAkjB,EAAApB,KAAAnd,KAAA7E,GAAAmiB,OACA,SAAAtY,OAAA,mDAEA,IAAA7J,EAAAojB,EAAAf,KAAAxd,KAAA3E,QAAAkjB,EAAAf,KAAAxd,KAAA7E,GAAAmiB,OACA,SAAAtY,OAAA,wDAEK,oBAAAyZ,OAAAxd,OAKL,SAAA+D,OAAA,gCAAAwZ,EAAArjB,GAJAojB,GAAAX,SAAAziB,GAAA,SACAojB,EAAAP,WAAA5d,MAA4BgB,MAAAqd,EAAArd,MAAAH,OAAAwd,EAAAxd,SAC5Bsd,EAAAN,eAAA7d,KAAAjF,IAOA,GAAAojB,EAAAT,UAAAziB,QAAA,EACA,SAAA2J,OAAA,sCAIA,IAAAuZ,EAAArB,IAAAld,KAAA3E,OAAAmjB,EAAAnjB,OACA,SAAA2J,OAAA,2CAEA,IAAAuZ,EAAApB,KAAAnd,KAAA3E,OAAAmjB,EAAAnjB,OACA,SAAA2J,OAAA,4CAEA,IAAAuZ,EAAAf,KAAAxd,KAAA3E,OAAAmjB,EAAAnjB,OACA,SAAA2J,OAAA,4CAYA,OARAuZ,GAAAH,QAAAE,EAAAI,aAAAJ,EAAAF,MAGAG,EAAAd,SAAAa,EAAAb,UAAA,QAGAc,EAAAb,UAAAY,EAAAZ,WAAA,GAEAiB,EAAAJ,GApGA,GAAAI,GAAAvkB,EAAA,GAuGAI,GAAAD,QAAA8jB,GnBwiHM,SAAS7jB,EAAQD,EAASH,GoBjpHhC,YAIA,SAAAukB,GAAAJ,GACA,GAAA7e,IAAA,gCACAkf,KACAC,EAAAN,EAAAd,SAAA,cAGA/d,GAAAU,MAAA,mBAAAye,EAAA,IAAAN,EAAAV,SAAAre,KAAA,WAA6EA,KAAA,IAI7E,QAHAsf,MACAC,KACAP,IAAA,QAAAD,EAAAT,UAAA,aAAAte,KAAA,KACArE,EAAA,EAAcA,EAAAojB,EAAAT,UAAAziB,SAAyBF,EAAA,CACvC,GAAAsS,GAAA8Q,EAAAT,UAAA3iB,EACAyjB,GAAAxe,MAAA,IAAAqN,EAAA,SAAAA,EAAA,UACA,IAAAA,EAAA,SAAAA,EAAA,UAAAjO,KAAA,KACAsf,EAAA1e,KAAA,IAAAqN,GACAqR,EAAA1e,KAAA,IAAAqN,GACAsR,EAAA3e,KAAA,IAAAqN,GACAsR,EAAA3e,KAAA,IAAAqN,EAAA,WACA+Q,EAAApe,KAAA,QAAAqN,EAAA,SACA+Q,EAAApe,KAAA,QAAAqN,EAAA,WACA+Q,EAAApe,KAAA,QAAAqN,EAAA,aAEA,OAAAtS,GAAA,EAAcA,EAAAojB,EAAAR,WAAA1iB,SAA0BF,EACxCqjB,EAAApe,KAAA,SAAAme,EAAAR,WAAA5iB,GAEAyjB,GAAAxe,MAAA,SAAA2e,EAAAvf,KAAA,iBAAAA,KAAA,KACAof,EAAAxe,KAAA,qBACAV,EAAAU,KAAA,OAAAwe,EAAApf,KAAA,MAEAE,EAAAU,MAAA,aACA,8BAAA0e,EAAAtf,KAAA,WACA,eAAAgf,EAAAhf,KAAA,WAAqDA,KAAA,KAErD+e,EAAAH,OACA1O,QAAAC,IAAA,mBAAAjQ,EAAAF,KAAA,MAIA,IAAAwf,GAAA,GAAApf,UAAA,UAAAF,EAAAF,KAAA,MACA,OAAAwf,GAAAC,EAAAC,KAAAhe,OAAAqd,IAzCA,GAAAU,GAAA7kB,EAAA,GA4CAI,GAAAD,QAAAokB,GpBwpHM,SAASnkB,EAAQD,EAASH,GqBtsHhC,YAIA,SAAA+kB,GAAAtgB,EAAA0f,EAAApB,GACA,GAKAhiB,GAAAsS,EALAnO,EAAAT,EAAAxD,OACA+jB,EAAAb,EAAAT,UAAAziB,OACAgkB,EAAAd,EAAAL,UAAA7iB,OAAA,EACAqE,KACAkf,KACAne,EAAA,EAAA6e,EAAA,CACA,KAAAnkB,EAAA,EAAUmE,EAAAnE,IAAaA,EACvByjB,EAAAxe,MAAA,IAAAjF,EAAA,MAAAqE,KAAA,IAGA,KAAAiO,EAAA,EAAU2R,EAAA3R,IAASA,EACnB,IAAAtS,EAAA,EAAYmE,EAAAnE,IAAaA,EACzBmkB,EAAA7e,EACAA,EAAA5B,EAAA1D,GACA,IAAAA,EACAyjB,EAAAxe,MAAA,IAAAqN,EAAA,IAAAtS,EAAA,KAAAsS,EAAA,IAAAhN,EAAA,KAAAjB,KAAA,KAEAof,EAAAxe,MAAA,IAAAqN,EAAA,IAAAtS,EAAA,MAAAsS,EAAA,IAAAhN,EAAA,MAAA6e,EAAA,KAAA7R,EAAA,IAAA6R,EAAA,MAAA9f,KAAA,IAMA,KAFAE,EAAAU,KAAA,OAAAwe,EAAApf,KAAA,MAEArE,EAAAmE,EAAA,EAAoBnE,GAAA,IAAMA,EAC1BsF,EAAA5B,EAAA1D,GACAuE,EAAAU,MAAA,QAAAjF,EAAA,OAA6BA,EAAA,KAAAsF,EAAA,OAAgBtF,EAAA,MAAUqE,KAAA,IAKvD,KAFAE,EAAAU,KAAA+c,GAEAhiB,EAAA,EAAUmE,EAAAnE,IAAaA,EAAA,CAGvB,IAFAmkB,EAAA7e,EACAA,EAAA5B,EAAA1D,GACAsS,EAAA,EAAY2R,EAAA3R,IAASA,EACrB/N,EAAAU,MAAA,IAAAqN,EAAA,MAAAA,EAAA,IAAAtS,GAAAqE,KAAA,IAEA6f,KACAlkB,EAAA,GACAuE,EAAAU,MAAA,SAAAkf,EAAA,OAAAA,GAAA9f,KAAA,KAEAE,EAAAU,MAAA,WAAAK,EAAA,KAAAjB,KAAA,MAEAE,EAAAU,KAAA,KAEA,MAAAV,GAAAF,KAAA,MAGA,QAAA+f,GAAAC,EAAA3gB,EAAA0f,EAAApB,GAMA,OALA7d,GAAAT,EAAAxD,OACA+jB,EAAAb,EAAAT,UAAAziB,OACAqiB,EAAAa,EAAAb,UACA2B,EAAAd,EAAAL,UAAA7iB,OAAA,EACAqE,KACAvE,EAAA,EAAcikB,EAAAjkB,IAASA,EACvBuE,EAAAU,MAAA,aAAAjF,EAAA,KAAAA,GAAAqE,KAAA,IAGA,QAAArE,GAAAqkB,EAAoBlgB,EAAAnE,IAAaA,EACjCuE,EAAAU,MAAA,YAAAjF,EAAA,OAAA0D,EAAA1D,GAAA,QAAoDA,EAAA,SAAaqE,KAAA,KACjEE,EAAAU,MAAA,OAAAjF,EAAA,IAAAuiB,EAAA,MAAyCle,KAAA,KACzCE,EAAAU,MAAA,IAAAvB,EAAA1D,GAAA,KAAAA,GAAAqE,KAAA,KACAE,EAAAU,MAAA,IAAAjF,EAAA,MAAAqE,KAAA,KACAE,EAAAU,MAAA,UAAsBvB,EAAA1D,GAAA,IAAAuiB,GAAAle,KAAA,KACtBE,EAAAU,MAAA,IAAAjF,EAAA,KAAAuiB,EAAA,KAAsCle,KAAA,KACtC6f,GACA3f,EAAAU,MAAA,SAAAvB,EAAA1D,GAAA,MAAAA,GAAAqE,KAAA,IAGA,QAAArE,GAAA,EAAcikB,EAAAjkB,IAASA,EAAA,CAEvB,OADAskB,IAAA,SAAAtkB,GACAsS,EAAA+R,EAAsBlgB,EAAAmO,IAAaA,EACnCgS,EAAArf,MAAA,IAAAqN,EAAA,KAAAtS,EAAA,IAAA0D,EAAA4O,GAAA,KAAAjO,KAAA,IAEAE,GAAAU,MAAA,IAAAjF,EAAA,KAAAskB,EAAAjgB,KAAA,UAAAA,KAAA,KAEAE,EAAAU,KAAA+e,EAAAtgB,EAAA0f,EAAApB,GACA,QAAAhiB,GAAAqkB,EAAoBlgB,EAAAnE,IAAaA,EACjCuE,EAAAU,KAAA,IAEA,OAAAV,GAAAF,KAAA,MAIA,QAAAkgB,GAAAC,GAEA,IADA,GAAAH,GAAA,EAAAlgB,EAAAqgB,EAAA,GAAAtkB,OACAiE,EAAAkgB,GAAA,CACA,OAAA/R,GAAA,EAAgBA,EAAAkS,EAAAtkB,SAAiBoS,EACjC,GAAAkS,EAAAlS,GAAA+R,KAAAG,EAAA,GAAAH,GACA,MAAAA,KAGAA,EAEA,MAAAA,GAIA,QAAAI,GAAAC,EAAAtB,EAAAuB,GAIA,OAHApgB,GAAAmgB,EAAA1C,KACAD,KACAM,KACAriB,EAAA,EAAcA,EAAA0kB,EAAA7f,KAAA3E,SAAqBF,EAAA,CACnC,GAAA4kB,GAAAF,EAAA7f,KAAA7E,EACA,MAAA4kB,EAAA7hB,OAAA,IAGA,GAAA8hB,GAAA,GAAAC,QAAAF,EAAA1Y,KAAA,KACA6Y,EAAA,GACAC,EAAA5B,EAAAT,UAAAxY,QAAAnK,EACA,QAAAojB,EAAAX,SAAAziB,IACA,aACA,GAAAilB,GAAA7B,EAAAN,eAAA3Y,QAAAnK,GACAklB,EAAA9B,EAAAP,WAAAoC,EACAD,GAAAE,EAAAjf,MACA8e,EAAA,KAAAE,CACA,aACAF,EAAA,IAAAC,EAAAD,CACA,IAAAI,GAAA,IAAAnlB,EACAolB,EAAA,IAAAJ,CACA,KAAAJ,EAAA7hB,MACA,YAAA4hB,EAAAK,GACAJ,EAAAzC,QACAJ,EAAA9c,MAAA,OAAAkgB,EAAA,IAAAC,EAAA,QAAAL,EAAA,KAAA1gB,KAAA,KACAE,IAAAyO,QAAA6R,EAAAM,GACA9C,EAAApd,MAAAmgB,EAAA,QAAAL,EAAA,IAAAI,EAAA,KAAA9gB,KAAA,MAEAE,IAAAyO,QAAA6R,GAAAO,EAAA,QAAAL,EAAA,KAAA1gB,KAAA,KAGAE,IAAAyO,QAAA6R,GAAAO,EAAA,IAAAL,EAAA,KAAA1gB,KAAA,KAES,YAAAsgB,EAAAK,IACTjD,EAAA9c,MAAA,OAAAkgB,EAAA,IAAAC,EAAA,QAAAL,EAAA,KAAA1gB,KAAA,KACAE,IAAAyO,QAAA6R,EAAAM,GACAP,EAAAzC,QACAE,EAAApd,MAAAmgB,EAAA,QAAAL,EAAA,IAAAI,EAAA,KAAA9gB,KAAA,OAGA0d,EAAA9c,MAAA,OAAAkgB,EAAA,IAAAC,EAAA,IAAAL,EAAA,KAAA1gB,KAAA,KACAE,IAAAyO,QAAA6R,EAAAM,GACAP,EAAAzC,QACAE,EAAApd,MAAAmgB,EAAA,IAAAL,EAAA,KAAAI,GAAA9gB,KAAA,KAGA,MACA,cACAE,IAAAyO,QAAA6R,EAAA,IAAAzB,EAAAR,WAAAzY,QAAAnK,GACA,MACA,aACAuE,IAAAyO,QAAA6R,EAAA,QACA,MACA,aACAtgB,IAAAyO,QAAA6R,EAAA,WAIA,OAAA9C,EAAA1d,KAAA,MAAAE,EAAA8d,EAAAhe,KAAA,OAAAA,KAAA,MAAA6O,OAGA,QAAAmS,GAAAV,GAGA,OAFAW,GAAA,GAAAxlB,OAAA6kB,EAAAzkB,QACAqlB,GAAA,EACAvlB,EAAA,EAAcA,EAAA2kB,EAAAzkB,SAAiBF,EAAA,CAC/B,GAAAwlB,GAAAb,EAAA3kB,GACAylB,EAAAD,EAAArR,MAAA,MAIAsR,GAHAA,EAGAA,EAAA,GAFA,GAIA,IAAAD,EAAAtjB,OAAA,GACAojB,EAAAtlB,GAAA,IAAAwlB,EAAAtjB,OAAA,GAAAujB,EAEAH,EAAAtlB,GAAAwlB,EAAAtjB,OAAA,GAAAujB,EAEAzlB,EAAA,IACAulB,KAAAD,EAAAtlB,KAAAslB,EAAAtlB,EAAA,IAGA,MAAAulB,GACAD,EAAA,GAEAA,EAAAjhB,KAAA,IAIA,QAAAqhB,GAAAtC,EAAAO,GAYA,OATAxf,GAAA,EAAAwf,EAAA,GAAAzjB,OACAskB,EAAA,GAAA1kB,OAAAsjB,EAAAT,UAAAziB,QACAykB,EAAA,GAAA7kB,OAAAsjB,EAAAT,UAAAziB,QAGAylB,GAAA,MACAphB,GAAA,gBACAkf,KAEAnR,EAAA,EAAcnO,EAAAmO,IAAaA,EAC3BmR,EAAAxe,MAAA,IAAAqN,EAAA,OAAAA,EAAA,KAAAjO,KAAA,IAEA,QAAArE,GAAA,EAAcA,EAAAojB,EAAAT,UAAAziB,SAAyBF,EACvC2lB,EAAA1gB,KAAA,IAAAjF,GACA2lB,EAAA1gB,KAAA,IAAAjF,GACA2lB,EAAA1gB,KAAA,IAAAjF,GACA2kB,EAAA3kB,GAAA2jB,EAAA,EAAA3jB,GACAwkB,EAAAxkB,GAAA2jB,EAAA,EAAA3jB,EAAA,EAEA,QAAAA,GAAA,EAAcA,EAAAojB,EAAAR,WAAA1iB,SAA0BF,EACxC2lB,EAAA1gB,KAAA,IAAAjF,EAKA,IAHAojB,EAAAJ,UAAA9iB,OAAA,GACAujB,EAAAxe,KAAA,qBAEAme,EAAAL,UAAA7iB,OAAA,GAEA,OADA0lB,GAAA,GAAA9lB,OAAAqE,GACAnE,EAAA,EAAgBmE,EAAAnE,IAAaA,EAC7B4lB,EAAA5lB,GAAA,GAEAyjB,GAAAxe,MAAA,UAAA2gB,EAAAvhB,KAAA,UAAAA,KAAA,KAEA,OAAArE,GAAA,EAAcA,EAAAojB,EAAAP,WAAA3iB,SAA0BF,EAAA,CAGxC,OAFA6lB,GAAAzC,EAAAP,WAAA7iB,GACA8lB,KACAxT,EAAA,EAAgBA,EAAAuT,EAAA/f,OAAA5F,SAAyBoS,EACzC,IAAAuT,EAAA/f,OAAAwM,KAEO,IAAAuT,EAAA/f,OAAAwM,GACPwT,EAAA7gB,MAAA,IAAA4gB,EAAA5f,MAAA,IAAAqM,EAAA,KAAAjO,KAAA,KAEAyhB,EAAA7gB,MAAA4gB,EAAA/f,OAAAwM,GAAA,KAAAuT,EAAA5f,MAAA,IAAAqM,EAAA,KAAAjO,KAAA,KAGA,KAAAyhB,EAAA5lB,OACAujB,EAAAxe,KAAA,IAAAjF,EAAA,MAEAyjB,EAAAxe,MAAA,IAAAjF,EAAA,KAAA8lB,EAAAzhB,KAAA,YAAAA,KAAA,KAKA,GAAA4d,GAAA8D,KAAA7kB,OAAAkiB,EAAArB,IAAAE,UACA/gB,OAAAkiB,EAAApB,KAAAC,UACA/gB,OAAAkiB,EAAAf,KAAAJ,UACAwB,KAAAviB,OAAA+gB,GACA1d,EAAAU,KAAA,OAAAwe,EAAApf,KAAA,KACA,QAAArE,GAAA,EAAcA,EAAAojB,EAAAT,UAAAziB,SAAyBF,EACvCuE,EAAAU,KAAA,IAAAjF,EAAA,MAIAojB,GAAArB,IAAAC,KAAA9hB,OAAA,GACAqE,EAAAU,KAAAwf,EAAArB,EAAArB,IAAAqB,EAAAuB,GAIA,IAAA3C,GAAAyC,EAAArB,EAAApB,KAAAoB,EAAAuB,GACAN,EAAAE,EAAAC,EACArgB,GAAAkgB,EACA9f,EAAAU,KAAAmf,EAAAC,EAAAG,EAAA,GAAApB,EAAApB,IAEAzd,EAAAU,KAAA+e,EAAAQ,EAAA,GAAApB,EAAApB,IAIAoB,EAAAf,KAAAL,KAAA9hB,OAAA,GACAqE,EAAAU,KAAAwf,EAAArB,EAAAf,KAAAe,EAAAuB,IAGAvB,EAAAH,OACA1O,QAAAC,IAAA,+BAAAmP,EAAA,QAAApf,EAAAF,KAAA,MAGA,IAAA2hB,IAAA5C,EAAAd,UAAA,yBAAAkC,EAAA,GAAAngB,KAAA,SAAAggB,EAAAgB,EAAAV,IAAAtgB,KAAA,IACAuW,EAAA,GAAAnW,WAAA,YAAAuhB,EAAA,IAAAL,EAAAthB,KAAA,UAAuEE,EAAAF,KAAA,kBAAqB2hB,GAAA3hB,KAAA,IAC5F,OAAAuW,KAtRA,GAAAmL,GAAA9mB,EAAA,GAwRAI,GAAAD,QAAAsmB,GrB4sHM,SAASrmB,EAAQD,GsBt+HvB,YAEA,SAAA6mB,GAAAnS,EAAAF,GAIA,OAHAsS,GAAA,EACAtb,EAAAkJ,EAAA5T,OACAsD,EAAAsQ,EAAA,GAAArQ,EAAAqQ,EAAA,GACA9T,EAAA,EAAc4K,EAAA5K,IAAOA,EAGrB,GAFAyD,EAAAD,EACAA,EAAAsQ,EAAA9T,GACA4T,EAAApQ,EAAAC,GAAA,CACA,GAAAzD,IAAAkmB,EAAA,CACAA,GACA,UAEApS,EAAAoS,KAAA1iB,EAIA,MADAsQ,GAAA5T,OAAAgmB,EACApS,EAGA,QAAAqS,GAAArS,GAIA,OAHAoS,GAAA,EACAtb,EAAAkJ,EAAA5T,OACAsD,EAAAsQ,EAAA,GAAArQ,EAAAqQ,EAAA,GACA9T,EAAA,EAAc4K,EAAA5K,IAAOA,EAAAyD,EAAAD,EAGrB,GAFAC,EAAAD,EACAA,EAAAsQ,EAAA9T,GACAwD,IAAAC,EAAA,CACA,GAAAzD,IAAAkmB,EAAA,CACAA,GACA,UAEApS,EAAAoS,KAAA1iB,EAIA,MADAsQ,GAAA5T,OAAAgmB,EACApS,EAGA,QAAAsS,GAAAtS,EAAAF,EAAAyS,GACA,WAAAvS,EAAA5T,UAGA0T,GACAyS,GACAvS,EAAA/P,KAAA6P,GAEAqS,EAAAnS,EAAAF,KAEAyS,GACAvS,EAAA/P,OAEAoiB,EAAArS,IAGAzU,EAAAD,QAAAgnB,GtB4+HM,SAAS/mB,EAAQD,EAASH,IuBpiIhC,SAAAmI,GAYA,QAAAkf,GAAA7Y,EAAA0B,EAAAmO,GAiBA,QAAAiJ,KACA,KAAAxf,EAAA7G,SAAAsmB,EAAAC,QAAA,CACA,GAAAtlB,GAAA4F,EAAA2f,OACA,WAAAvlB,EACA,MAAAqlB,GAAAxa,KAAA,MAEAwa,GAAAxa,KAAA,OAAA7K,IA2BA,QAAAwlB,KACAH,EAAAI,UAAA,EACAzX,EAAA3P,KAAAgnB,IACAA,EAAAK,UAAAL,EAAAM,aACAN,EAAAO,UArDAtZ,KAAA,SAAAtM,GAAoCyC,KAAA2G,MAAApJ,IACpCgO,KAAA,WAA4BvL,KAAA2G,MAAA,MAE5B,IAAA0S,IAAA,EAAA+J,GAAA,EAAAjgB,KAAAkgB,GAAA,EACAT,EAAA,GAAAU,EAwFA,OAvFAV,GAAAK,SAAAL,EAAAI,UAAA,EACAJ,EAAAC,QAAA,EAGAD,EAAAM,cAAAxJ,KAAAwJ,eAAA,GAEAN,EAAA/Y,MAAA,SAAAtM,GAEA,MADAsM,GAAAjO,KAAAoE,KAAAzC,IACAqlB,EAAAC,QAaAD,EAAAjc,MAAAic,EAAAvhB,KAAA,SAAA9D,GAEA,MAAA8lB,GAAAT,GACA,OAAArlB,IAAA8lB,GAAA,GACAlgB,EAAA9B,KAAA9D,GACAolB,IACAC,IASAA,EAAA9a,GAAA,iBACA8a,EAAAK,UAAA,GACAL,EAAAI,UAAAJ,EAAAM,aACA1f,EAAAuC,SAAA,WACA6c,EAAAO,cAWAP,EAAArX,IAAA,SAAAhO,GACA,MAAA8b,GAAA,QACAA,GAAA,EACA/R,UAAAhL,QAAAsmB,EAAA/Y,MAAAtM,GACAwlB,IACAH,IAGAA,EAAAO,QAAA,WACA,MAAAC,GAAA,QACAA,GAAA,EACA/J,GAAA,EACAlW,EAAA7G,OAAA,EACAsmB,EAAAI,SAAAJ,EAAAK,UAAA,EACAL,EAAAxa,KAAA,SACAwa,IAGAA,EAAAW,MAAA,WACA,MAAAX,GAAAC,OAAA,QACAD,EAAAC,QAAA,EACAD,IAGAA,EAAAY,OAAA,WAUA,MATAZ,GAAAC,SACAD,EAAAC,QAAA,EACAD,EAAAxa,KAAA,WAEAua,IAGAC,EAAAC,QACAD,EAAAxa,KAAA,SACAwa,GAEAA,EAzGA,GAAAU,GAAAjoB,EAAA,GAOAG,GAAAC,EAAAD,QAAAknB,EACAA,cvB2oI8B9mB,KAAKJ,EAASH,EAAoB,KAI1D,SAASI,EAAQD,EAASH,GwB9mIhC,QAAAioB,KACAG,EAAA7nB,KAAAoE,MArBAvE,EAAAD,QAAA8nB,CAEA,IAAAG,GAAApoB,EAAA,IAAAqoB,aACAC,EAAAtoB,EAAA,GAEAsoB,GAAAL,EAAAG,GACAH,EAAAM,SAAAvoB,EAAA,IACAioB,EAAAO,SAAAxoB,EAAA,IACAioB,EAAAQ,OAAAzoB,EAAA,IACAioB,EAAAS,UAAA1oB,EAAA,IACAioB,EAAAU,YAAA3oB,EAAA,IAGAioB,WAWAA,EAAAvhB,UAAAkiB,KAAA,SAAAC,EAAArnB,GAGA,QAAAsnB,GAAAC,GACAF,EAAAlB,WACA,IAAAkB,EAAAra,MAAAua,IAAAC,EAAAd,OACAc,EAAAd,QAOA,QAAAe,KACAD,EAAApB,UAAAoB,EAAAb,QACAa,EAAAb,SAcA,QAAAe,KACAC,IACAA,GAAA,EAEAN,EAAA3Y,OAIA,QAAAkZ,KACAD,IACAA,GAAA,EAEA,kBAAAN,GAAAf,SAAAe,EAAAf,WAIA,QAAA1e,GAAAigB,GAEA,GADAC,IACA,IAAAlB,EAAAmB,cAAA5kB,KAAA,SACA,KAAA0kB,GAQA,QAAAC,KACAN,EAAAnc,eAAA,OAAAic,GACAD,EAAAhc,eAAA,QAAAoc;AAEAD,EAAAnc,eAAA,MAAAqc,GACAF,EAAAnc,eAAA,QAAAuc,GAEAJ,EAAAnc,eAAA,QAAAzD,GACAyf,EAAAhc,eAAA,QAAAzD,GAEA4f,EAAAnc,eAAA,MAAAyc,GACAN,EAAAnc,eAAA,QAAAyc,GAEAT,EAAAhc,eAAA,QAAAyc,GApEA,GAAAN,GAAArkB,IAUAqkB,GAAAvc,GAAA,OAAAqc,GAQAD,EAAApc,GAAA,QAAAwc,GAIAJ,EAAAW,UAAAhoB,KAAA0O,OAAA,IACA8Y,EAAAvc,GAAA,MAAAyc,GACAF,EAAAvc,GAAA,QAAA2c,GAGA,IAAAD,IAAA,CAoDA,OA5BAH,GAAAvc,GAAA,QAAArD,GACAyf,EAAApc,GAAA,QAAArD,GAmBA4f,EAAAvc,GAAA,MAAA6c,GACAN,EAAAvc,GAAA,QAAA6c,GAEAT,EAAApc,GAAA,QAAA6c,GAEAT,EAAA9b,KAAA,OAAAic,GAGAH,IxB+pIM,SAASzoB,EAAQD,GyBvwIvB,QAAAkoB,KACA1jB,KAAA8kB,QAAA9kB,KAAA8kB,YACA9kB,KAAA+kB,cAAA/kB,KAAA+kB,eAAA5iB,OAoQA,QAAA6iB,GAAA7b,GACA,wBAAAA,GAGA,QAAA8b,GAAA9b,GACA,sBAAAA,GAGA,QAAA+b,GAAA/b,GACA,sBAAAA,IAAA,OAAAA,EAGA,QAAAgc,GAAAhc,GACA,gBAAAA,EA/QA1N,EAAAD,QAAAkoB,EAGAA,iBAEAA,EAAA3hB,UAAA+iB,QAAA3iB,OACAuhB,EAAA3hB,UAAAgjB,cAAA5iB,OAIAuhB,EAAA0B,oBAAA,GAIA1B,EAAA3hB,UAAAsjB,gBAAA,SAAApnB,GACA,IAAAgnB,EAAAhnB,IAAA,EAAAA,GAAAqO,MAAArO,GACA,KAAAgM,WAAA,8BAEA,OADAjK,MAAA+kB,cAAA9mB,EACA+B,MAGA0jB,EAAA3hB,UAAAqG,KAAA,SAAAjC,GACA,GAAAue,GAAAY,EAAAte,EAAA/F,EAAA7E,EAAAmpB,CAMA,IAJAvlB,KAAA8kB,UACA9kB,KAAA8kB,YAGA,UAAA3e,KACAnG,KAAA8kB,QAAAU,OACAN,EAAAllB,KAAA8kB,QAAAU,SAAAxlB,KAAA8kB,QAAAU,MAAAlpB,QAAA,CAEA,GADAooB,EAAApd,UAAA,GACAod,YAAAze,OACA,KAAAye,EAEA,MAAAza,WAAA,wCAMA,GAFAqb,EAAAtlB,KAAA8kB,QAAA3e,GAEAgf,EAAAG,GACA,QAEA,IAAAN,EAAAM,GACA,OAAAhe,UAAAhL,QAEA,OACAgpB,EAAA1pB,KAAAoE,KACA,MACA,QACAslB,EAAA1pB,KAAAoE,KAAAsH,UAAA,GACA,MACA,QACAge,EAAA1pB,KAAAoE,KAAAsH,UAAA,GAAAA,UAAA,GACA,MAEA,SACArG,EAAA/E,MAAA6F,UAAAkL,MAAArR,KAAA0L,UAAA,GACAge,EAAA/d,MAAAvH,KAAAiB,OAEG,IAAAikB,EAAAI,GAIH,IAHArkB,EAAA/E,MAAA6F,UAAAkL,MAAArR,KAAA0L,UAAA,GACAie,EAAAD,EAAArY,QACAjG,EAAAue,EAAAjpB,OACAF,EAAA,EAAe4K,EAAA5K,EAASA,IACxBmpB,EAAAnpB,GAAAmL,MAAAvH,KAAAiB,EAGA,WAGAyiB,EAAA3hB,UAAAgG,YAAA,SAAA5B,EAAAsf,GACA,GAAA5pB,EAEA,KAAAmpB,EAAAS,GACA,KAAAxb,WAAA,8BA2CA,OAzCAjK,MAAA8kB,UACA9kB,KAAA8kB,YAIA9kB,KAAA8kB,QAAAY,aACA1lB,KAAAoI,KAAA,cAAAjC,EACA6e,EAAAS,YACAA,cAEAzlB,KAAA8kB,QAAA3e,GAGA+e,EAAAllB,KAAA8kB,QAAA3e,IAEAnG,KAAA8kB,QAAA3e,GAAA9E,KAAAokB,GAGAzlB,KAAA8kB,QAAA3e,IAAAnG,KAAA8kB,QAAA3e,GAAAsf,GANAzlB,KAAA8kB,QAAA3e,GAAAsf,EASAP,EAAAllB,KAAA8kB,QAAA3e,MAAAnG,KAAA8kB,QAAA3e,GAAAwf,SAIA9pB,EAHAspB,EAAAnlB,KAAA+kB,eAGArB,EAAA0B,oBAFAplB,KAAA+kB,cAKAlpB,KAAA,GAAAmE,KAAA8kB,QAAA3e,GAAA7J,OAAAT,IACAmE,KAAA8kB,QAAA3e,GAAAwf,QAAA,EACAhV,QAAA6U,MAAA,mIAGAxlB,KAAA8kB,QAAA3e,GAAA7J,QACA,kBAAAqU,SAAAiV,OAEAjV,QAAAiV,UAKA5lB,MAGA0jB,EAAA3hB,UAAA+F,GAAA4b,EAAA3hB,UAAAgG,YAEA2b,EAAA3hB,UAAAiG,KAAA,SAAA7B,EAAAsf,GAMA,QAAAjI,KACAxd,KAAAkI,eAAA/B,EAAAqX,GAEAqI,IACAA,GAAA,EACAJ,EAAAle,MAAAvH,KAAAsH,YAVA,IAAA0d,EAAAS,GACA,KAAAxb,WAAA,8BAEA,IAAA4b,IAAA,CAcA,OAHArI,GAAAiI,WACAzlB,KAAA8H,GAAA3B,EAAAqX,GAEAxd,MAIA0jB,EAAA3hB,UAAAmG,eAAA,SAAA/B,EAAAsf,GACA,GAAAvV,GAAA4V,EAAAxpB,EAAAF,CAEA,KAAA4oB,EAAAS,GACA,KAAAxb,WAAA,8BAEA,KAAAjK,KAAA8kB,UAAA9kB,KAAA8kB,QAAA3e,GACA,MAAAnG,KAMA,IAJAkQ,EAAAlQ,KAAA8kB,QAAA3e,GACA7J,EAAA4T,EAAA5T,OACAwpB,EAAA,GAEA5V,IAAAuV,GACAT,EAAA9U,EAAAuV,WAAAvV,EAAAuV,mBACAzlB,MAAA8kB,QAAA3e,GACAnG,KAAA8kB,QAAA5c,gBACAlI,KAAAoI,KAAA,iBAAAjC,EAAAsf,OAEG,IAAAP,EAAAhV,GAAA,CACH,IAAA9T,EAAAE,EAAoBF,KAAA,GACpB,GAAA8T,EAAA9T,KAAAqpB,GACAvV,EAAA9T,GAAAqpB,UAAAvV,EAAA9T,GAAAqpB,aAAA,CACAK,EAAA1pB,CACA,OAIA,KAAA0pB,EACA,MAAA9lB,KAEA,KAAAkQ,EAAA5T,QACA4T,EAAA5T,OAAA,QACA0D,MAAA8kB,QAAA3e,IAEA+J,EAAA0G,OAAAkP,EAAA,GAGA9lB,KAAA8kB,QAAA5c,gBACAlI,KAAAoI,KAAA,iBAAAjC,EAAAsf,GAGA,MAAAzlB,OAGA0jB,EAAA3hB,UAAAoG,mBAAA,SAAAhC,GACA,GAAA4f,GAAAR,CAEA,KAAAvlB,KAAA8kB,QACA,MAAA9kB,KAGA,KAAAA,KAAA8kB,QAAA5c,eAKA,MAJA,KAAAZ,UAAAhL,OACA0D,KAAA8kB,WACA9kB,KAAA8kB,QAAA3e,UACAnG,MAAA8kB,QAAA3e,GACAnG,IAIA,QAAAsH,UAAAhL,OAAA,CACA,IAAAypB,IAAA/lB,MAAA8kB,QACA,mBAAAiB,GACA/lB,KAAAmI,mBAAA4d,EAIA,OAFA/lB,MAAAmI,mBAAA,kBACAnI,KAAA8kB,WACA9kB,KAKA,GAFAulB,EAAAvlB,KAAA8kB,QAAA3e,GAEA6e,EAAAO,GACAvlB,KAAAkI,eAAA/B,EAAAof,OACG,IAAAA,EAEH,KAAAA,EAAAjpB,QACA0D,KAAAkI,eAAA/B,EAAAof,IAAAjpB,OAAA,GAIA,cAFA0D,MAAA8kB,QAAA3e,GAEAnG,MAGA0jB,EAAA3hB,UAAAwjB,UAAA,SAAApf,GACA,GAAA6H,EAOA,OAHAA,GAHAhO,KAAA8kB,SAAA9kB,KAAA8kB,QAAA3e,GAEA6e,EAAAhlB,KAAA8kB,QAAA3e,KACAnG,KAAA8kB,QAAA3e,IAEAnG,KAAA8kB,QAAA3e,GAAA8G,YAIAyW,EAAA3hB,UAAA6iB,cAAA,SAAAze,GACA,GAAAnG,KAAA8kB,QAAA,CACA,GAAAkB,GAAAhmB,KAAA8kB,QAAA3e,EAEA,IAAA6e,EAAAgB,GACA,QACA,IAAAA,EACA,MAAAA,GAAA1pB,OAEA,UAGAonB,EAAAkB,cAAA,SAAAqB,EAAA9f,GACA,MAAA8f,GAAArB,cAAAze,KzBozIM,SAAS1K,EAAQD,G0B5kJvB,kBAAAsG,QAAAokB,OAEAzqB,EAAAD,QAAA,SAAA4G,EAAA+jB,GACA/jB,EAAAgkB,OAAAD,EACA/jB,EAAAL,UAAAD,OAAAokB,OAAAC,EAAApkB,WACAwB,aACA+K,MAAAlM,EACAikB,YAAA,EACArD,UAAA,EACAsD,cAAA,MAMA7qB,EAAAD,QAAA,SAAA4G,EAAA+jB,GACA/jB,EAAAgkB,OAAAD,CACA,IAAAI,GAAA,YACAA,GAAAxkB,UAAAokB,EAAApkB,UACAK,EAAAL,UAAA,GAAAwkB,GACAnkB,EAAAL,UAAAwB,YAAAnB,I1BqlJM,SAAS3G,EAAQD,EAASH,G2BzmJhCG,EAAAC,EAAAD,QAAAH,EAAA,IACAG,EAAA8nB,OAAAjoB,EAAA,IACAG,EAAAooB,SAAApoB,EACAA,EAAAqoB,SAAAxoB,EAAA,IACAG,EAAAsoB,OAAAzoB,EAAA,IACAG,EAAAuoB,UAAA1oB,EAAA,IACAG,EAAAwoB,YAAA3oB,EAAA,K3BgnJM,SAASI,EAAQD,EAASH,I4BtnJhC,SAAAmI,GAgEA,QAAAgjB,GAAA3pB,EAAA+lB,GACA,GAAAkB,GAAAzoB,EAAA,GAEAwB,QAIA,IAAA4pB,GAAA5pB,EAAA6pB,cACAC,EAAA9pB,EAAA+pB,WAAA,QACA5mB,MAAA0mB,cAAAD,GAAA,IAAAA,IAAAE,EAGA3mB,KAAA0mB,gBAAA1mB,KAAA0mB,cAEA1mB,KAAAmD,UACAnD,KAAA1D,OAAA,EACA0D,KAAA6mB,MAAA,KACA7mB,KAAA8mB,WAAA,EACA9mB,KAAA+mB,QAAA,KACA/mB,KAAAqZ,OAAA,EACArZ,KAAAgnB,YAAA,EACAhnB,KAAAinB,SAAA,EAMAjnB,KAAAknB,MAAA,EAIAlnB,KAAAmnB,cAAA,EACAnnB,KAAAonB,iBAAA,EACApnB,KAAAqnB,mBAAA,EAKArnB,KAAA4mB,aAAA/pB,EAAA+pB,WAEAhE,YAAAkB,KACA9jB,KAAA4mB,WAAA5mB,KAAA4mB,cAAA/pB,EAAAyqB,oBAKAtnB,KAAAunB,gBAAA1qB,EAAA0qB,iBAAA,OAIAvnB,KAAAwnB,QAAA,EAGAxnB,KAAAynB,WAAA,EAGAznB,KAAA0nB,aAAA,EAEA1nB,KAAA2nB,QAAA,KACA3nB,KAAA4J,SAAA,KACA/M,EAAA+M,WACAge,IACAA,EAAAvsB,EAAA,IAAAusB,eACA5nB,KAAA2nB,QAAA,GAAAC,GAAA/qB,EAAA+M,UACA5J,KAAA4J,SAAA/M,EAAA+M,UAIA,QAAAga,GAAA/mB,GACAxB,EAAA,GAEA,OAAA2E,gBAAA4jB,IAGA5jB,KAAA6nB,eAAA,GAAArB,GAAA3pB,EAAAmD,MAGAA,KAAAijB,UAAA,MAEAK,GAAA1nB,KAAAoE,OAPA,GAAA4jB,GAAA/mB,GAkCA,QAAAirB,GAAAlF,EAAAmF,EAAA3D,EAAAxa,EAAAoe,GACA,GAAAtD,GAAAuD,EAAAF,EAAA3D,EACA,IAAAM,EACA9B,EAAAxa,KAAA,QAAAsc,OACG,IAAAwD,EAAAC,kBAAA/D,GACH2D,EAAAd,SAAA,EACAc,EAAA1O,OACA+O,EAAAxF,EAAAmF,OACG,IAAAA,EAAAnB,YAAAxC,KAAA9nB,OAAA,EACH,GAAAyrB,EAAA1O,QAAA2O,EAAA,CACA,GAAAhf,GAAA,GAAA/C,OAAA,0BACA2c,GAAAxa,KAAA,QAAAY,OACK,IAAA+e,EAAAf,YAAAgB,EAAA,CACL,GAAAhf,GAAA,GAAA/C,OAAA,mCACA2c,GAAAxa,KAAA,QAAAY,QAEA+e,EAAAJ,SAAAK,GAAApe,IACAwa,EAAA2D,EAAAJ,QAAA9d,MAAAua,IAEA4D,IACAD,EAAAd,SAAA,GAGAc,EAAAhB,SAAA,IAAAgB,EAAAzrB,SAAAyrB,EAAAb,MACAtE,EAAAxa,KAAA,OAAAgc,GACAxB,EAAAtQ,KAAA,KAGAyV,EAAAzrB,QAAAyrB,EAAAnB,WAAA,EAAAxC,EAAA9nB,OACA0rB,EACAD,EAAA5kB,OAAA0T,QAAAuN,GAEA2D,EAAA5kB,OAAA9B,KAAA+iB,GAEA2D,EAAAZ,cACAkB,EAAAzF,IAGA0F,EAAA1F,EAAAmF,OAEGC,KACHD,EAAAd,SAAA,EAGA,OAAAsB,GAAAR,GAYA,QAAAQ,GAAAR,GACA,OAAAA,EAAA1O,QACA0O,EAAAZ,cACAY,EAAAzrB,OAAAyrB,EAAArB,eACA,IAAAqB,EAAAzrB,QAcA,QAAAksB,GAAAvqB,GACA,GAAAA,GAAAwqB,EACAxqB,EAAAwqB,MACG,CAEHxqB,GACA,QAAAlC,GAAA,EAAmB,GAAAA,EAAQA,IAAA,EAAAkC,MAAAlC,CAC3BkC,KAEA,MAAAA,GAGA,QAAAyqB,GAAAzqB,EAAA8pB,GACA,WAAAA,EAAAzrB,QAAAyrB,EAAA1O,MACA,EAEA0O,EAAAnB,WACA,IAAA3oB,EAAA,IAEAqO,MAAArO,IAAAiqB,EAAAS,OAAA1qB,GAEA8pB,EAAAhB,SAAAgB,EAAA5kB,OAAA7G,OACAyrB,EAAA5kB,OAAA,GAAA7G,OAEAyrB,EAAAzrB,OAGA,GAAA2B,EACA,GAMAA,EAAA8pB,EAAArB,gBACAqB,EAAArB,cAAA8B,EAAAvqB,IAGAA,EAAA8pB,EAAAzrB,OACAyrB,EAAA1O,MAIA0O,EAAAzrB,QAHAyrB,EAAAZ,cAAA,EACA,GAKAlpB,GAuHA,QAAAgqB,GAAAF,EAAA3D,GACA,GAAAM,GAAA,IAOA,OANAwD,GAAAtmB,SAAAwiB,IACA8D,EAAAU,SAAAxE,IACA8D,EAAAC,kBAAA/D,IACA2D,EAAAnB,aACAlC,EAAA,GAAAza,WAAA,oCAEAya,EAIA,QAAA0D,GAAAxF,EAAAmF,GACA,GAAAA,EAAAJ,UAAAI,EAAA1O,MAAA,CACA,GAAA+K,GAAA2D,EAAAJ,QAAApc,KACA6Y,MAAA9nB,SACAyrB,EAAA5kB,OAAA9B,KAAA+iB,GACA2D,EAAAzrB,QAAAyrB,EAAAnB,WAAA,EAAAxC,EAAA9nB,QAGAyrB,EAAA1O,OAAA,EAGAgP,EAAAzF,GAMA,QAAAyF,GAAAzF,GACA,GAAAmF,GAAAnF,EAAAiF,cACAE,GAAAZ,cAAA,EACAY,EAAAX,kBACA/H,EAAA,eAAA0I,EAAAhB,SACAgB,EAAAX,iBAAA,EACAW,EAAAb,KACA1jB,EAAAuC,SAAA,WACA8iB,EAAAjG,KAGAiG,EAAAjG,IAIA,QAAAiG,GAAAjG,GACAvD,EAAA,iBACAuD,EAAAxa,KAAA,YACA0gB,EAAAlG,GAUA,QAAA0F,GAAA1F,EAAAmF,GACAA,EAAAL,cACAK,EAAAL,aAAA,EACAlkB,EAAAuC,SAAA,WACAgjB,EAAAnG,EAAAmF,MAKA,QAAAgB,GAAAnG,EAAAmF,GAEA,IADA,GAAA/gB,GAAA+gB,EAAAzrB,QACAyrB,EAAAd,UAAAc,EAAAhB,UAAAgB,EAAA1O,OACA0O,EAAAzrB,OAAAyrB,EAAArB,gBACArH,EAAA,wBACAuD,EAAAtQ,KAAA,GACAtL,IAAA+gB,EAAAzrB,SAIA0K,EAAA+gB,EAAAzrB,MAEAyrB,GAAAL,aAAA,EA+IA,QAAAsB,GAAAjsB,GACA,kBACA,GAAAgrB,GAAAhrB,EAAA8qB,cACAxI,GAAA,cAAA0I,EAAAN,YACAM,EAAAN,YACAM,EAAAN,aACA,IAAAM,EAAAN,YAAAhE,EAAAmB,cAAA7nB,EAAA,UACAgrB,EAAAhB,SAAA,EACA+B,EAAA/rB,KA8GA,QAAAymB,GAAAZ,EAAAmF,GACAA,EAAAkB,kBACAlB,EAAAkB,iBAAA,EACAzlB,EAAAuC,SAAA,WACAmjB,EAAAtG,EAAAmF,MAKA,QAAAmB,GAAAtG,EAAAmF,GACAA,EAAAkB,iBAAA,EACArG,EAAAxa,KAAA,UACA0gB,EAAAlG,GACAmF,EAAAhB,UAAAgB,EAAAd,SACArE,EAAAtQ,KAAA,GAaA,QAAAwW,GAAAlG,GACA,GAAAmF,GAAAnF,EAAAiF,cAEA,IADAxI,EAAA,OAAA0I,EAAAhB,SACAgB,EAAAhB,QACA,EACA,IAAA3C,GAAAxB,EAAAtQ,aACK,OAAA8R,GAAA2D,EAAAhB,SAyEL,QAAAoC,GAAAlrB,EAAA8pB,GACA,GAIA/Z,GAJAkC,EAAA6X,EAAA5kB,OACA7G,EAAAyrB,EAAAzrB,OACA8sB,IAAArB,EAAAJ,QACAf,IAAAmB,EAAAnB,UAIA,QAAA1W,EAAA5T,OACA,WAEA,QAAAA,EACA0R,EAAA,SACA,IAAA4Y,EACA5Y,EAAAkC,EAAA4S,YACA,KAAA7kB,MAAA3B,EAGA0R,EADAob,EACAlZ,EAAAzP,KAAA,IAEAgD,EAAAnG,OAAA4S,EAAA5T,GACA4T,EAAA5T,OAAA,MAGA,IAAA2B,EAAAiS,EAAA,GAAA5T,OAAA,CAGA,GAAA0O,GAAAkF,EAAA,EACAlC,GAAAhD,EAAAiC,MAAA,EAAAhP,GACAiS,EAAA,GAAAlF,EAAAiC,MAAAhP,OACK,IAAAA,IAAAiS,EAAA,GAAA5T,OAEL0R,EAAAkC,EAAA4S,YACK,CAIL9U,EADAob,EACA,GAEA,GAAA3lB,GAAAxF,EAGA,QADAnC,GAAA,EACAM,EAAA,EAAA6Y,EAAA/E,EAAA5T,OAAsC2Y,EAAA7Y,GAAA6B,EAAAnC,EAAgBM,IAAA,CACtD,GAAA4O,GAAAkF,EAAA,GACAmZ,EAAAnrB,KAAAgP,IAAAjP,EAAAnC,EAAAkP,EAAA1O,OAEA8sB,GACApb,GAAAhD,EAAAiC,MAAA,EAAAoc,GAEAre,EAAAT,KAAAyD,EAAAlS,EAAA,EAAAutB,GAEAA,EAAAre,EAAA1O,OACA4T,EAAA,GAAAlF,EAAAiC,MAAAoc,GAEAnZ,EAAA4S,QAEAhnB,GAAAutB,GAKA,MAAArb,GAGA,QAAAsb,GAAA1G,GACA,GAAAmF,GAAAnF,EAAAiF,cAIA,IAAAE,EAAAzrB,OAAA,EACA,SAAA2J,OAAA,yCAEA8hB,GAAAf,aACAe,EAAA1O,OAAA,EACA7V,EAAAuC,SAAA,WAEAgiB,EAAAf,YAAA,IAAAe,EAAAzrB,SACAyrB,EAAAf,YAAA,EACApE,EAAAK,UAAA,EACAL,EAAAxa,KAAA,WAMA,QAAAmhB,GAAAxS,EAAAC,GACA,OAAA5a,GAAA,EAAA6Y,EAAA8B,EAAAza,OAAgC2Y,EAAA7Y,EAAOA,IACvC4a,EAAAD,EAAA3a,MAIA,QAAAmK,GAAAwQ,EAAA9Z,GACA,OAAAb,GAAA,EAAA6Y,EAAA8B,EAAAza,OAAgC2Y,EAAA7Y,EAAOA,IACvC,GAAA2a,EAAA3a,KAAAa,EAAA,MAAAb,EAEA,UAh6BAX,EAAAD,QAAAooB,CAGA,IAAAznB,GAAAd,EAAA,IAKAoI,EAAApI,EAAA,IAAAoI,MAGAmgB,GAAA4C,eAEA,IAAA/C,GAAApoB,EAAA,IAAAqoB,YAGAD,GAAAmB,gBAAAnB,EAAAmB,cAAA,SAAAqB,EAAA9f,GACA,MAAA8f,GAAAV,UAAApf,GAAA7J,QAIA,IAAAgnB,GAAAjoB,EAAA,IAGA6sB,EAAA7sB,EAAA,GACA6sB,GAAAvE,SAAAtoB,EAAA,GAGA,IAAAusB,GAIAvI,EAAAhkB,EAAA,GAEAgkB,GADAA,KAAAmK,SACAnK,EAAAmK,SAAA,UAEA,aAKAtB,EAAAvE,SAAAC,EAAAN,GAwFAM,EAAA7hB,UAAAV,KAAA,SAAA+iB,EAAAxa,GACA,GAAAme,GAAA/nB,KAAA6nB,cAUA,OARAK,GAAAU,SAAAxE,KAAA2D,EAAAnB,aACAhd,KAAAme,EAAAR,gBACA3d,IAAAme,EAAAne,WACAwa,EAAA,GAAA3gB,GAAA2gB,EAAAxa,GACAA,EAAA,KAIAke,EAAA9nB,KAAA+nB,EAAA3D,EAAAxa,GAAA,IAIAga,EAAA7hB,UAAA8U,QAAA,SAAAuN,GACA,GAAA2D,GAAA/nB,KAAA6nB,cACA,OAAAC,GAAA9nB,KAAA+nB,EAAA3D,EAAA,QAmEAR,EAAA7hB,UAAA0nB,YAAA,SAAAC,GAKA,MAJA9B,KACAA,EAAAvsB,EAAA,IAAAusB,eACA5nB,KAAA6nB,eAAAF,QAAA,GAAAC,GAAA8B,GACA1pB,KAAA6nB,eAAAje,SAAA8f,EACA1pB,KAIA,IAAAyoB,GAAA,OAmDA7E,GAAA7hB,UAAAuQ,KAAA,SAAArU,GACAohB,EAAA,OAAAphB,EACA,IAAA8pB,GAAA/nB,KAAA6nB,eACA8B,EAAA1rB,CAQA,MANAiqB,EAAAjD,SAAAhnB,MAAA,KACA8pB,EAAAX,iBAAA,GAKA,IAAAnpB,GACA8pB,EAAAZ,eACAY,EAAAzrB,QAAAyrB,EAAArB,eAAAqB,EAAA1O,OAMA,MALAgG,GAAA,qBAAA0I,EAAAzrB,OAAAyrB,EAAA1O,OACA,IAAA0O,EAAAzrB,QAAAyrB,EAAA1O,MACAiQ,EAAAtpB,MAEAqoB,EAAAroB,MACA,IAMA,IAHA/B,EAAAyqB,EAAAzqB,EAAA8pB,GAGA,IAAA9pB,GAAA8pB,EAAA1O,MAGA,MAFA,KAAA0O,EAAAzrB,QACAgtB,EAAAtpB,MACA,IA0BA,IAAA4pB,GAAA7B,EAAAZ,YACA9H,GAAA,gBAAAuK,IAGA,IAAA7B,EAAAzrB,QAAAyrB,EAAAzrB,OAAA2B,EAAA8pB,EAAArB,iBACAkD,GAAA,EACAvK,EAAA,6BAAAuK,KAKA7B,EAAA1O,OAAA0O,EAAAd,WACA2C,GAAA,EACAvK,EAAA,mBAAAuK,IAGAA,IACAvK,EAAA,WACA0I,EAAAd,SAAA,EACAc,EAAAb,MAAA,EAEA,IAAAa,EAAAzrB,SACAyrB,EAAAZ,cAAA,GAEAnnB,KAAA6pB,MAAA9B,EAAArB,eACAqB,EAAAb,MAAA,GAKA0C,IAAA7B,EAAAd,UACAhpB,EAAAyqB,EAAAiB,EAAA5B,GAEA,IAAA/Z,EAyBA,OAvBAA,GADA/P,EAAA,EACAkrB,EAAAlrB,EAAA8pB,GAEA,KAEAG,EAAAS,OAAA3a,KACA+Z,EAAAZ,cAAA,EACAlpB,EAAA,GAGA8pB,EAAAzrB,QAAA2B,EAIA,IAAA8pB,EAAAzrB,QAAAyrB,EAAA1O,QACA0O,EAAAZ,cAAA,GAGAwC,IAAA1rB,GAAA8pB,EAAA1O,OAAA,IAAA0O,EAAAzrB,QACAgtB,EAAAtpB,MAEAkoB,EAAAS,OAAA3a,IACAhO,KAAAoI,KAAA,OAAA4F,GAEAA,GAwFA4V,EAAA7hB,UAAA8nB,MAAA,SAAA5rB,GACA+B,KAAAoI,KAAA,WAAAnC,OAAA,qBAGA2d,EAAA7hB,UAAAkiB,KAAA,SAAAC,EAAA4F,GA6BA,QAAAC,GAAA9G,GACA5D,EAAA,YACA4D,IAAAlmB,GACA4nB,IAIA,QAAAJ,KACAlF,EAAA,SACA6E,EAAA3Y,MAUA,QAAAoZ,KACAtF,EAAA,WAEA6E,EAAAhc,eAAA,QAAAuc,GACAP,EAAAhc,eAAA,SAAA8hB,GACA9F,EAAAhc,eAAA,QAAAoc,GACAJ,EAAAhc,eAAA,QAAAzD,GACAyf,EAAAhc,eAAA,SAAA6hB,GACAhtB,EAAAmL,eAAA,MAAAqc,GACAxnB,EAAAmL,eAAA,MAAAyc,GACA5nB,EAAAmL,eAAA,OAAAic,IAOA4D,EAAAN,YACAvD,EAAA+F,iBAAA/F,EAAA+F,eAAAC,WACA5F,IAIA,QAAAH,GAAAC,GACA/E,EAAA,SACA,IAAArR,GAAAkW,EAAAra,MAAAua,IACA,IAAApW,IACAqR,EAAA,8BACAtiB,EAAA8qB,eAAAJ,YACA1qB,EAAA8qB,eAAAJ,aACA1qB,EAAAwmB,SAMA,QAAA9e,GAAAigB,GACArF,EAAA,UAAAqF,GACAyF,IACAjG,EAAAhc,eAAA,QAAAzD,GACA,IAAAgf,EAAAmB,cAAAV,EAAA,UACAA,EAAA9b,KAAA,QAAAsc,GAcA,QAAAD,KACAP,EAAAhc,eAAA,SAAA8hB,GACAG,IAGA,QAAAH,KACA3K,EAAA,YACA6E,EAAAhc,eAAA,QAAAuc,GACA0F,IAIA,QAAAA,KACA9K,EAAA,UACAtiB,EAAAotB,OAAAjG,GApHA,GAAAnnB,GAAAiD,KACA+nB,EAAA/nB,KAAA6nB,cAEA,QAAAE,EAAAjB,YACA,OACAiB,EAAAlB,MAAA3C,CACA,MACA,QACA6D,EAAAlB,OAAAkB,EAAAlB,MAAA3C,EACA,MACA,SACA6D,EAAAlB,MAAAxlB,KAAA6iB,GAGA6D,EAAAjB,YAAA,EACAzH,EAAA,wBAAA0I,EAAAjB,WAAAgD,EAEA,IAAAM,KAAAN,KAAAve,OAAA,IACA2Y,IAAA1gB,EAAA6mB,QACAnG,IAAA1gB,EAAA8mB,OAEAC,EAAAH,EAAA7F,EAAAI,CACAoD,GAAAf,WACAxjB,EAAAuC,SAAAwkB,GAEAxtB,EAAAiL,KAAA,MAAAuiB,GAEArG,EAAApc,GAAA,SAAAiiB,EAiBA,IAAAzF,GAAA0E,EAAAjsB,EAoFA,OAnFAmnB,GAAApc,GAAA,QAAAwc,GAwBAvnB,EAAA+K,GAAA,OAAAqc,GAuBAD,EAAAY,SAAAZ,EAAAY,QAAAU,MAEArpB,EAAA+nB,EAAAY,QAAAU,OACAtB,EAAAY,QAAAU,MAAA3O,QAAApS,GAEAyf,EAAAY,QAAAU,OAAA/gB,EAAAyf,EAAAY,QAAAU,OAJAtB,EAAApc,GAAA,QAAArD,GAaAyf,EAAAlc,KAAA,QAAAyc,GAMAP,EAAAlc,KAAA,SAAAgiB,GAQA9F,EAAA9b,KAAA,OAAArL,GAGAgrB,EAAAhB,UACA1H,EAAA,eACAtiB,EAAAymB,UAGAU,GAiBAN,EAAA7hB,UAAAooB,OAAA,SAAAjG,GACA,GAAA6D,GAAA/nB,KAAA6nB,cAGA,QAAAE,EAAAjB,WACA,MAAA9mB,KAGA,QAAA+nB,EAAAjB,WAEA,MAAA5C,QAAA6D,EAAAlB,MACA7mB,MAEAkkB,IACAA,EAAA6D,EAAAlB,OAGAkB,EAAAlB,MAAA,KACAkB,EAAAjB,WAAA,EACAiB,EAAAhB,SAAA,EACA7C,GACAA,EAAA9b,KAAA,SAAApI,MACAA,KAKA,KAAAkkB,EAAA,CAEA,GAAAsG,GAAAzC,EAAAlB,MACA7f,EAAA+gB,EAAAjB,UACAiB,GAAAlB,MAAA,KACAkB,EAAAjB,WAAA,EACAiB,EAAAhB,SAAA,CAEA,QAAA3qB,GAAA,EAAmB4K,EAAA5K,EAASA,IAC5BouB,EAAApuB,GAAAgM,KAAA,SAAApI,KACA,OAAAA,MAIA,GAAA5D,GAAAmK,EAAAwhB,EAAAlB,MAAA3C,EACA,YAAA9nB,EACA4D,MAEA+nB,EAAAlB,MAAAjQ,OAAAxa,EAAA,GACA2rB,EAAAjB,YAAA,EACA,IAAAiB,EAAAjB,aACAiB,EAAAlB,MAAAkB,EAAAlB,MAAA,IAEA3C,EAAA9b,KAAA,SAAApI,MAEAA,OAKA4jB,EAAA7hB,UAAA+F,GAAA,SAAA2iB,EAAAC,GACA,GAAAvd,GAAAmW,EAAAvhB,UAAA+F,GAAAlM,KAAAoE,KAAAyqB,EAAAC,EAQA,IAJA,SAAAD,IAAA,IAAAzqB,KAAA6nB,eAAAd,SACA/mB,KAAAwjB,SAGA,aAAAiH,GAAAzqB,KAAAijB,SAAA,CACA,GAAA8E,GAAA/nB,KAAA6nB,cACA,KAAAE,EAAAV,kBAIA,GAHAU,EAAAV,mBAAA,EACAU,EAAAX,iBAAA,EACAW,EAAAZ,cAAA,EACAY,EAAAd,QAMOc,EAAAzrB,QACP+rB,EAAAroB,KAAA+nB,OAPA,CACA,GAAA4C,GAAA3qB,IACAwD,GAAAuC,SAAA,WACAsZ,EAAA,4BACAsL,EAAArY,KAAA,MAQA,MAAAnF,IAEAyW,EAAA7hB,UAAAgG,YAAA6b,EAAA7hB,UAAA+F,GAIA8b,EAAA7hB,UAAAyhB,OAAA,WACA,GAAAuE,GAAA/nB,KAAA6nB,cAUA,OATAE,GAAAhB,UACA1H,EAAA,UACA0I,EAAAhB,SAAA,EACAgB,EAAAd,UACA5H,EAAA,iBACArf,KAAAsS,KAAA,IAEAkR,EAAAxjB,KAAA+nB,IAEA/nB,MAoBA4jB,EAAA7hB,UAAAwhB,MAAA,WAOA,MANAlE,GAAA,wBAAArf,KAAA6nB,eAAAd,UACA,IAAA/mB,KAAA6nB,eAAAd,UACA1H,EAAA,SACArf,KAAA6nB,eAAAd,SAAA,EACA/mB,KAAAoI,KAAA,UAEApI,MAgBA4jB,EAAA7hB,UAAA6oB,KAAA,SAAAhI,GACA,GAAAmF,GAAA/nB,KAAA6nB,eACAhF,GAAA,EAEA8H,EAAA3qB,IACA4iB,GAAA9a,GAAA,iBAEA,GADAuX,EAAA,eACA0I,EAAAJ,UAAAI,EAAA1O,MAAA,CACA,GAAA+K,GAAA2D,EAAAJ,QAAApc,KACA6Y,MAAA9nB,QACAquB,EAAAtpB,KAAA+iB,GAGAuG,EAAAtpB,KAAA,QAGAuhB,EAAA9a,GAAA,gBAAAsc,GAIA,GAHA/E,EAAA,gBACA0I,EAAAJ,UACAvD,EAAA2D,EAAAJ,QAAA9d,MAAAua,IACAA,IAAA2D,EAAAnB,YAAAxC,EAAA9nB,QAAA,CAGA,GAAA0R,GAAA2c,EAAAtpB,KAAA+iB,EACApW,KACA6U,GAAA,EACAD,EAAAW,WAMA,QAAAnnB,KAAAwmB,GACAsF,EAAAlD,WAAApC,EAAAxmB,KAAA8rB,EAAA/C,YAAAnlB,KAAA5D,MACA4D,KAAA5D,GAAA,SAAAyuB,GAAkC,kBAClC,MAAAjI,GAAAiI,GAAAtjB,MAAAqb,EAAAtb,aACQlL,GAKR,IAAA0uB,IAAA,2CAeA,OAdAvB,GAAAuB,EAAA,SAAAL,GACA7H,EAAA9a,GAAA2iB,EAAAE,EAAAviB,KAAA+X,KAAAwK,EAAAF,MAKAE,EAAAd,MAAA,SAAA5rB,GACAohB,EAAA,gBAAAphB,GACA4kB,IACAA,GAAA,EACAD,EAAAY,WAIAmH,GAMA/G,EAAAmH,UAAA5B,I5B8tJ8BvtB,KAAKJ,EAASH,EAAoB,KAI1D,SAASI,EAAQD,G6BpjLvBC,EAAAD,QAAAU,MAAAC,SAAA,SAAAF,GACA,wBAAA6F,OAAAC,UAAAC,SAAApG,KAAAK,K7B4jLM,SAASR,EAAQD,EAASH,I8B7jLhC,SAAAoI,GAwBA,QAAAtH,GAAAgN,GACA,MAAAjN,OAAAC,QACAD,MAAAC,QAAAgN,GAEA,mBAAA6hB,EAAA7hB,GAIA,QAAA8hB,GAAA9hB,GACA,uBAAAA,GAIA,QAAAwf,GAAAxf,GACA,cAAAA,EAIA,QAAAgf,GAAAhf,GACA,aAAAA,EAIA,QAAA8b,GAAA9b,GACA,sBAAAA,GAIA,QAAAyf,GAAAzf,GACA,sBAAAA,GAIA,QAAA+hB,GAAA/hB,GACA,sBAAAA,GAIA,QAAAgc,GAAAhc,GACA,gBAAAA,EAIA,QAAAgiB,GAAAlK,GACA,0BAAA+J,EAAA/J,GAIA,QAAAiE,GAAA/b,GACA,sBAAAA,IAAA,OAAAA,EAIA,QAAAiiB,GAAA9oB,GACA,wBAAA0oB,EAAA1oB,GAIA,QAAA+oB,GAAAriB,GACA,yBAAAgiB,EAAAhiB,gBAAA/C,OAIA,QAAA+e,GAAA7b,GACA,wBAAAA,GAIA,QAAAmiB,GAAAniB,GACA,cAAAA,GACA,iBAAAA,IACA,gBAAAA,IACA,gBAAAA,IACA,gBAAAA,IACA,mBAAAA,GAMA,QAAA6hB,GAAAO,GACA,MAAAzpB,QAAAC,UAAAC,SAAApG,KAAA2vB,GA3EA/vB,EAAAW,UAKAX,EAAAyvB,YAKAzvB,EAAAmtB,SAKAntB,EAAA2sB,oBAKA3sB,EAAAypB,WAKAzpB,EAAAotB,WAKAptB,EAAA0vB,WAKA1vB,EAAA2pB,cAKA3pB,EAAA2vB,WAKA3vB,EAAA0pB,WAKA1pB,EAAA4vB,SAKA5vB,EAAA6vB,UAKA7vB,EAAAwpB,aAUAxpB,EAAA8vB,cAEA9vB,EAAAoG,SAAA6B,EAAA7B,W9BqkL8BhG,KAAKJ,EAASH,EAAoB,IAAIoI,SAI9D,SAAShI,EAAQD,KAMjB,SAASC,EAAQD,EAASH,I+BrrLhC,SAAAmI,GAoDA,QAAAsgB,GAAAjnB,GACA,MAAAmD,gBAAA8jB,IAGAF,EAAAhoB,KAAAoE,KAAAnD,GACAgnB,EAAAjoB,KAAAoE,KAAAnD,GAEAA,KAAAomB,YAAA,IACAjjB,KAAAijB,UAAA,GAEApmB,KAAAmmB,YAAA,IACAhjB,KAAAgjB,UAAA,GAEAhjB,KAAAwrB,eAAA,EACA3uB,KAAA2uB,iBAAA,IACAxrB,KAAAwrB,eAAA,OAEAxrB,MAAAgI,KAAA,MAAAuc,IAfA,GAAAT,GAAAjnB,GAmBA,QAAA0nB,KAGAvkB,KAAAwrB,eAAAxrB,KAAAiqB,eAAA5Q,OAKA7V,EAAAuC,SAAA/F,KAAAuL,IAAA4U,KAAAngB,OAGA,QAAAupB,GAAAxS,EAAAC,GACA,OAAA5a,GAAA,EAAA6Y,EAAA8B,EAAAza,OAAgC2Y,EAAA7Y,EAAOA,IACvC4a,EAAAD,EAAA3a,MA5DAX,EAAAD,QAAAsoB,CAGA,IAAA2H,GAAA3pB,OAAA4pB,MAAA,SAAAroB,GACA,GAAAqoB,KACA,QAAA3F,KAAA1iB,GAAAqoB,EAAArqB,KAAA0kB,EACA,OAAA2F,IAMAxD,EAAA7sB,EAAA,GACA6sB,GAAAvE,SAAAtoB,EAAA,GAGA,IAAAuoB,GAAAvoB,EAAA,IACAwoB,EAAAxoB,EAAA,GAEA6sB,GAAAvE,SAAAG,EAAAF,GAEA2F,EAAAkC,EAAA5H,EAAA9hB,WAAA,SAAA8oB,GACA/G,EAAA/hB,UAAA8oB,KACA/G,EAAA/hB,UAAA8oB,GAAAhH,EAAA9hB,UAAA8oB,Q/BguL8BjvB,KAAKJ,EAASH,EAAoB,KAI1D,SAASI,EAAQD,EAASH,IgCrxLhC,SAAAmI,GA2CA,QAAAmoB,GAAAvH,EAAAxa,EAAA9M,GACAkD,KAAAokB,QACApkB,KAAA4J,WACA5J,KAAA4rB,SAAA9uB,EAGA,QAAA+uB,GAAAhvB,EAAA+lB,GACA,GAAAkB,GAAAzoB,EAAA,GAEAwB,QAKA,IAAA4pB,GAAA5pB,EAAA6pB,cACAC,EAAA9pB,EAAA+pB,WAAA,QACA5mB,MAAA0mB,cAAAD,GAAA,IAAAA,IAAAE,EAIA3mB,KAAA4mB,aAAA/pB,EAAA+pB,WAEAhE,YAAAkB,KACA9jB,KAAA4mB,WAAA5mB,KAAA4mB,cAAA/pB,EAAAivB,oBAGA9rB,KAAA0mB,gBAAA1mB,KAAA0mB,cAEA1mB,KAAAkqB,WAAA,EAEAlqB,KAAA+rB,QAAA,EAEA/rB,KAAAqZ,OAAA,EAEArZ,KAAAgsB,UAAA,CAKA,IAAAC,GAAApvB,EAAAqvB,iBAAA,CACAlsB,MAAAksB,eAAAD,EAKAjsB,KAAAunB,gBAAA1qB,EAAA0qB,iBAAA,OAKAvnB,KAAA1D,OAAA,EAGA0D,KAAAmsB,SAAA,EAGAnsB,KAAAosB,OAAA,EAMApsB,KAAAknB,MAAA,EAKAlnB,KAAAqsB,kBAAA,EAGArsB,KAAAssB,QAAA,SAAA5H,GACA4H,EAAA1J,EAAA8B,IAIA1kB,KAAAusB,QAAA,KAGAvsB,KAAAwsB,SAAA,EAEAxsB,KAAAmD,UAIAnD,KAAAysB,UAAA,EAIAzsB,KAAA0sB,aAAA,EAGA1sB,KAAA2sB,cAAA,EAGA,QAAA9I,GAAAhnB,GACA,GAAAinB,GAAAzoB,EAAA,GAIA,OAAA2E,gBAAA6jB,IAAA7jB,eAAA8jB,IAGA9jB,KAAAiqB,eAAA,GAAA4B,GAAAhvB,EAAAmD,MAGAA,KAAAgjB,UAAA,MAEAM,GAAA1nB,KAAAoE,OAPA,GAAA6jB,GAAAhnB,GAgBA,QAAA+vB,GAAAhK,EAAAmF,EAAAjrB,GACA,GAAA4nB,GAAA,GAAAze,OAAA,kBAEA2c,GAAAxa,KAAA,QAAAsc,GACAlhB,EAAAuC,SAAA,WACAjJ,EAAA4nB,KASA,QAAAmI,GAAAjK,EAAAmF,EAAA3D,EAAAtnB,GACA,GAAAgwB,IAAA,CACA,MAAA5E,EAAAtmB,SAAAwiB,IACA8D,EAAAU,SAAAxE,IACA8D,EAAAC,kBAAA/D,IACA2D,EAAAnB,YAAA,CACA,GAAAlC,GAAA,GAAAza,WAAA,kCACA2Y,GAAAxa,KAAA,QAAAsc,GACAlhB,EAAAuC,SAAA,WACAjJ,EAAA4nB,KAEAoI,GAAA,EAEA,MAAAA,GAmDA,QAAAC,GAAAhF,EAAA3D,EAAAxa,GAMA,OALAme,EAAAnB,YACAmB,EAAAmE,iBAAA,GACAhE,EAAAU,SAAAxE,KACAA,EAAA,GAAA3gB,GAAA2gB,EAAAxa,IAEAwa,EAMA,QAAA4I,GAAApK,EAAAmF,EAAA3D,EAAAxa,EAAA9M,GACAsnB,EAAA2I,EAAAhF,EAAA3D,EAAAxa,GACAse,EAAAtmB,SAAAwiB,KACAxa,EAAA,SACA,IAAA5C,GAAA+gB,EAAAnB,WAAA,EAAAxC,EAAA9nB,MAEAyrB,GAAAzrB,QAAA0K,CAEA,IAAAgH,GAAA+Z,EAAAzrB,OAAAyrB,EAAArB,aAUA,OARA1Y,KACA+Z,EAAAmC,WAAA,GAEAnC,EAAAoE,SAAApE,EAAAqE,OACArE,EAAA5kB,OAAA9B,KAAA,GAAAsqB,GAAAvH,EAAAxa,EAAA9M,IAEAmwB,EAAArK,EAAAmF,GAAA,EAAA/gB,EAAAod,EAAAxa,EAAA9M,GAEAkR,EAGA,QAAAif,GAAArK,EAAAmF,EAAAmF,EAAAlmB,EAAAod,EAAAxa,EAAA9M,GACAirB,EAAAyE,SAAAxlB,EACA+gB,EAAAwE,QAAAzvB,EACAirB,EAAAoE,SAAA,EACApE,EAAAb,MAAA,EACAgG,EACAtK,EAAAuK,QAAA/I,EAAA2D,EAAAuE,SAEA1J,EAAAwK,OAAAhJ,EAAAxa,EAAAme,EAAAuE,SACAvE,EAAAb,MAAA,EAGA,QAAAmG,GAAAzK,EAAAmF,EAAAb,EAAAxC,EAAA5nB,GACAoqB,EACA1jB,EAAAuC,SAAA,WACAgiB,EAAA0E,YACA3vB,EAAA4nB,MAGAqD,EAAA0E,YACA3vB,EAAA4nB,IAGA9B,EAAAqH,eAAA0C,cAAA,EACA/J,EAAAxa,KAAA,QAAAsc,GAGA,QAAA4I,GAAAvF,GACAA,EAAAoE,SAAA,EACApE,EAAAwE,QAAA,KACAxE,EAAAzrB,QAAAyrB,EAAAyE,SACAzE,EAAAyE,SAAA,EAGA,QAAAF,GAAA1J,EAAA8B,GACA,GAAAqD,GAAAnF,EAAAqH,eACA/C,EAAAa,EAAAb,KACApqB,EAAAirB,EAAAwE,OAIA,IAFAe,EAAAvF,GAEArD,EACA2I,EAAAzK,EAAAmF,EAAAb,EAAAxC,EAAA5nB,OACA,CAEA,GAAAkvB,GAAAuB,EAAA3K,EAAAmF,EAEAiE,IACAjE,EAAAqE,QACArE,EAAAsE,mBACAtE,EAAA5kB,OAAA7G,QACAkxB,EAAA5K,EAAAmF,GAGAb,EACA1jB,EAAAuC,SAAA,WACA0nB,EAAA7K,EAAAmF,EAAAiE,EAAAlvB,KAGA2wB,EAAA7K,EAAAmF,EAAAiE,EAAAlvB,IAKA,QAAA2wB,GAAA7K,EAAAmF,EAAAiE,EAAAlvB,GACAkvB,GACA0B,EAAA9K,EAAAmF,GACAA,EAAA0E,YACA3vB,IACA6wB,EAAA/K,EAAAmF,GAMA,QAAA2F,GAAA9K,EAAAmF,GACA,IAAAA,EAAAzrB,QAAAyrB,EAAAmC,YACAnC,EAAAmC,WAAA,EACAtH,EAAAxa,KAAA,UAMA,QAAAolB,GAAA5K,EAAAmF,GAGA,GAFAA,EAAAsE,kBAAA,EAEAzJ,EAAAuK,SAAApF,EAAA5kB,OAAA7G,OAAA,GAGA,OADAsxB,MACA9xB,EAAA,EAAmBA,EAAAisB,EAAA5kB,OAAA7G,OAAyBR,IAC5C8xB,EAAAvsB,KAAA0mB,EAAA5kB,OAAArH,GAAA8vB,SAIA7D,GAAA0E,YACAQ,EAAArK,EAAAmF,GAAA,EAAAA,EAAAzrB,OAAAyrB,EAAA5kB,OAAA,YAAAzE,GACA,OAAAtC,GAAA,EAAqBA,EAAAwxB,EAAAtxB,OAAgBF,IACrC2rB,EAAA0E,YACAmB,EAAAxxB,GAAAsC,KAKAqpB,EAAA5kB,cACG,CAEH,OAAArH,GAAA,EAAmBA,EAAAisB,EAAA5kB,OAAA7G,OAAyBR,IAAA,CAC5C,GAAA+xB,GAAA9F,EAAA5kB,OAAArH,GACAsoB,EAAAyJ,EAAAzJ,MACAxa,EAAAikB,EAAAjkB,SACA9M,EAAA+wB,EAAAjC,SACA5kB,EAAA+gB,EAAAnB,WAAA,EAAAxC,EAAA9nB,MAQA,IANA2wB,EAAArK,EAAAmF,GAAA,EAAA/gB,EAAAod,EAAAxa,EAAA9M,GAMAirB,EAAAoE,QAAA,CACArwB,GACA,QAIAA,EAAAisB,EAAA5kB,OAAA7G,OACAyrB,EAAA5kB,OAAA4kB,EAAA5kB,OAAA8J,MAAAnR,GAEAisB,EAAA5kB,OAAA7G,OAAA,EAGAyrB,EAAAsE,kBAAA,EAqCA,QAAAkB,GAAA3K,EAAAmF,GACA,MAAAA,GAAAgE,QACA,IAAAhE,EAAAzrB,SACAyrB,EAAAiE,WACAjE,EAAAoE,QAGA,QAAA2B,GAAAlL,EAAAmF,GACAA,EAAA2E,cACA3E,EAAA2E,aAAA,EACA9J,EAAAxa,KAAA,cAIA,QAAAulB,GAAA/K,EAAAmF,GACA,GAAAgG,GAAAR,EAAA3K,EAAAmF,EASA,OARAgG,KACA,IAAAhG,EAAA0E,WACAqB,EAAAlL,EAAAmF,GACAA,EAAAiE,UAAA,EACApJ,EAAAxa,KAAA,WAEA0lB,EAAAlL,EAAAmF,IAEAgG,EAGA,QAAAC,GAAApL,EAAAmF,EAAAjrB,GACAirB,EAAAgE,QAAA,EACA4B,EAAA/K,EAAAmF,GACAjrB,IACAirB,EAAAiE,SACAxoB,EAAAuC,SAAAjJ,GAEA8lB,EAAA5a,KAAA,SAAAlL,IAEAirB,EAAA1O,OAAA,EAlcA5d,EAAAD,QAAAqoB,CAGA,IAAApgB,GAAApI,EAAA,IAAAoI,MAGAogB,GAAAgI,eAIA,IAAA3D,GAAA7sB,EAAA,GACA6sB,GAAAvE,SAAAtoB,EAAA,GAGA,IAAAioB,GAAAjoB,EAAA,GAEA6sB,GAAAvE,SAAAE,EAAAP,GAiHAO,EAAA9hB,UAAAkiB,KAAA,WACAjkB,KAAAoI,KAAA,WAAAnC,OAAA,gCAkCA4d,EAAA9hB,UAAA8H,MAAA,SAAAua,EAAAxa,EAAA9M,GACA,GAAAirB,GAAA/nB,KAAAiqB,eACAjc,GAAA,CAsBA,OApBAka,GAAAlD,WAAApb,KACA9M,EAAA8M,EACAA,EAAA,MAGAse,EAAAtmB,SAAAwiB,GACAxa,EAAA,SACAA,IACAA,EAAAme,EAAAR,iBAEAW,EAAAlD,WAAAloB,KACAA,EAAA,cAEAirB,EAAA1O,MACAuT,EAAA5sB,KAAA+nB,EAAAjrB,GACA+vB,EAAA7sB,KAAA+nB,EAAA3D,EAAAtnB,KACAirB,EAAA0E,YACAze,EAAAgf,EAAAhtB,KAAA+nB,EAAA3D,EAAAxa,EAAA9M,IAGAkR,GAGA6V,EAAA9hB,UAAAksB,KAAA,WACA,GAAAlG,GAAA/nB,KAAAiqB,cAEAlC,GAAAqE,UAGAvI,EAAA9hB,UAAAmsB,OAAA,WACA,GAAAnG,GAAA/nB,KAAAiqB,cAEAlC,GAAAqE,SACArE,EAAAqE,SAEArE,EAAAoE,SACApE,EAAAqE,QACArE,EAAAiE,UACAjE,EAAAsE,mBACAtE,EAAA5kB,OAAA7G,QACAkxB,EAAAxtB,KAAA+nB,KA4KAlE,EAAA9hB,UAAAqrB,OAAA,SAAAhJ,EAAAxa,EAAA9M,GACAA,EAAA,GAAAmJ,OAAA,qBAIA4d,EAAA9hB,UAAAorB,QAAA,KAEAtJ,EAAA9hB,UAAAwJ,IAAA,SAAA6Y,EAAAxa,EAAA9M,GACA,GAAAirB,GAAA/nB,KAAAiqB,cAEA/B,GAAAlD,WAAAZ,IACAtnB,EAAAsnB,EACAA,EAAA,KACAxa,EAAA,MACGse,EAAAlD,WAAApb,KACH9M,EAAA8M,EACAA,EAAA,MAGAse,EAAAC,kBAAA/D,IACApkB,KAAA6J,MAAAua,EAAAxa,GAGAme,EAAAqE,SACArE,EAAAqE,OAAA,EACApsB,KAAAkuB,UAIAnG,EAAAgE,QAAAhE,EAAAiE,UACAgC,EAAAhuB,KAAA+nB,EAAAjrB,MhCk0L8BlB,KAAKJ,EAASH,EAAoB,KAI1D,SAASI,EAAQD,EAASH,GiCztMhC,QAAA8yB,GAAAvkB,GACA,GAAAA,IAAAwkB,EAAAxkB,GACA,SAAA3D,OAAA,qBAAA2D,GA8KA,QAAAykB,GAAAlrB,GACA,MAAAA,GAAAnB,SAAAhC,KAAA4J,UAGA,QAAA0kB,GAAAnrB,GACAnD,KAAAuuB,aAAAprB,EAAA7G,OAAA,EACA0D,KAAAwuB,WAAAxuB,KAAAuuB,aAAA,IAGA,QAAAE,GAAAtrB,GACAnD,KAAAuuB,aAAAprB,EAAA7G,OAAA,EACA0D,KAAAwuB,WAAAxuB,KAAAuuB,aAAA,IAtMA,GAAA9qB,GAAApI,EAAA,IAAAoI,OAEA2qB,EAAA3qB,EAAAwM,YACA,SAAArG,GACA,OAAAA,KAAAwB,eACA,6IACA,oBAmBAwc,EAAApsB,EAAAosB,cAAA,SAAAhe,GAGA,OAFA5J,KAAA4J,aAAA,QAAAwB,cAAAgE,QAAA,WACA+e,EAAAvkB,GACA5J,KAAA4J,UACA,WAEA5J,KAAA0uB,cAAA,CACA,MACA,YACA,cAEA1uB,KAAA0uB,cAAA,EACA1uB,KAAA2uB,qBAAAL,CACA,MACA,cAEAtuB,KAAA0uB,cAAA,EACA1uB,KAAA2uB,qBAAAF,CACA,MACA,SAEA,YADAzuB,KAAA6J,MAAAwkB,GAMAruB,KAAA4uB,WAAA,GAAAnrB,GAAA,GAEAzD,KAAAuuB,aAAA,EAEAvuB,KAAAwuB,WAAA,EAaA5G,GAAA7lB,UAAA8H,MAAA,SAAA1G,GAGA,IAFA,GAAA0rB,GAAA,GAEA7uB,KAAAwuB,YAAA,CAEA,GAAAM,GAAA3rB,EAAA7G,QAAA0D,KAAAwuB,WAAAxuB,KAAAuuB,aACAvuB,KAAAwuB,WAAAxuB,KAAAuuB,aACAprB,EAAA7G,MAMA,IAHA6G,EAAAoH,KAAAvK,KAAA4uB,WAAA5uB,KAAAuuB,aAAA,EAAAO,GACA9uB,KAAAuuB,cAAAO,EAEA9uB,KAAAuuB,aAAAvuB,KAAAwuB,WAEA,QAIArrB,KAAA8J,MAAA6hB,EAAA3rB,EAAA7G,QAGAuyB,EAAA7uB,KAAA4uB,WAAA3hB,MAAA,EAAAjN,KAAAwuB,YAAAxsB,SAAAhC,KAAA4J,SAGA,IAAAmlB,GAAAF,EAAApf,WAAAof,EAAAvyB,OAAA,EACA,MAAAyyB,GAAA,cAAAA,GAAA,CAQA,GAHA/uB,KAAAuuB,aAAAvuB,KAAAwuB,WAAA,EAGA,IAAArrB,EAAA7G,OACA,MAAAuyB,EAEA,OAVA7uB,KAAAwuB,YAAAxuB,KAAA0uB,cACAG,EAAA,GAaA7uB,KAAA2uB,qBAAAxrB,EAEA,IAAAoI,GAAApI,EAAA7G,MACA0D,MAAAwuB,aAEArrB,EAAAoH,KAAAvK,KAAA4uB,WAAA,EAAAzrB,EAAA7G,OAAA0D,KAAAuuB,aAAAhjB,GACAA,GAAAvL,KAAAuuB,cAGAM,GAAA1rB,EAAAnB,SAAAhC,KAAA4J,SAAA,EAAA2B,EAEA,IAAAA,GAAAsjB,EAAAvyB,OAAA,EACAyyB,EAAAF,EAAApf,WAAAlE,EAEA,IAAAwjB,GAAA,cAAAA,EAAA,CACA,GAAAC,GAAAhvB,KAAA0uB,aAKA,OAJA1uB,MAAAwuB,YAAAQ,EACAhvB,KAAAuuB,cAAAS,EACAhvB,KAAA4uB,WAAArkB,KAAAvK,KAAA4uB,WAAAI,EAAA,EAAAA,GACA7rB,EAAAoH,KAAAvK,KAAA4uB,WAAA,IAAAI,GACAH,EAAAI,UAAA,EAAA1jB,GAIA,MAAAsjB,IAOAjH,EAAA7lB,UAAA4sB,qBAAA,SAAAxrB,GAMA,IAJA,GAAA/G,GAAA+G,EAAA7G,QAAA,IAAA6G,EAAA7G,OAIQF,EAAA,EAAOA,IAAA,CACf,GAAAN,GAAAqH,IAAA7G,OAAAF,EAKA,OAAAA,GAAAN,GAAA,MACAkE,KAAAwuB,WAAA,CACA,OAIA,MAAApyB,GAAAN,GAAA,OACAkE,KAAAwuB,WAAA,CACA,OAIA,MAAApyB,GAAAN,GAAA,OACAkE,KAAAwuB,WAAA,CACA,QAGAxuB,KAAAuuB,aAAAnyB,GAGAwrB,EAAA7lB,UAAAwJ,IAAA,SAAApI,GACA,GAAAgK,GAAA,EAIA,IAHAhK,KAAA7G,SACA6Q,EAAAnN,KAAA6J,MAAA1G,IAEAnD,KAAAuuB,aAAA,CACA,GAAAW,GAAAlvB,KAAAuuB,aACAvjB,EAAAhL,KAAA4uB,WACAlF,EAAA1pB,KAAA4J,QACAuD,IAAAnC,EAAAiC,MAAA,EAAAiiB,GAAAltB,SAAA0nB,GAGA,MAAAvc,KjC+wMM,SAAS1R,EAAQD,EAASH,GkCh5MhC,QAAA8zB,GAAAtyB,EAAA+lB,GACA5iB,KAAAovB,eAAA,SAAA1K,EAAAnnB,GACA,MAAA6xB,GAAAxM,EAAA8B,EAAAnnB,IAGAyC,KAAAqvB,eAAA,EACArvB,KAAAsvB,cAAA,EACAtvB,KAAAusB,QAAA,KACAvsB,KAAAuvB,WAAA,KAGA,QAAAH,GAAAxM,EAAA8B,EAAAnnB,GACA,GAAAiyB,GAAA5M,EAAA6M,eACAD,GAAAF,cAAA,CAEA,IAAAxyB,GAAA0yB,EAAAjD,OAEA,KAAAzvB,EACA,MAAA8lB,GAAAxa,KAAA,WAAAnC,OAAA,iCAEAupB,GAAAD,WAAA,KACAC,EAAAjD,QAAA,KAEArE,EAAAC,kBAAA5qB,IACAqlB,EAAAvhB,KAAA9D,GAEAT,GACAA,EAAA4nB,EAEA,IAAAgL,GAAA9M,EAAAiF,cACA6H,GAAAzI,SAAA,GACAyI,EAAAvI,cAAAuI,EAAApzB,OAAAozB,EAAAhJ,gBACA9D,EAAAiH,MAAA6F,EAAAhJ,eAKA,QAAA3C,GAAAlnB,GACA,KAAAmD,eAAA+jB,IACA,UAAAA,GAAAlnB,EAEAinB,GAAAloB,KAAAoE,KAAAnD,GAEAmD,KAAAyvB,gBAAA,GAAAN,GAAAtyB,EAAAmD,KAGA,IAAA4iB,GAAA5iB,IAGAA,MAAA6nB,eAAAV,cAAA,EAKAnnB,KAAA6nB,eAAAX,MAAA,EAEAlnB,KAAAgI,KAAA,uBACAkgB,EAAAlD,WAAAhlB,KAAA2vB,QACA3vB,KAAA2vB,OAAA,SAAAjL,GACAkL,EAAAhN,EAAA8B,KAGAkL,EAAAhN,KAsDA,QAAAgN,GAAAhN,EAAA8B,GACA,GAAAA,EACA,MAAA9B,GAAAxa,KAAA,QAAAsc,EAIA,IAAAmL,GAAAjN,EAAAqH,eACAuF,EAAA5M,EAAA6M,eAEA,IAAAI,EAAAvzB,OACA,SAAA2J,OAAA,6CAEA,IAAAupB,EAAAF,aACA,SAAArpB,OAAA,iDAEA,OAAA2c,GAAAvhB,KAAA,MA/IA5F,EAAAD,QAAAuoB,CAEA,IAAAD,GAAAzoB,EAAA,IAGA6sB,EAAA7sB,EAAA,GACA6sB,GAAAvE,SAAAtoB,EAAA,IAGA6sB,EAAAvE,SAAAI,EAAAD,GAqEAC,EAAAhiB,UAAAV,KAAA,SAAA+iB,EAAAxa,GAEA,MADA5J,MAAAyvB,gBAAAJ,eAAA,EACAvL,EAAA/hB,UAAAV,KAAAzF,KAAAoE,KAAAokB,EAAAxa,IAaAma,EAAAhiB,UAAA+tB,WAAA,SAAA1L,EAAAxa,EAAA9M,GACA,SAAAmJ,OAAA,oBAGA8d,EAAAhiB,UAAAqrB,OAAA,SAAAhJ,EAAAxa,EAAA9M,GACA,GAAA0yB,GAAAxvB,KAAAyvB,eAIA,IAHAD,EAAAjD,QAAAzvB,EACA0yB,EAAAD,WAAAnL,EACAoL,EAAAO,cAAAnmB,GACA4lB,EAAAF,aAAA,CACA,GAAAI,GAAA1vB,KAAA6nB,gBACA2H,EAAAH,eACAK,EAAAvI,cACAuI,EAAApzB,OAAAozB,EAAAhJ,gBACA1mB,KAAA6pB,MAAA6F,EAAAhJ,iBAOA3C,EAAAhiB,UAAA8nB,MAAA,SAAA5rB,GACA,GAAAuxB,GAAAxvB,KAAAyvB,eAEAvH,GAAAS,OAAA6G,EAAAD,cAAAC,EAAAjD,SAAAiD,EAAAF,aAMAE,EAAAH,eAAA,GALAG,EAAAF,cAAA,EACAtvB,KAAA8vB,WAAAN,EAAAD,WAAAC,EAAAO,cAAAP,EAAAJ,mBlC4/MM,SAAS3zB,EAAQD,EAASH,GmC/oNhC,QAAA2oB,GAAAnnB,GACA,MAAAmD,gBAAAgkB,OAGAD,GAAAnoB,KAAAoE,KAAAnD,GAFA,GAAAmnB,GAAAnnB,GAbApB,EAAAD,QAAAwoB,CAEA,IAAAD,GAAA1oB,EAAA,IAGA6sB,EAAA7sB,EAAA,GACA6sB,GAAAvE,SAAAtoB,EAAA,IAGA6sB,EAAAvE,SAAAK,EAAAD,GASAC,EAAAjiB,UAAA+tB,WAAA,SAAA1L,EAAAxa,EAAA9M,GACAA,EAAA,KAAAsnB,KnC2rNM,SAAS3oB,EAAQD,EAASH,GoCvuNhCI,EAAAD,QAAAH,EAAA,KpC8uNM,SAASI,EAAQD,EAASH,GqC9uNhCI,EAAAD,QAAAH,EAAA,KrCqvNM,SAASI,EAAQD,EAASH,GsCrvNhCI,EAAAD,QAAAH,EAAA,KtC4vNM,SAASI,EAAQD,EAASH,GuC5vNhCI,EAAAD,QAAAH,EAAA,KvCmwNM,SAASI,EAAQD,EAASH,IAEH,SAASoI,GwCtvNtC,QAAAusB,GAAAC,GACA,eAAAC,KAAAD,GACA,SAAAhmB,WAAA,mEAIAgmB,KAAA7gB,QAAA,YAGA,IAAA+gB,GAAAF,EAAA1pB,QAAA,IACA,SAAA4pB,GAAA,GAAAA,EAAA,SAAAlmB,WAAA,sBAOA,QAJA7M,GAAA6yB,EAAAhB,UAAA,EAAAkB,GAAA3Y,MAAA,KAEAzK,GAAA,EACAqjB,EAAA,WACAh0B,EAAA,EAAiBA,EAAAgB,EAAAd,OAAiBF,IAClC,UAAAgB,EAAAhB,GACA2Q,GAAA,EACK,GAAA3P,EAAAhB,GAAAmK,QAAA,cACL6pB,EAAAhzB,EAAAhB,GAAA6yB,UAAA,GAKA,IAAA1xB,GAAA8yB,SAAAJ,EAAAhB,UAAAkB,EAAA,IAEAvmB,EAAAmD,EAAA,iBACA5J,EAAA,GAAAM,GAAAlG,EAAAqM,EAQA,OALAzG,GAAAgD,KAAA/I,EAAA,iBAGA+F,EAAAitB,UAEAjtB,EA/CA1H,EAAAD,QAAAw0B,IxCuzN8Bp0B,KAAKJ,EAASH,EAAoB,IAAIoI,SAI9D,SAAShI,EAAQD,EAASH,GyCh0NhC,YAEA,IAAMkD,GAAUlD,EAAQ,GAElBsB,EAAU,SAAC0F,EAAQiuB,EAAGC,GAI1B,IAAK,GAHCt0B,GAAMsC,EAAQ8D,GAAQiuB,EAAGC,IAC3BpjB,KAEKjQ,EAAI,EAAOqzB,EAAJrzB,EAAOA,IAAK,CAE1B,IAAK,GADDszB,MACKvzB,EAAI,EAAOqzB,EAAJrzB,EAAOA,IACrBuzB,EAAInvB,KAAKpF,EAAIsD,IAAItC,EAAGC,GAEtBiQ,GAAI9L,KAAKmvB,EAAI/vB,KAAK,KAEpB,MAAO0M,GAGT1R,GAAOD,QAAUmB","file":"asciizer.min.js","sourcesContent":["var asciizer =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tvar equalizeHistogram = __webpack_require__(2);\n\tvar assignCharacters = __webpack_require__(3);\n\tvar readSums = __webpack_require__(4);\n\tvar getRows = __webpack_require__(41);\n\t\n\t// options {src, x, y, chars}\n\tvar asciize = function asciize(options, cb) {\n\t  if (!options.src) throw \"Missing src\";\n\t  options.chars = options.chars || \" .-:*+=%#@\";\n\t\n\t  readSums(options.src, options.x, options.y, function (sum, meta) {\n\t    var equalizedData = equalizeHistogram([].concat(_toConsumableArray(sum.data)), meta.maxval, options.chars.length - 1);\n\t    var asciized = assignCharacters(equalizedData, options.chars);\n\t    var formatted = getRows(asciized, meta.sizeX, meta.sizeY);\n\t\n\t    cb(formatted);\n\t  });\n\t};\n\t\n\tmodule.exports = asciize;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tvar equalizeHistogram = function equalizeHistogram(src, inMax, outMax) {\n\t  var step = (inMax + 1) / (outMax + 1);\n\t\n\t  return src.map(function (n) {\n\t    return Math.floor(n / step);\n\t  });\n\t};\n\t\n\tmodule.exports = equalizeHistogram;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tvar assignCharacters = function assignCharacters(counts, chars) {\n\t  return counts.map(function (val) {\n\t    return Array.isArray(chars) ? chars[Math.floor(val)] : chars.charAt(Math.floor(val));\n\t  });\n\t};\n\t\n\tmodule.exports = assignCharacters;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\t// const getPixels = require('get-pixels')\n\t\n\tvar ndarray = __webpack_require__(5);\n\tvar getPixels = __webpack_require__(8);\n\t\n\tvar readSums = function readSums(img, sizeX, sizeY, cb) {\n\t  getPixels(img, function (err, pixels) {\n\t    var picX = pixels.shape[0];\n\t    var picY = pixels.shape[1];\n\t    var ratio = picX / picY;\n\t\n\t    sizeX = !sizeX && sizeY ? Math.floor(sizeY * ratio) : sizeX;\n\t    sizeY = !sizeY && sizeX ? Math.floor(sizeX / ratio) : sizeY;\n\t\n\t    var sum = ndarray(new Uint16Array(sizeX * sizeY), [sizeX, sizeY]);\n\t    var stepX = Math.floor(picX / sizeX);\n\t    var stepY = Math.floor(picY / sizeY);\n\t    var maxval = stepX * stepY * 255 * 3;\n\t\n\t    for (var y = 0; y < picY / stepY; y++) {\n\t      for (var x = 0; x < picX / stepX; x++) {\n\t        var count = 0;\n\t        for (var py = 0; py < stepY; py++) {\n\t          for (var px = 0; px < stepX; px++) {\n\t            var R = pixels.get(x * stepX + px, y * stepY + py, 0);\n\t            var G = pixels.get(x * stepX + px, y * stepY + py, 1);\n\t            var B = pixels.get(x * stepX + px, y * stepY + py, 2);\n\t            // const A = pixels.get(x * stepX + px, y * stepY + py, 3)\n\t            count += R + G + B;\n\t          }\n\t        }\n\t        sum.set(x, y, count);\n\t      }\n\t    }\n\t    cb(sum, { maxval: maxval, sizeX: sizeX, sizeY: sizeY });\n\t  });\n\t};\n\t\n\tmodule.exports = readSums;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar iota = __webpack_require__(6)\n\tvar isBuffer = __webpack_require__(7)\n\t\n\tvar hasTypedArrays  = ((typeof Float64Array) !== \"undefined\")\n\t\n\tfunction compare1st(a, b) {\n\t  return a[0] - b[0]\n\t}\n\t\n\tfunction order() {\n\t  var stride = this.stride\n\t  var terms = new Array(stride.length)\n\t  var i\n\t  for(i=0; i<terms.length; ++i) {\n\t    terms[i] = [Math.abs(stride[i]), i]\n\t  }\n\t  terms.sort(compare1st)\n\t  var result = new Array(terms.length)\n\t  for(i=0; i<result.length; ++i) {\n\t    result[i] = terms[i][1]\n\t  }\n\t  return result\n\t}\n\t\n\tfunction compileConstructor(dtype, dimension) {\n\t  var className = [\"View\", dimension, \"d\", dtype].join(\"\")\n\t  if(dimension < 0) {\n\t    className = \"View_Nil\" + dtype\n\t  }\n\t  var useGetters = (dtype === \"generic\")\n\t\n\t  if(dimension === -1) {\n\t    //Special case for trivial arrays\n\t    var code =\n\t      \"function \"+className+\"(a){this.data=a;};\\\n\tvar proto=\"+className+\".prototype;\\\n\tproto.dtype='\"+dtype+\"';\\\n\tproto.index=function(){return -1};\\\n\tproto.size=0;\\\n\tproto.dimension=-1;\\\n\tproto.shape=proto.stride=proto.order=[];\\\n\tproto.lo=proto.hi=proto.transpose=proto.step=\\\n\tfunction(){return new \"+className+\"(this.data);};\\\n\tproto.get=proto.set=function(){};\\\n\tproto.pick=function(){return null};\\\n\treturn function construct_\"+className+\"(a){return new \"+className+\"(a);}\"\n\t    var procedure = new Function(code)\n\t    return procedure()\n\t  } else if(dimension === 0) {\n\t    //Special case for 0d arrays\n\t    var code =\n\t      \"function \"+className+\"(a,d) {\\\n\tthis.data = a;\\\n\tthis.offset = d\\\n\t};\\\n\tvar proto=\"+className+\".prototype;\\\n\tproto.dtype='\"+dtype+\"';\\\n\tproto.index=function(){return this.offset};\\\n\tproto.dimension=0;\\\n\tproto.size=1;\\\n\tproto.shape=\\\n\tproto.stride=\\\n\tproto.order=[];\\\n\tproto.lo=\\\n\tproto.hi=\\\n\tproto.transpose=\\\n\tproto.step=function \"+className+\"_copy() {\\\n\treturn new \"+className+\"(this.data,this.offset)\\\n\t};\\\n\tproto.pick=function \"+className+\"_pick(){\\\n\treturn TrivialArray(this.data);\\\n\t};\\\n\tproto.valueOf=proto.get=function \"+className+\"_get(){\\\n\treturn \"+(useGetters ? \"this.data.get(this.offset)\" : \"this.data[this.offset]\")+\n\t\"};\\\n\tproto.set=function \"+className+\"_set(v){\\\n\treturn \"+(useGetters ? \"this.data.set(this.offset,v)\" : \"this.data[this.offset]=v\")+\"\\\n\t};\\\n\treturn function construct_\"+className+\"(a,b,c,d){return new \"+className+\"(a,d)}\"\n\t    var procedure = new Function(\"TrivialArray\", code)\n\t    return procedure(CACHED_CONSTRUCTORS[dtype][0])\n\t  }\n\t\n\t  var code = [\"'use strict'\"]\n\t\n\t  //Create constructor for view\n\t  var indices = iota(dimension)\n\t  var args = indices.map(function(i) { return \"i\"+i })\n\t  var index_str = \"this.offset+\" + indices.map(function(i) {\n\t        return \"this.stride[\" + i + \"]*i\" + i\n\t      }).join(\"+\")\n\t  var shapeArg = indices.map(function(i) {\n\t      return \"b\"+i\n\t    }).join(\",\")\n\t  var strideArg = indices.map(function(i) {\n\t      return \"c\"+i\n\t    }).join(\",\")\n\t  code.push(\n\t    \"function \"+className+\"(a,\" + shapeArg + \",\" + strideArg + \",d){this.data=a\",\n\t      \"this.shape=[\" + shapeArg + \"]\",\n\t      \"this.stride=[\" + strideArg + \"]\",\n\t      \"this.offset=d|0}\",\n\t    \"var proto=\"+className+\".prototype\",\n\t    \"proto.dtype='\"+dtype+\"'\",\n\t    \"proto.dimension=\"+dimension)\n\t\n\t  //view.size:\n\t  code.push(\"Object.defineProperty(proto,'size',{get:function \"+className+\"_size(){\\\n\treturn \"+indices.map(function(i) { return \"this.shape[\"+i+\"]\" }).join(\"*\"),\n\t\"}})\")\n\t\n\t  //view.order:\n\t  if(dimension === 1) {\n\t    code.push(\"proto.order=[0]\")\n\t  } else {\n\t    code.push(\"Object.defineProperty(proto,'order',{get:\")\n\t    if(dimension < 4) {\n\t      code.push(\"function \"+className+\"_order(){\")\n\t      if(dimension === 2) {\n\t        code.push(\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\")\n\t      } else if(dimension === 3) {\n\t        code.push(\n\t\"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\\\n\tif(s0>s1){\\\n\tif(s1>s2){\\\n\treturn [2,1,0];\\\n\t}else if(s0>s2){\\\n\treturn [1,2,0];\\\n\t}else{\\\n\treturn [1,0,2];\\\n\t}\\\n\t}else if(s0>s2){\\\n\treturn [2,0,1];\\\n\t}else if(s2>s1){\\\n\treturn [0,1,2];\\\n\t}else{\\\n\treturn [0,2,1];\\\n\t}}})\")\n\t      }\n\t    } else {\n\t      code.push(\"ORDER})\")\n\t    }\n\t  }\n\t\n\t  //view.set(i0, ..., v):\n\t  code.push(\n\t\"proto.set=function \"+className+\"_set(\"+args.join(\",\")+\",v){\")\n\t  if(useGetters) {\n\t    code.push(\"return this.data.set(\"+index_str+\",v)}\")\n\t  } else {\n\t    code.push(\"return this.data[\"+index_str+\"]=v}\")\n\t  }\n\t\n\t  //view.get(i0, ...):\n\t  code.push(\"proto.get=function \"+className+\"_get(\"+args.join(\",\")+\"){\")\n\t  if(useGetters) {\n\t    code.push(\"return this.data.get(\"+index_str+\")}\")\n\t  } else {\n\t    code.push(\"return this.data[\"+index_str+\"]}\")\n\t  }\n\t\n\t  //view.index:\n\t  code.push(\n\t    \"proto.index=function \"+className+\"_index(\", args.join(), \"){return \"+index_str+\"}\")\n\t\n\t  //view.hi():\n\t  code.push(\"proto.hi=function \"+className+\"_hi(\"+args.join(\",\")+\"){return new \"+className+\"(this.data,\"+\n\t    indices.map(function(i) {\n\t      return [\"(typeof i\",i,\"!=='number'||i\",i,\"<0)?this.shape[\", i, \"]:i\", i,\"|0\"].join(\"\")\n\t    }).join(\",\")+\",\"+\n\t    indices.map(function(i) {\n\t      return \"this.stride[\"+i + \"]\"\n\t    }).join(\",\")+\",this.offset)}\")\n\t\n\t  //view.lo():\n\t  var a_vars = indices.map(function(i) { return \"a\"+i+\"=this.shape[\"+i+\"]\" })\n\t  var c_vars = indices.map(function(i) { return \"c\"+i+\"=this.stride[\"+i+\"]\" })\n\t  code.push(\"proto.lo=function \"+className+\"_lo(\"+args.join(\",\")+\"){var b=this.offset,d=0,\"+a_vars.join(\",\")+\",\"+c_vars.join(\",\"))\n\t  for(var i=0; i<dimension; ++i) {\n\t    code.push(\n\t\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){\\\n\td=i\"+i+\"|0;\\\n\tb+=c\"+i+\"*d;\\\n\ta\"+i+\"-=d}\")\n\t  }\n\t  code.push(\"return new \"+className+\"(this.data,\"+\n\t    indices.map(function(i) {\n\t      return \"a\"+i\n\t    }).join(\",\")+\",\"+\n\t    indices.map(function(i) {\n\t      return \"c\"+i\n\t    }).join(\",\")+\",b)}\")\n\t\n\t  //view.step():\n\t  code.push(\"proto.step=function \"+className+\"_step(\"+args.join(\",\")+\"){var \"+\n\t    indices.map(function(i) {\n\t      return \"a\"+i+\"=this.shape[\"+i+\"]\"\n\t    }).join(\",\")+\",\"+\n\t    indices.map(function(i) {\n\t      return \"b\"+i+\"=this.stride[\"+i+\"]\"\n\t    }).join(\",\")+\",c=this.offset,d=0,ceil=Math.ceil\")\n\t  for(var i=0; i<dimension; ++i) {\n\t    code.push(\n\t\"if(typeof i\"+i+\"==='number'){\\\n\td=i\"+i+\"|0;\\\n\tif(d<0){\\\n\tc+=b\"+i+\"*(a\"+i+\"-1);\\\n\ta\"+i+\"=ceil(-a\"+i+\"/d)\\\n\t}else{\\\n\ta\"+i+\"=ceil(a\"+i+\"/d)\\\n\t}\\\n\tb\"+i+\"*=d\\\n\t}\")\n\t  }\n\t  code.push(\"return new \"+className+\"(this.data,\"+\n\t    indices.map(function(i) {\n\t      return \"a\" + i\n\t    }).join(\",\")+\",\"+\n\t    indices.map(function(i) {\n\t      return \"b\" + i\n\t    }).join(\",\")+\",c)}\")\n\t\n\t  //view.transpose():\n\t  var tShape = new Array(dimension)\n\t  var tStride = new Array(dimension)\n\t  for(var i=0; i<dimension; ++i) {\n\t    tShape[i] = \"a[i\"+i+\"]\"\n\t    tStride[i] = \"b[i\"+i+\"]\"\n\t  }\n\t  code.push(\"proto.transpose=function \"+className+\"_transpose(\"+args+\"){\"+\n\t    args.map(function(n,idx) { return n + \"=(\" + n + \"===undefined?\" + idx + \":\" + n + \"|0)\"}).join(\";\"),\n\t    \"var a=this.shape,b=this.stride;return new \"+className+\"(this.data,\"+tShape.join(\",\")+\",\"+tStride.join(\",\")+\",this.offset)}\")\n\t\n\t  //view.pick():\n\t  code.push(\"proto.pick=function \"+className+\"_pick(\"+args+\"){var a=[],b=[],c=this.offset\")\n\t  for(var i=0; i<dimension; ++i) {\n\t    code.push(\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){c=(c+this.stride[\"+i+\"]*i\"+i+\")|0}else{a.push(this.shape[\"+i+\"]);b.push(this.stride[\"+i+\"])}\")\n\t  }\n\t  code.push(\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\")\n\t\n\t  //Add return statement\n\t  code.push(\"return function construct_\"+className+\"(data,shape,stride,offset){return new \"+className+\"(data,\"+\n\t    indices.map(function(i) {\n\t      return \"shape[\"+i+\"]\"\n\t    }).join(\",\")+\",\"+\n\t    indices.map(function(i) {\n\t      return \"stride[\"+i+\"]\"\n\t    }).join(\",\")+\",offset)}\")\n\t\n\t  //Compile procedure\n\t  var procedure = new Function(\"CTOR_LIST\", \"ORDER\", code.join(\"\\n\"))\n\t  return procedure(CACHED_CONSTRUCTORS[dtype], order)\n\t}\n\t\n\tfunction arrayDType(data) {\n\t  if(isBuffer(data)) {\n\t    return \"buffer\"\n\t  }\n\t  if(hasTypedArrays) {\n\t    switch(Object.prototype.toString.call(data)) {\n\t      case \"[object Float64Array]\":\n\t        return \"float64\"\n\t      case \"[object Float32Array]\":\n\t        return \"float32\"\n\t      case \"[object Int8Array]\":\n\t        return \"int8\"\n\t      case \"[object Int16Array]\":\n\t        return \"int16\"\n\t      case \"[object Int32Array]\":\n\t        return \"int32\"\n\t      case \"[object Uint8Array]\":\n\t        return \"uint8\"\n\t      case \"[object Uint16Array]\":\n\t        return \"uint16\"\n\t      case \"[object Uint32Array]\":\n\t        return \"uint32\"\n\t      case \"[object Uint8ClampedArray]\":\n\t        return \"uint8_clamped\"\n\t    }\n\t  }\n\t  if(Array.isArray(data)) {\n\t    return \"array\"\n\t  }\n\t  return \"generic\"\n\t}\n\t\n\tvar CACHED_CONSTRUCTORS = {\n\t  \"float32\":[],\n\t  \"float64\":[],\n\t  \"int8\":[],\n\t  \"int16\":[],\n\t  \"int32\":[],\n\t  \"uint8\":[],\n\t  \"uint16\":[],\n\t  \"uint32\":[],\n\t  \"array\":[],\n\t  \"uint8_clamped\":[],\n\t  \"buffer\":[],\n\t  \"generic\":[]\n\t}\n\t\n\t;(function() {\n\t  for(var id in CACHED_CONSTRUCTORS) {\n\t    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))\n\t  }\n\t});\n\t\n\tfunction wrappedNDArrayCtor(data, shape, stride, offset) {\n\t  if(data === undefined) {\n\t    var ctor = CACHED_CONSTRUCTORS.array[0]\n\t    return ctor([])\n\t  } else if(typeof data === \"number\") {\n\t    data = [data]\n\t  }\n\t  if(shape === undefined) {\n\t    shape = [ data.length ]\n\t  }\n\t  var d = shape.length\n\t  if(stride === undefined) {\n\t    stride = new Array(d)\n\t    for(var i=d-1, sz=1; i>=0; --i) {\n\t      stride[i] = sz\n\t      sz *= shape[i]\n\t    }\n\t  }\n\t  if(offset === undefined) {\n\t    offset = 0\n\t    for(var i=0; i<d; ++i) {\n\t      if(stride[i] < 0) {\n\t        offset -= (shape[i]-1)*stride[i]\n\t      }\n\t    }\n\t  }\n\t  var dtype = arrayDType(data)\n\t  var ctor_list = CACHED_CONSTRUCTORS[dtype]\n\t  while(ctor_list.length <= d+1) {\n\t    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))\n\t  }\n\t  var ctor = ctor_list[d+1]\n\t  return ctor(data, shape, stride, offset)\n\t}\n\t\n\tmodule.exports = wrappedNDArrayCtor\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t\"use strict\"\n\t\n\tfunction iota(n) {\n\t  var result = new Array(n)\n\t  for(var i=0; i<n; ++i) {\n\t    result[i] = i\n\t  }\n\t  return result\n\t}\n\t\n\tmodule.exports = iota\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Determine if an object is Buffer\n\t *\n\t * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n\t * License:  MIT\n\t *\n\t * `npm install is-buffer`\n\t */\n\t\n\tmodule.exports = function (obj) {\n\t  return !!(obj != null &&\n\t    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)\n\t      (obj.constructor &&\n\t      typeof obj.constructor.isBuffer === 'function' &&\n\t      obj.constructor.isBuffer(obj))\n\t    ))\n\t}\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process, Buffer) {// https://github.com/scijs/get-pixels/blob/master/dom-pixels.js\n\t'use strict';\n\t\n\tvar path = __webpack_require__(14);\n\tvar ndarray = __webpack_require__(5);\n\tvar GifReader = __webpack_require__(15).GifReader;\n\tvar pack = __webpack_require__(16);\n\tvar through = __webpack_require__(22);\n\tvar parseDataURI = __webpack_require__(40);\n\t\n\tfunction defaultImage(url, cb) {\n\t  var img = new Image();\n\t  img.crossOrigin = \"Anonymous\";\n\t  img.onload = function () {\n\t    var canvas = document.createElement('canvas');\n\t    canvas.width = img.width;\n\t    canvas.height = img.height;\n\t    var context = canvas.getContext('2d');\n\t    context.drawImage(img, 0, 0);\n\t    var pixels = context.getImageData(0, 0, img.width, img.height);\n\t    cb(null, ndarray(new Uint8Array(pixels.data), [img.width, img.height, 4], [4, 4 * img.width, 1], 0));\n\t  };\n\t  img.onerror = function (err) {\n\t    cb(err);\n\t  };\n\t  img.src = url;\n\t}\n\t\n\t//Animated gif loading\n\tfunction handleGif(data, cb) {\n\t  var reader;\n\t  try {\n\t    reader = new GifReader(data);\n\t  } catch (err) {\n\t    cb(err);\n\t    return;\n\t  }\n\t  if (reader.numFrames() > 0) {\n\t    var nshape = [reader.numFrames(), reader.height, reader.width, 4];\n\t    var ndata = new Uint8Array(nshape[0] * nshape[1] * nshape[2] * nshape[3]);\n\t    var result = ndarray(ndata, nshape);\n\t    try {\n\t      for (var i = 0; i < reader.numFrames(); ++i) {\n\t        reader.decodeAndBlitFrameRGBA(i, ndata.subarray(result.index(i, 0, 0, 0), result.index(i + 1, 0, 0, 0)));\n\t      }\n\t    } catch (err) {\n\t      cb(err);\n\t      return;\n\t    }\n\t    cb(null, result.transpose(0, 2, 1));\n\t  } else {\n\t    var nshape = [reader.height, reader.width, 4];\n\t    var ndata = new Uint8Array(nshape[0] * nshape[1] * nshape[2]);\n\t    var result = ndarray(ndata, nshape);\n\t    try {\n\t      reader.decodeAndBlitFrameRGBA(0, ndata);\n\t    } catch (err) {\n\t      cb(err);\n\t      return;\n\t    }\n\t    cb(null, result.transpose(1, 0));\n\t  }\n\t}\n\t\n\tfunction httpGif(url, cb) {\n\t  var xhr = new XMLHttpRequest();\n\t  xhr.open('GET', url, true);\n\t  xhr.responseType = 'arraybuffer';\n\t  if (xhr.overrideMimeType) {\n\t    xhr.overrideMimeType('application/binary');\n\t  }\n\t  xhr.onerror = function (err) {\n\t    cb(err);\n\t  };\n\t  xhr.onload = function () {\n\t    if (xhr.readyState !== 4) {\n\t      return;\n\t    }\n\t    var data = new Uint8Array(xhr.response);\n\t    handleGif(data, cb);\n\t    return;\n\t  };\n\t  xhr.send();\n\t}\n\t\n\tfunction copyBuffer(buffer) {\n\t  if (buffer[0] === undefined) {\n\t    var n = buffer.length;\n\t    var result = new Uint8Array(n);\n\t    for (var i = 0; i < n; ++i) {\n\t      result[i] = buffer.get(i);\n\t    }\n\t    return result;\n\t  } else {\n\t    return new Uint8Array(buffer);\n\t  }\n\t}\n\t\n\tfunction dataGif(url, cb) {\n\t  process.nextTick(function () {\n\t    try {\n\t      var buffer = parseDataURI(url);\n\t      if (buffer) {\n\t        handleGif(copyBuffer(buffer), cb);\n\t      } else {\n\t        cb(new Error('Error parsing data URI'));\n\t      }\n\t    } catch (err) {\n\t      cb(err);\n\t    }\n\t  });\n\t}\n\t\n\tmodule.exports = function getPixels(url, type, cb) {\n\t  if (!cb) {\n\t    cb = type;\n\t    type = '';\n\t  }\n\t  var ext = path.extname(url);\n\t  switch (type || ext.toUpperCase()) {\n\t    case '.GIF':\n\t      httpGif(url, cb);\n\t      break;\n\t    default:\n\t      if (Buffer.isBuffer(url)) {\n\t        url = 'data:' + type + ';base64,' + url.toString('base64');\n\t      }\n\t      if (url.indexOf('data:image/gif;') === 0) {\n\t        dataGif(url, cb);\n\t      } else {\n\t        defaultImage(url, cb);\n\t      }\n\t  }\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9), __webpack_require__(10).Buffer))\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = setTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    clearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        setTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!\n\t * The buffer module from node.js, for the browser.\n\t *\n\t * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n\t * @license  MIT\n\t */\n\t/* eslint-disable no-proto */\n\t\n\tvar base64 = __webpack_require__(11)\n\tvar ieee754 = __webpack_require__(12)\n\tvar isArray = __webpack_require__(13)\n\t\n\texports.Buffer = Buffer\n\texports.SlowBuffer = SlowBuffer\n\texports.INSPECT_MAX_BYTES = 50\n\tBuffer.poolSize = 8192 // not used by this implementation\n\t\n\tvar rootParent = {}\n\t\n\t/**\n\t * If `Buffer.TYPED_ARRAY_SUPPORT`:\n\t *   === true    Use Uint8Array implementation (fastest)\n\t *   === false   Use Object implementation (most compatible, even IE6)\n\t *\n\t * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n\t * Opera 11.6+, iOS 4.2+.\n\t *\n\t * Due to various browser bugs, sometimes the Object implementation will be used even\n\t * when the browser supports typed arrays.\n\t *\n\t * Note:\n\t *\n\t *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n\t *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n\t *\n\t *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property\n\t *     on objects.\n\t *\n\t *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n\t *\n\t *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n\t *     incorrect length in some situations.\n\t\n\t * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n\t * get the Object implementation, which is slower but behaves correctly.\n\t */\n\tBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n\t  ? global.TYPED_ARRAY_SUPPORT\n\t  : typedArraySupport()\n\t\n\tfunction typedArraySupport () {\n\t  function Bar () {}\n\t  try {\n\t    var arr = new Uint8Array(1)\n\t    arr.foo = function () { return 42 }\n\t    arr.constructor = Bar\n\t    return arr.foo() === 42 && // typed array instances can be augmented\n\t        arr.constructor === Bar && // constructor can be set\n\t        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n\t        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n\t  } catch (e) {\n\t    return false\n\t  }\n\t}\n\t\n\tfunction kMaxLength () {\n\t  return Buffer.TYPED_ARRAY_SUPPORT\n\t    ? 0x7fffffff\n\t    : 0x3fffffff\n\t}\n\t\n\t/**\n\t * Class: Buffer\n\t * =============\n\t *\n\t * The Buffer constructor returns instances of `Uint8Array` that are augmented\n\t * with function properties for all the node `Buffer` API functions. We use\n\t * `Uint8Array` so that square bracket notation works as expected -- it returns\n\t * a single octet.\n\t *\n\t * By augmenting the instances, we can avoid modifying the `Uint8Array`\n\t * prototype.\n\t */\n\tfunction Buffer (arg) {\n\t  if (!(this instanceof Buffer)) {\n\t    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n\t    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n\t    return new Buffer(arg)\n\t  }\n\t\n\t  this.length = 0\n\t  this.parent = undefined\n\t\n\t  // Common case.\n\t  if (typeof arg === 'number') {\n\t    return fromNumber(this, arg)\n\t  }\n\t\n\t  // Slightly less common case.\n\t  if (typeof arg === 'string') {\n\t    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n\t  }\n\t\n\t  // Unusual.\n\t  return fromObject(this, arg)\n\t}\n\t\n\tfunction fromNumber (that, length) {\n\t  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n\t    for (var i = 0; i < length; i++) {\n\t      that[i] = 0\n\t    }\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromString (that, string, encoding) {\n\t  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\t\n\t  // Assumption: byteLength() return value is always < kMaxLength.\n\t  var length = byteLength(string, encoding) | 0\n\t  that = allocate(that, length)\n\t\n\t  that.write(string, encoding)\n\t  return that\n\t}\n\t\n\tfunction fromObject (that, object) {\n\t  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\t\n\t  if (isArray(object)) return fromArray(that, object)\n\t\n\t  if (object == null) {\n\t    throw new TypeError('must start with number, buffer, array or string')\n\t  }\n\t\n\t  if (typeof ArrayBuffer !== 'undefined') {\n\t    if (object.buffer instanceof ArrayBuffer) {\n\t      return fromTypedArray(that, object)\n\t    }\n\t    if (object instanceof ArrayBuffer) {\n\t      return fromArrayBuffer(that, object)\n\t    }\n\t  }\n\t\n\t  if (object.length) return fromArrayLike(that, object)\n\t\n\t  return fromJsonObject(that, object)\n\t}\n\t\n\tfunction fromBuffer (that, buffer) {\n\t  var length = checked(buffer.length) | 0\n\t  that = allocate(that, length)\n\t  buffer.copy(that, 0, 0, length)\n\t  return that\n\t}\n\t\n\tfunction fromArray (that, array) {\n\t  var length = checked(array.length) | 0\n\t  that = allocate(that, length)\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\t\n\t// Duplicate of fromArray() to keep fromArray() monomorphic.\n\tfunction fromTypedArray (that, array) {\n\t  var length = checked(array.length) | 0\n\t  that = allocate(that, length)\n\t  // Truncating the elements is probably not what people expect from typed\n\t  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n\t  // of the old Buffer constructor.\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromArrayBuffer (that, array) {\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    array.byteLength\n\t    that = Buffer._augment(new Uint8Array(array))\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    that = fromTypedArray(that, new Uint8Array(array))\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromArrayLike (that, array) {\n\t  var length = checked(array.length) | 0\n\t  that = allocate(that, length)\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\t\n\t// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n\t// Returns a zero-length buffer for inputs that don't conform to the spec.\n\tfunction fromJsonObject (that, object) {\n\t  var array\n\t  var length = 0\n\t\n\t  if (object.type === 'Buffer' && isArray(object.data)) {\n\t    array = object.data\n\t    length = checked(array.length) | 0\n\t  }\n\t  that = allocate(that, length)\n\t\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\t\n\tif (Buffer.TYPED_ARRAY_SUPPORT) {\n\t  Buffer.prototype.__proto__ = Uint8Array.prototype\n\t  Buffer.__proto__ = Uint8Array\n\t}\n\t\n\tfunction allocate (that, length) {\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    that = Buffer._augment(new Uint8Array(length))\n\t    that.__proto__ = Buffer.prototype\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    that.length = length\n\t    that._isBuffer = true\n\t  }\n\t\n\t  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n\t  if (fromPool) that.parent = rootParent\n\t\n\t  return that\n\t}\n\t\n\tfunction checked (length) {\n\t  // Note: cannot use `length < kMaxLength` here because that fails when\n\t  // length is NaN (which is otherwise coerced to zero.)\n\t  if (length >= kMaxLength()) {\n\t    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n\t                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n\t  }\n\t  return length | 0\n\t}\n\t\n\tfunction SlowBuffer (subject, encoding) {\n\t  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\t\n\t  var buf = new Buffer(subject, encoding)\n\t  delete buf.parent\n\t  return buf\n\t}\n\t\n\tBuffer.isBuffer = function isBuffer (b) {\n\t  return !!(b != null && b._isBuffer)\n\t}\n\t\n\tBuffer.compare = function compare (a, b) {\n\t  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n\t    throw new TypeError('Arguments must be Buffers')\n\t  }\n\t\n\t  if (a === b) return 0\n\t\n\t  var x = a.length\n\t  var y = b.length\n\t\n\t  var i = 0\n\t  var len = Math.min(x, y)\n\t  while (i < len) {\n\t    if (a[i] !== b[i]) break\n\t\n\t    ++i\n\t  }\n\t\n\t  if (i !== len) {\n\t    x = a[i]\n\t    y = b[i]\n\t  }\n\t\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t}\n\t\n\tBuffer.isEncoding = function isEncoding (encoding) {\n\t  switch (String(encoding).toLowerCase()) {\n\t    case 'hex':\n\t    case 'utf8':\n\t    case 'utf-8':\n\t    case 'ascii':\n\t    case 'binary':\n\t    case 'base64':\n\t    case 'raw':\n\t    case 'ucs2':\n\t    case 'ucs-2':\n\t    case 'utf16le':\n\t    case 'utf-16le':\n\t      return true\n\t    default:\n\t      return false\n\t  }\n\t}\n\t\n\tBuffer.concat = function concat (list, length) {\n\t  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\t\n\t  if (list.length === 0) {\n\t    return new Buffer(0)\n\t  }\n\t\n\t  var i\n\t  if (length === undefined) {\n\t    length = 0\n\t    for (i = 0; i < list.length; i++) {\n\t      length += list[i].length\n\t    }\n\t  }\n\t\n\t  var buf = new Buffer(length)\n\t  var pos = 0\n\t  for (i = 0; i < list.length; i++) {\n\t    var item = list[i]\n\t    item.copy(buf, pos)\n\t    pos += item.length\n\t  }\n\t  return buf\n\t}\n\t\n\tfunction byteLength (string, encoding) {\n\t  if (typeof string !== 'string') string = '' + string\n\t\n\t  var len = string.length\n\t  if (len === 0) return 0\n\t\n\t  // Use a for loop to avoid recursion\n\t  var loweredCase = false\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'ascii':\n\t      case 'binary':\n\t      // Deprecated\n\t      case 'raw':\n\t      case 'raws':\n\t        return len\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8ToBytes(string).length\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return len * 2\n\t      case 'hex':\n\t        return len >>> 1\n\t      case 'base64':\n\t        return base64ToBytes(string).length\n\t      default:\n\t        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n\t        encoding = ('' + encoding).toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\tBuffer.byteLength = byteLength\n\t\n\t// pre-set for values that may exist in the future\n\tBuffer.prototype.length = undefined\n\tBuffer.prototype.parent = undefined\n\t\n\tfunction slowToString (encoding, start, end) {\n\t  var loweredCase = false\n\t\n\t  start = start | 0\n\t  end = end === undefined || end === Infinity ? this.length : end | 0\n\t\n\t  if (!encoding) encoding = 'utf8'\n\t  if (start < 0) start = 0\n\t  if (end > this.length) end = this.length\n\t  if (end <= start) return ''\n\t\n\t  while (true) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexSlice(this, start, end)\n\t\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Slice(this, start, end)\n\t\n\t      case 'ascii':\n\t        return asciiSlice(this, start, end)\n\t\n\t      case 'binary':\n\t        return binarySlice(this, start, end)\n\t\n\t      case 'base64':\n\t        return base64Slice(this, start, end)\n\t\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return utf16leSlice(this, start, end)\n\t\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = (encoding + '').toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\t\n\tBuffer.prototype.toString = function toString () {\n\t  var length = this.length | 0\n\t  if (length === 0) return ''\n\t  if (arguments.length === 0) return utf8Slice(this, 0, length)\n\t  return slowToString.apply(this, arguments)\n\t}\n\t\n\tBuffer.prototype.equals = function equals (b) {\n\t  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n\t  if (this === b) return true\n\t  return Buffer.compare(this, b) === 0\n\t}\n\t\n\tBuffer.prototype.inspect = function inspect () {\n\t  var str = ''\n\t  var max = exports.INSPECT_MAX_BYTES\n\t  if (this.length > 0) {\n\t    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n\t    if (this.length > max) str += ' ... '\n\t  }\n\t  return '<Buffer ' + str + '>'\n\t}\n\t\n\tBuffer.prototype.compare = function compare (b) {\n\t  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n\t  if (this === b) return 0\n\t  return Buffer.compare(this, b)\n\t}\n\t\n\tBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n\t  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n\t  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n\t  byteOffset >>= 0\n\t\n\t  if (this.length === 0) return -1\n\t  if (byteOffset >= this.length) return -1\n\t\n\t  // Negative offsets start from the end of the buffer\n\t  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\t\n\t  if (typeof val === 'string') {\n\t    if (val.length === 0) return -1 // special case: looking for empty string always fails\n\t    return String.prototype.indexOf.call(this, val, byteOffset)\n\t  }\n\t  if (Buffer.isBuffer(val)) {\n\t    return arrayIndexOf(this, val, byteOffset)\n\t  }\n\t  if (typeof val === 'number') {\n\t    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n\t      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n\t    }\n\t    return arrayIndexOf(this, [ val ], byteOffset)\n\t  }\n\t\n\t  function arrayIndexOf (arr, val, byteOffset) {\n\t    var foundIndex = -1\n\t    for (var i = 0; byteOffset + i < arr.length; i++) {\n\t      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n\t        if (foundIndex === -1) foundIndex = i\n\t        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n\t      } else {\n\t        foundIndex = -1\n\t      }\n\t    }\n\t    return -1\n\t  }\n\t\n\t  throw new TypeError('val must be string, number or Buffer')\n\t}\n\t\n\t// `get` is deprecated\n\tBuffer.prototype.get = function get (offset) {\n\t  console.log('.get() is deprecated. Access using array indexes instead.')\n\t  return this.readUInt8(offset)\n\t}\n\t\n\t// `set` is deprecated\n\tBuffer.prototype.set = function set (v, offset) {\n\t  console.log('.set() is deprecated. Access using array indexes instead.')\n\t  return this.writeUInt8(v, offset)\n\t}\n\t\n\tfunction hexWrite (buf, string, offset, length) {\n\t  offset = Number(offset) || 0\n\t  var remaining = buf.length - offset\n\t  if (!length) {\n\t    length = remaining\n\t  } else {\n\t    length = Number(length)\n\t    if (length > remaining) {\n\t      length = remaining\n\t    }\n\t  }\n\t\n\t  // must be an even number of digits\n\t  var strLen = string.length\n\t  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\t\n\t  if (length > strLen / 2) {\n\t    length = strLen / 2\n\t  }\n\t  for (var i = 0; i < length; i++) {\n\t    var parsed = parseInt(string.substr(i * 2, 2), 16)\n\t    if (isNaN(parsed)) throw new Error('Invalid hex string')\n\t    buf[offset + i] = parsed\n\t  }\n\t  return i\n\t}\n\t\n\tfunction utf8Write (buf, string, offset, length) {\n\t  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\t\n\tfunction asciiWrite (buf, string, offset, length) {\n\t  return blitBuffer(asciiToBytes(string), buf, offset, length)\n\t}\n\t\n\tfunction binaryWrite (buf, string, offset, length) {\n\t  return asciiWrite(buf, string, offset, length)\n\t}\n\t\n\tfunction base64Write (buf, string, offset, length) {\n\t  return blitBuffer(base64ToBytes(string), buf, offset, length)\n\t}\n\t\n\tfunction ucs2Write (buf, string, offset, length) {\n\t  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\t\n\tBuffer.prototype.write = function write (string, offset, length, encoding) {\n\t  // Buffer#write(string)\n\t  if (offset === undefined) {\n\t    encoding = 'utf8'\n\t    length = this.length\n\t    offset = 0\n\t  // Buffer#write(string, encoding)\n\t  } else if (length === undefined && typeof offset === 'string') {\n\t    encoding = offset\n\t    length = this.length\n\t    offset = 0\n\t  // Buffer#write(string, offset[, length][, encoding])\n\t  } else if (isFinite(offset)) {\n\t    offset = offset | 0\n\t    if (isFinite(length)) {\n\t      length = length | 0\n\t      if (encoding === undefined) encoding = 'utf8'\n\t    } else {\n\t      encoding = length\n\t      length = undefined\n\t    }\n\t  // legacy write(string, encoding, offset, length) - remove in v0.13\n\t  } else {\n\t    var swap = encoding\n\t    encoding = offset\n\t    offset = length | 0\n\t    length = swap\n\t  }\n\t\n\t  var remaining = this.length - offset\n\t  if (length === undefined || length > remaining) length = remaining\n\t\n\t  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n\t    throw new RangeError('attempt to write outside buffer bounds')\n\t  }\n\t\n\t  if (!encoding) encoding = 'utf8'\n\t\n\t  var loweredCase = false\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexWrite(this, string, offset, length)\n\t\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Write(this, string, offset, length)\n\t\n\t      case 'ascii':\n\t        return asciiWrite(this, string, offset, length)\n\t\n\t      case 'binary':\n\t        return binaryWrite(this, string, offset, length)\n\t\n\t      case 'base64':\n\t        // Warning: maxLength not taken into account in base64Write\n\t        return base64Write(this, string, offset, length)\n\t\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return ucs2Write(this, string, offset, length)\n\t\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = ('' + encoding).toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\t\n\tBuffer.prototype.toJSON = function toJSON () {\n\t  return {\n\t    type: 'Buffer',\n\t    data: Array.prototype.slice.call(this._arr || this, 0)\n\t  }\n\t}\n\t\n\tfunction base64Slice (buf, start, end) {\n\t  if (start === 0 && end === buf.length) {\n\t    return base64.fromByteArray(buf)\n\t  } else {\n\t    return base64.fromByteArray(buf.slice(start, end))\n\t  }\n\t}\n\t\n\tfunction utf8Slice (buf, start, end) {\n\t  end = Math.min(buf.length, end)\n\t  var res = []\n\t\n\t  var i = start\n\t  while (i < end) {\n\t    var firstByte = buf[i]\n\t    var codePoint = null\n\t    var bytesPerSequence = (firstByte > 0xEF) ? 4\n\t      : (firstByte > 0xDF) ? 3\n\t      : (firstByte > 0xBF) ? 2\n\t      : 1\n\t\n\t    if (i + bytesPerSequence <= end) {\n\t      var secondByte, thirdByte, fourthByte, tempCodePoint\n\t\n\t      switch (bytesPerSequence) {\n\t        case 1:\n\t          if (firstByte < 0x80) {\n\t            codePoint = firstByte\n\t          }\n\t          break\n\t        case 2:\n\t          secondByte = buf[i + 1]\n\t          if ((secondByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n\t            if (tempCodePoint > 0x7F) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t          break\n\t        case 3:\n\t          secondByte = buf[i + 1]\n\t          thirdByte = buf[i + 2]\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n\t            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t          break\n\t        case 4:\n\t          secondByte = buf[i + 1]\n\t          thirdByte = buf[i + 2]\n\t          fourthByte = buf[i + 3]\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n\t            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t      }\n\t    }\n\t\n\t    if (codePoint === null) {\n\t      // we did not generate a valid codePoint so insert a\n\t      // replacement char (U+FFFD) and advance only 1 byte\n\t      codePoint = 0xFFFD\n\t      bytesPerSequence = 1\n\t    } else if (codePoint > 0xFFFF) {\n\t      // encode to utf16 (surrogate pair dance)\n\t      codePoint -= 0x10000\n\t      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n\t      codePoint = 0xDC00 | codePoint & 0x3FF\n\t    }\n\t\n\t    res.push(codePoint)\n\t    i += bytesPerSequence\n\t  }\n\t\n\t  return decodeCodePointsArray(res)\n\t}\n\t\n\t// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n\t// the lowest limit is Chrome, with 0x10000 args.\n\t// We go 1 magnitude less, for safety\n\tvar MAX_ARGUMENTS_LENGTH = 0x1000\n\t\n\tfunction decodeCodePointsArray (codePoints) {\n\t  var len = codePoints.length\n\t  if (len <= MAX_ARGUMENTS_LENGTH) {\n\t    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n\t  }\n\t\n\t  // Decode in chunks to avoid \"call stack size exceeded\".\n\t  var res = ''\n\t  var i = 0\n\t  while (i < len) {\n\t    res += String.fromCharCode.apply(\n\t      String,\n\t      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n\t    )\n\t  }\n\t  return res\n\t}\n\t\n\tfunction asciiSlice (buf, start, end) {\n\t  var ret = ''\n\t  end = Math.min(buf.length, end)\n\t\n\t  for (var i = start; i < end; i++) {\n\t    ret += String.fromCharCode(buf[i] & 0x7F)\n\t  }\n\t  return ret\n\t}\n\t\n\tfunction binarySlice (buf, start, end) {\n\t  var ret = ''\n\t  end = Math.min(buf.length, end)\n\t\n\t  for (var i = start; i < end; i++) {\n\t    ret += String.fromCharCode(buf[i])\n\t  }\n\t  return ret\n\t}\n\t\n\tfunction hexSlice (buf, start, end) {\n\t  var len = buf.length\n\t\n\t  if (!start || start < 0) start = 0\n\t  if (!end || end < 0 || end > len) end = len\n\t\n\t  var out = ''\n\t  for (var i = start; i < end; i++) {\n\t    out += toHex(buf[i])\n\t  }\n\t  return out\n\t}\n\t\n\tfunction utf16leSlice (buf, start, end) {\n\t  var bytes = buf.slice(start, end)\n\t  var res = ''\n\t  for (var i = 0; i < bytes.length; i += 2) {\n\t    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n\t  }\n\t  return res\n\t}\n\t\n\tBuffer.prototype.slice = function slice (start, end) {\n\t  var len = this.length\n\t  start = ~~start\n\t  end = end === undefined ? len : ~~end\n\t\n\t  if (start < 0) {\n\t    start += len\n\t    if (start < 0) start = 0\n\t  } else if (start > len) {\n\t    start = len\n\t  }\n\t\n\t  if (end < 0) {\n\t    end += len\n\t    if (end < 0) end = 0\n\t  } else if (end > len) {\n\t    end = len\n\t  }\n\t\n\t  if (end < start) end = start\n\t\n\t  var newBuf\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    newBuf = Buffer._augment(this.subarray(start, end))\n\t  } else {\n\t    var sliceLen = end - start\n\t    newBuf = new Buffer(sliceLen, undefined)\n\t    for (var i = 0; i < sliceLen; i++) {\n\t      newBuf[i] = this[i + start]\n\t    }\n\t  }\n\t\n\t  if (newBuf.length) newBuf.parent = this.parent || this\n\t\n\t  return newBuf\n\t}\n\t\n\t/*\n\t * Need to make sure that buffer isn't trying to write out of bounds.\n\t */\n\tfunction checkOffset (offset, ext, length) {\n\t  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n\t  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n\t}\n\t\n\tBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var val = this[offset]\n\t  var mul = 1\n\t  var i = 0\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul\n\t  }\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) {\n\t    checkOffset(offset, byteLength, this.length)\n\t  }\n\t\n\t  var val = this[offset + --byteLength]\n\t  var mul = 1\n\t  while (byteLength > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --byteLength] * mul\n\t  }\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length)\n\t  return this[offset]\n\t}\n\t\n\tBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  return this[offset] | (this[offset + 1] << 8)\n\t}\n\t\n\tBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  return (this[offset] << 8) | this[offset + 1]\n\t}\n\t\n\tBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return ((this[offset]) |\n\t      (this[offset + 1] << 8) |\n\t      (this[offset + 2] << 16)) +\n\t      (this[offset + 3] * 0x1000000)\n\t}\n\t\n\tBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset] * 0x1000000) +\n\t    ((this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    this[offset + 3])\n\t}\n\t\n\tBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var val = this[offset]\n\t  var mul = 1\n\t  var i = 0\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul\n\t  }\n\t  mul *= 0x80\n\t\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var i = byteLength\n\t  var mul = 1\n\t  var val = this[offset + --i]\n\t  while (i > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --i] * mul\n\t  }\n\t  mul *= 0x80\n\t\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length)\n\t  if (!(this[offset] & 0x80)) return (this[offset])\n\t  return ((0xff - this[offset] + 1) * -1)\n\t}\n\t\n\tBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  var val = this[offset] | (this[offset + 1] << 8)\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t}\n\t\n\tBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  var val = this[offset + 1] | (this[offset] << 8)\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t}\n\t\n\tBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset]) |\n\t    (this[offset + 1] << 8) |\n\t    (this[offset + 2] << 16) |\n\t    (this[offset + 3] << 24)\n\t}\n\t\n\tBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset] << 24) |\n\t    (this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    (this[offset + 3])\n\t}\n\t\n\tBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t  return ieee754.read(this, offset, true, 23, 4)\n\t}\n\t\n\tBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t  return ieee754.read(this, offset, false, 23, 4)\n\t}\n\t\n\tBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length)\n\t  return ieee754.read(this, offset, true, 52, 8)\n\t}\n\t\n\tBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length)\n\t  return ieee754.read(this, offset, false, 52, 8)\n\t}\n\t\n\tfunction checkInt (buf, value, offset, ext, max, min) {\n\t  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n\t  if (value > max || value < min) throw new RangeError('value is out of bounds')\n\t  if (offset + ext > buf.length) throw new RangeError('index out of range')\n\t}\n\t\n\tBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\t\n\t  var mul = 1\n\t  var i = 0\n\t  this[offset] = value & 0xFF\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\t\n\t  var i = byteLength - 1\n\t  var mul = 1\n\t  this[offset + i] = value & 0xFF\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t  this[offset] = (value & 0xff)\n\t  return offset + 1\n\t}\n\t\n\tfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffff + value + 1\n\t  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n\t    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n\t      (littleEndian ? i : 1 - i) * 8\n\t  }\n\t}\n\t\n\tBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8)\n\t    this[offset + 1] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffffffff + value + 1\n\t  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n\t    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n\t  }\n\t}\n\t\n\tBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset + 3] = (value >>> 24)\n\t    this[offset + 2] = (value >>> 16)\n\t    this[offset + 1] = (value >>> 8)\n\t    this[offset] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24)\n\t    this[offset + 1] = (value >>> 16)\n\t    this[offset + 2] = (value >>> 8)\n\t    this[offset + 3] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1)\n\t\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n\t  }\n\t\n\t  var i = 0\n\t  var mul = 1\n\t  var sub = value < 0 ? 1 : 0\n\t  this[offset] = value & 0xFF\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1)\n\t\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n\t  }\n\t\n\t  var i = byteLength - 1\n\t  var mul = 1\n\t  var sub = value < 0 ? 1 : 0\n\t  this[offset + i] = value & 0xFF\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t  if (value < 0) value = 0xff + value + 1\n\t  this[offset] = (value & 0xff)\n\t  return offset + 1\n\t}\n\t\n\tBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8)\n\t    this[offset + 1] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t    this[offset + 2] = (value >>> 16)\n\t    this[offset + 3] = (value >>> 24)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t  if (value < 0) value = 0xffffffff + value + 1\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24)\n\t    this[offset + 1] = (value >>> 16)\n\t    this[offset + 2] = (value >>> 8)\n\t    this[offset + 3] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n\t  if (value > max || value < min) throw new RangeError('value is out of bounds')\n\t  if (offset + ext > buf.length) throw new RangeError('index out of range')\n\t  if (offset < 0) throw new RangeError('index out of range')\n\t}\n\t\n\tfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n\t  }\n\t  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, true, noAssert)\n\t}\n\t\n\tBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, false, noAssert)\n\t}\n\t\n\tfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n\t  }\n\t  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n\t  return offset + 8\n\t}\n\t\n\tBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, true, noAssert)\n\t}\n\t\n\tBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, false, noAssert)\n\t}\n\t\n\t// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\tBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n\t  if (!start) start = 0\n\t  if (!end && end !== 0) end = this.length\n\t  if (targetStart >= target.length) targetStart = target.length\n\t  if (!targetStart) targetStart = 0\n\t  if (end > 0 && end < start) end = start\n\t\n\t  // Copy 0 bytes; we're done\n\t  if (end === start) return 0\n\t  if (target.length === 0 || this.length === 0) return 0\n\t\n\t  // Fatal error conditions\n\t  if (targetStart < 0) {\n\t    throw new RangeError('targetStart out of bounds')\n\t  }\n\t  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n\t  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\t\n\t  // Are we oob?\n\t  if (end > this.length) end = this.length\n\t  if (target.length - targetStart < end - start) {\n\t    end = target.length - targetStart + start\n\t  }\n\t\n\t  var len = end - start\n\t  var i\n\t\n\t  if (this === target && start < targetStart && targetStart < end) {\n\t    // descending copy from end\n\t    for (i = len - 1; i >= 0; i--) {\n\t      target[i + targetStart] = this[i + start]\n\t    }\n\t  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // ascending copy from start\n\t    for (i = 0; i < len; i++) {\n\t      target[i + targetStart] = this[i + start]\n\t    }\n\t  } else {\n\t    target._set(this.subarray(start, start + len), targetStart)\n\t  }\n\t\n\t  return len\n\t}\n\t\n\t// fill(value, start=0, end=buffer.length)\n\tBuffer.prototype.fill = function fill (value, start, end) {\n\t  if (!value) value = 0\n\t  if (!start) start = 0\n\t  if (!end) end = this.length\n\t\n\t  if (end < start) throw new RangeError('end < start')\n\t\n\t  // Fill 0 bytes; we're done\n\t  if (end === start) return\n\t  if (this.length === 0) return\n\t\n\t  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n\t  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\t\n\t  var i\n\t  if (typeof value === 'number') {\n\t    for (i = start; i < end; i++) {\n\t      this[i] = value\n\t    }\n\t  } else {\n\t    var bytes = utf8ToBytes(value.toString())\n\t    var len = bytes.length\n\t    for (i = start; i < end; i++) {\n\t      this[i] = bytes[i % len]\n\t    }\n\t  }\n\t\n\t  return this\n\t}\n\t\n\t/**\n\t * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n\t * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n\t */\n\tBuffer.prototype.toArrayBuffer = function toArrayBuffer () {\n\t  if (typeof Uint8Array !== 'undefined') {\n\t    if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t      return (new Buffer(this)).buffer\n\t    } else {\n\t      var buf = new Uint8Array(this.length)\n\t      for (var i = 0, len = buf.length; i < len; i += 1) {\n\t        buf[i] = this[i]\n\t      }\n\t      return buf.buffer\n\t    }\n\t  } else {\n\t    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n\t  }\n\t}\n\t\n\t// HELPER FUNCTIONS\n\t// ================\n\t\n\tvar BP = Buffer.prototype\n\t\n\t/**\n\t * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n\t */\n\tBuffer._augment = function _augment (arr) {\n\t  arr.constructor = Buffer\n\t  arr._isBuffer = true\n\t\n\t  // save reference to original Uint8Array set method before overwriting\n\t  arr._set = arr.set\n\t\n\t  // deprecated\n\t  arr.get = BP.get\n\t  arr.set = BP.set\n\t\n\t  arr.write = BP.write\n\t  arr.toString = BP.toString\n\t  arr.toLocaleString = BP.toString\n\t  arr.toJSON = BP.toJSON\n\t  arr.equals = BP.equals\n\t  arr.compare = BP.compare\n\t  arr.indexOf = BP.indexOf\n\t  arr.copy = BP.copy\n\t  arr.slice = BP.slice\n\t  arr.readUIntLE = BP.readUIntLE\n\t  arr.readUIntBE = BP.readUIntBE\n\t  arr.readUInt8 = BP.readUInt8\n\t  arr.readUInt16LE = BP.readUInt16LE\n\t  arr.readUInt16BE = BP.readUInt16BE\n\t  arr.readUInt32LE = BP.readUInt32LE\n\t  arr.readUInt32BE = BP.readUInt32BE\n\t  arr.readIntLE = BP.readIntLE\n\t  arr.readIntBE = BP.readIntBE\n\t  arr.readInt8 = BP.readInt8\n\t  arr.readInt16LE = BP.readInt16LE\n\t  arr.readInt16BE = BP.readInt16BE\n\t  arr.readInt32LE = BP.readInt32LE\n\t  arr.readInt32BE = BP.readInt32BE\n\t  arr.readFloatLE = BP.readFloatLE\n\t  arr.readFloatBE = BP.readFloatBE\n\t  arr.readDoubleLE = BP.readDoubleLE\n\t  arr.readDoubleBE = BP.readDoubleBE\n\t  arr.writeUInt8 = BP.writeUInt8\n\t  arr.writeUIntLE = BP.writeUIntLE\n\t  arr.writeUIntBE = BP.writeUIntBE\n\t  arr.writeUInt16LE = BP.writeUInt16LE\n\t  arr.writeUInt16BE = BP.writeUInt16BE\n\t  arr.writeUInt32LE = BP.writeUInt32LE\n\t  arr.writeUInt32BE = BP.writeUInt32BE\n\t  arr.writeIntLE = BP.writeIntLE\n\t  arr.writeIntBE = BP.writeIntBE\n\t  arr.writeInt8 = BP.writeInt8\n\t  arr.writeInt16LE = BP.writeInt16LE\n\t  arr.writeInt16BE = BP.writeInt16BE\n\t  arr.writeInt32LE = BP.writeInt32LE\n\t  arr.writeInt32BE = BP.writeInt32BE\n\t  arr.writeFloatLE = BP.writeFloatLE\n\t  arr.writeFloatBE = BP.writeFloatBE\n\t  arr.writeDoubleLE = BP.writeDoubleLE\n\t  arr.writeDoubleBE = BP.writeDoubleBE\n\t  arr.fill = BP.fill\n\t  arr.inspect = BP.inspect\n\t  arr.toArrayBuffer = BP.toArrayBuffer\n\t\n\t  return arr\n\t}\n\t\n\tvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\t\n\tfunction base64clean (str) {\n\t  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\t  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n\t  // Node converts strings with length < 2 to ''\n\t  if (str.length < 2) return ''\n\t  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\t  while (str.length % 4 !== 0) {\n\t    str = str + '='\n\t  }\n\t  return str\n\t}\n\t\n\tfunction stringtrim (str) {\n\t  if (str.trim) return str.trim()\n\t  return str.replace(/^\\s+|\\s+$/g, '')\n\t}\n\t\n\tfunction toHex (n) {\n\t  if (n < 16) return '0' + n.toString(16)\n\t  return n.toString(16)\n\t}\n\t\n\tfunction utf8ToBytes (string, units) {\n\t  units = units || Infinity\n\t  var codePoint\n\t  var length = string.length\n\t  var leadSurrogate = null\n\t  var bytes = []\n\t\n\t  for (var i = 0; i < length; i++) {\n\t    codePoint = string.charCodeAt(i)\n\t\n\t    // is surrogate component\n\t    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n\t      // last char was a lead\n\t      if (!leadSurrogate) {\n\t        // no lead yet\n\t        if (codePoint > 0xDBFF) {\n\t          // unexpected trail\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t          continue\n\t        } else if (i + 1 === length) {\n\t          // unpaired lead\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t          continue\n\t        }\n\t\n\t        // valid lead\n\t        leadSurrogate = codePoint\n\t\n\t        continue\n\t      }\n\t\n\t      // 2 leads in a row\n\t      if (codePoint < 0xDC00) {\n\t        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t        leadSurrogate = codePoint\n\t        continue\n\t      }\n\t\n\t      // valid surrogate pair\n\t      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n\t    } else if (leadSurrogate) {\n\t      // valid bmp char, but last char was a lead\n\t      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t    }\n\t\n\t    leadSurrogate = null\n\t\n\t    // encode utf8\n\t    if (codePoint < 0x80) {\n\t      if ((units -= 1) < 0) break\n\t      bytes.push(codePoint)\n\t    } else if (codePoint < 0x800) {\n\t      if ((units -= 2) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x6 | 0xC0,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else if (codePoint < 0x10000) {\n\t      if ((units -= 3) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0xC | 0xE0,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else if (codePoint < 0x110000) {\n\t      if ((units -= 4) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x12 | 0xF0,\n\t        codePoint >> 0xC & 0x3F | 0x80,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else {\n\t      throw new Error('Invalid code point')\n\t    }\n\t  }\n\t\n\t  return bytes\n\t}\n\t\n\tfunction asciiToBytes (str) {\n\t  var byteArray = []\n\t  for (var i = 0; i < str.length; i++) {\n\t    // Node's code seems to be doing this and not & 0x7F..\n\t    byteArray.push(str.charCodeAt(i) & 0xFF)\n\t  }\n\t  return byteArray\n\t}\n\t\n\tfunction utf16leToBytes (str, units) {\n\t  var c, hi, lo\n\t  var byteArray = []\n\t  for (var i = 0; i < str.length; i++) {\n\t    if ((units -= 2) < 0) break\n\t\n\t    c = str.charCodeAt(i)\n\t    hi = c >> 8\n\t    lo = c % 256\n\t    byteArray.push(lo)\n\t    byteArray.push(hi)\n\t  }\n\t\n\t  return byteArray\n\t}\n\t\n\tfunction base64ToBytes (str) {\n\t  return base64.toByteArray(base64clean(str))\n\t}\n\t\n\tfunction blitBuffer (src, dst, offset, length) {\n\t  for (var i = 0; i < length; i++) {\n\t    if ((i + offset >= dst.length) || (i >= src.length)) break\n\t    dst[i + offset] = src[i]\n\t  }\n\t  return i\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10).Buffer, (function() { return this; }())))\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\t\n\t;(function (exports) {\n\t\t'use strict';\n\t\n\t  var Arr = (typeof Uint8Array !== 'undefined')\n\t    ? Uint8Array\n\t    : Array\n\t\n\t\tvar PLUS   = '+'.charCodeAt(0)\n\t\tvar SLASH  = '/'.charCodeAt(0)\n\t\tvar NUMBER = '0'.charCodeAt(0)\n\t\tvar LOWER  = 'a'.charCodeAt(0)\n\t\tvar UPPER  = 'A'.charCodeAt(0)\n\t\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\t\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\t\n\t\tfunction decode (elt) {\n\t\t\tvar code = elt.charCodeAt(0)\n\t\t\tif (code === PLUS ||\n\t\t\t    code === PLUS_URL_SAFE)\n\t\t\t\treturn 62 // '+'\n\t\t\tif (code === SLASH ||\n\t\t\t    code === SLASH_URL_SAFE)\n\t\t\t\treturn 63 // '/'\n\t\t\tif (code < NUMBER)\n\t\t\t\treturn -1 //no match\n\t\t\tif (code < NUMBER + 10)\n\t\t\t\treturn code - NUMBER + 26 + 26\n\t\t\tif (code < UPPER + 26)\n\t\t\t\treturn code - UPPER\n\t\t\tif (code < LOWER + 26)\n\t\t\t\treturn code - LOWER + 26\n\t\t}\n\t\n\t\tfunction b64ToByteArray (b64) {\n\t\t\tvar i, j, l, tmp, placeHolders, arr\n\t\n\t\t\tif (b64.length % 4 > 0) {\n\t\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t\t}\n\t\n\t\t\t// the number of equal signs (place holders)\n\t\t\t// if there are two placeholders, than the two characters before it\n\t\t\t// represent one byte\n\t\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t\t// this is just a cheap hack to not do indexOf twice\n\t\t\tvar len = b64.length\n\t\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\t\n\t\t\t// base64 is 4/3 + up to two characters of the original data\n\t\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\t\n\t\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\t\n\t\t\tvar L = 0\n\t\n\t\t\tfunction push (v) {\n\t\t\t\tarr[L++] = v\n\t\t\t}\n\t\n\t\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\t\tpush(tmp & 0xFF)\n\t\t\t}\n\t\n\t\t\tif (placeHolders === 2) {\n\t\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\t\tpush(tmp & 0xFF)\n\t\t\t} else if (placeHolders === 1) {\n\t\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\t\tpush(tmp & 0xFF)\n\t\t\t}\n\t\n\t\t\treturn arr\n\t\t}\n\t\n\t\tfunction uint8ToBase64 (uint8) {\n\t\t\tvar i,\n\t\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\t\toutput = \"\",\n\t\t\t\ttemp, length\n\t\n\t\t\tfunction encode (num) {\n\t\t\t\treturn lookup.charAt(num)\n\t\t\t}\n\t\n\t\t\tfunction tripletToBase64 (num) {\n\t\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t\t}\n\t\n\t\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\t\toutput += tripletToBase64(temp)\n\t\t\t}\n\t\n\t\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\t\tswitch (extraBytes) {\n\t\t\t\tcase 1:\n\t\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\t\toutput += '=='\n\t\t\t\t\tbreak\n\t\t\t\tcase 2:\n\t\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\t\toutput += '='\n\t\t\t\t\tbreak\n\t\t\t}\n\t\n\t\t\treturn output\n\t\t}\n\t\n\t\texports.toByteArray = b64ToByteArray\n\t\texports.fromByteArray = uint8ToBase64\n\t}( false ? (this.base64js = {}) : exports))\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\texports.read = function (buffer, offset, isLE, mLen, nBytes) {\n\t  var e, m\n\t  var eLen = nBytes * 8 - mLen - 1\n\t  var eMax = (1 << eLen) - 1\n\t  var eBias = eMax >> 1\n\t  var nBits = -7\n\t  var i = isLE ? (nBytes - 1) : 0\n\t  var d = isLE ? -1 : 1\n\t  var s = buffer[offset + i]\n\t\n\t  i += d\n\t\n\t  e = s & ((1 << (-nBits)) - 1)\n\t  s >>= (-nBits)\n\t  nBits += eLen\n\t  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\t\n\t  m = e & ((1 << (-nBits)) - 1)\n\t  e >>= (-nBits)\n\t  nBits += mLen\n\t  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\t\n\t  if (e === 0) {\n\t    e = 1 - eBias\n\t  } else if (e === eMax) {\n\t    return m ? NaN : ((s ? -1 : 1) * Infinity)\n\t  } else {\n\t    m = m + Math.pow(2, mLen)\n\t    e = e - eBias\n\t  }\n\t  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n\t}\n\t\n\texports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n\t  var e, m, c\n\t  var eLen = nBytes * 8 - mLen - 1\n\t  var eMax = (1 << eLen) - 1\n\t  var eBias = eMax >> 1\n\t  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n\t  var i = isLE ? 0 : (nBytes - 1)\n\t  var d = isLE ? 1 : -1\n\t  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\t\n\t  value = Math.abs(value)\n\t\n\t  if (isNaN(value) || value === Infinity) {\n\t    m = isNaN(value) ? 1 : 0\n\t    e = eMax\n\t  } else {\n\t    e = Math.floor(Math.log(value) / Math.LN2)\n\t    if (value * (c = Math.pow(2, -e)) < 1) {\n\t      e--\n\t      c *= 2\n\t    }\n\t    if (e + eBias >= 1) {\n\t      value += rt / c\n\t    } else {\n\t      value += rt * Math.pow(2, 1 - eBias)\n\t    }\n\t    if (value * c >= 2) {\n\t      e++\n\t      c /= 2\n\t    }\n\t\n\t    if (e + eBias >= eMax) {\n\t      m = 0\n\t      e = eMax\n\t    } else if (e + eBias >= 1) {\n\t      m = (value * c - 1) * Math.pow(2, mLen)\n\t      e = e + eBias\n\t    } else {\n\t      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n\t      e = 0\n\t    }\n\t  }\n\t\n\t  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\t\n\t  e = (e << mLen) | m\n\t  eLen += mLen\n\t  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\t\n\t  buffer[offset + i - d] |= s * 128\n\t}\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\tvar toString = {}.toString;\n\t\n\tmodule.exports = Array.isArray || function (arr) {\n\t  return toString.call(arr) == '[object Array]';\n\t};\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\t// resolves . and .. elements in a path array with directory names there\n\t// must be no slashes, empty elements, or device names (c:\\) in the array\n\t// (so also no leading and trailing slashes - it does not distinguish\n\t// relative and absolute paths)\n\tfunction normalizeArray(parts, allowAboveRoot) {\n\t  // if the path tries to go above the root, `up` ends up > 0\n\t  var up = 0;\n\t  for (var i = parts.length - 1; i >= 0; i--) {\n\t    var last = parts[i];\n\t    if (last === '.') {\n\t      parts.splice(i, 1);\n\t    } else if (last === '..') {\n\t      parts.splice(i, 1);\n\t      up++;\n\t    } else if (up) {\n\t      parts.splice(i, 1);\n\t      up--;\n\t    }\n\t  }\n\t\n\t  // if the path is allowed to go above the root, restore leading ..s\n\t  if (allowAboveRoot) {\n\t    for (; up--; up) {\n\t      parts.unshift('..');\n\t    }\n\t  }\n\t\n\t  return parts;\n\t}\n\t\n\t// Split a filename into [root, dir, basename, ext], unix version\n\t// 'root' is just a slash, or nothing.\n\tvar splitPathRe =\n\t    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n\tvar splitPath = function(filename) {\n\t  return splitPathRe.exec(filename).slice(1);\n\t};\n\t\n\t// path.resolve([from ...], to)\n\t// posix version\n\texports.resolve = function() {\n\t  var resolvedPath = '',\n\t      resolvedAbsolute = false;\n\t\n\t  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n\t    var path = (i >= 0) ? arguments[i] : process.cwd();\n\t\n\t    // Skip empty and invalid entries\n\t    if (typeof path !== 'string') {\n\t      throw new TypeError('Arguments to path.resolve must be strings');\n\t    } else if (!path) {\n\t      continue;\n\t    }\n\t\n\t    resolvedPath = path + '/' + resolvedPath;\n\t    resolvedAbsolute = path.charAt(0) === '/';\n\t  }\n\t\n\t  // At this point the path should be resolved to a full absolute path, but\n\t  // handle relative paths to be safe (might happen when process.cwd() fails)\n\t\n\t  // Normalize the path\n\t  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n\t    return !!p;\n\t  }), !resolvedAbsolute).join('/');\n\t\n\t  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n\t};\n\t\n\t// path.normalize(path)\n\t// posix version\n\texports.normalize = function(path) {\n\t  var isAbsolute = exports.isAbsolute(path),\n\t      trailingSlash = substr(path, -1) === '/';\n\t\n\t  // Normalize the path\n\t  path = normalizeArray(filter(path.split('/'), function(p) {\n\t    return !!p;\n\t  }), !isAbsolute).join('/');\n\t\n\t  if (!path && !isAbsolute) {\n\t    path = '.';\n\t  }\n\t  if (path && trailingSlash) {\n\t    path += '/';\n\t  }\n\t\n\t  return (isAbsolute ? '/' : '') + path;\n\t};\n\t\n\t// posix version\n\texports.isAbsolute = function(path) {\n\t  return path.charAt(0) === '/';\n\t};\n\t\n\t// posix version\n\texports.join = function() {\n\t  var paths = Array.prototype.slice.call(arguments, 0);\n\t  return exports.normalize(filter(paths, function(p, index) {\n\t    if (typeof p !== 'string') {\n\t      throw new TypeError('Arguments to path.join must be strings');\n\t    }\n\t    return p;\n\t  }).join('/'));\n\t};\n\t\n\t\n\t// path.relative(from, to)\n\t// posix version\n\texports.relative = function(from, to) {\n\t  from = exports.resolve(from).substr(1);\n\t  to = exports.resolve(to).substr(1);\n\t\n\t  function trim(arr) {\n\t    var start = 0;\n\t    for (; start < arr.length; start++) {\n\t      if (arr[start] !== '') break;\n\t    }\n\t\n\t    var end = arr.length - 1;\n\t    for (; end >= 0; end--) {\n\t      if (arr[end] !== '') break;\n\t    }\n\t\n\t    if (start > end) return [];\n\t    return arr.slice(start, end - start + 1);\n\t  }\n\t\n\t  var fromParts = trim(from.split('/'));\n\t  var toParts = trim(to.split('/'));\n\t\n\t  var length = Math.min(fromParts.length, toParts.length);\n\t  var samePartsLength = length;\n\t  for (var i = 0; i < length; i++) {\n\t    if (fromParts[i] !== toParts[i]) {\n\t      samePartsLength = i;\n\t      break;\n\t    }\n\t  }\n\t\n\t  var outputParts = [];\n\t  for (var i = samePartsLength; i < fromParts.length; i++) {\n\t    outputParts.push('..');\n\t  }\n\t\n\t  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\t\n\t  return outputParts.join('/');\n\t};\n\t\n\texports.sep = '/';\n\texports.delimiter = ':';\n\t\n\texports.dirname = function(path) {\n\t  var result = splitPath(path),\n\t      root = result[0],\n\t      dir = result[1];\n\t\n\t  if (!root && !dir) {\n\t    // No dirname whatsoever\n\t    return '.';\n\t  }\n\t\n\t  if (dir) {\n\t    // It has a dirname, strip trailing slash\n\t    dir = dir.substr(0, dir.length - 1);\n\t  }\n\t\n\t  return root + dir;\n\t};\n\t\n\t\n\texports.basename = function(path, ext) {\n\t  var f = splitPath(path)[2];\n\t  // TODO: make this comparison case-insensitive on windows?\n\t  if (ext && f.substr(-1 * ext.length) === ext) {\n\t    f = f.substr(0, f.length - ext.length);\n\t  }\n\t  return f;\n\t};\n\t\n\t\n\texports.extname = function(path) {\n\t  return splitPath(path)[3];\n\t};\n\t\n\tfunction filter (xs, f) {\n\t    if (xs.filter) return xs.filter(f);\n\t    var res = [];\n\t    for (var i = 0; i < xs.length; i++) {\n\t        if (f(xs[i], i, xs)) res.push(xs[i]);\n\t    }\n\t    return res;\n\t}\n\t\n\t// String.prototype.substr - negative index don't work in IE8\n\tvar substr = 'ab'.substr(-1) === 'b'\n\t    ? function (str, start, len) { return str.substr(start, len) }\n\t    : function (str, start, len) {\n\t        if (start < 0) start = str.length + start;\n\t        return str.substr(start, len);\n\t    }\n\t;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)))\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t// (c) Dean McNamee <dean@gmail.com>, 2013.\n\t//\n\t// https://github.com/deanm/omggif\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a copy\n\t// of this software and associated documentation files (the \"Software\"), to\n\t// deal in the Software without restriction, including without limitation the\n\t// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n\t// sell copies of the Software, and to permit persons to whom the Software is\n\t// furnished to do so, subject to the following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included in\n\t// all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\t// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\t// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\t// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\t// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n\t// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n\t// IN THE SOFTWARE.\n\t//\n\t// omggif is a JavaScript implementation of a GIF 89a encoder and decoder,\n\t// including animation and compression.  It does not rely on any specific\n\t// underlying system, so should run in the browser, Node, or Plask.\n\t\n\tfunction GifWriter(buf, width, height, gopts) {\n\t  var p = 0;\n\t\n\t  var gopts = gopts === undefined ? { } : gopts;\n\t  var loop_count = gopts.loop === undefined ? null : gopts.loop;\n\t  var global_palette = gopts.palette === undefined ? null : gopts.palette;\n\t\n\t  if (width <= 0 || height <= 0 || width > 65535 || height > 65535)\n\t    throw \"Width/Height invalid.\"\n\t\n\t  function check_palette_and_num_colors(palette) {\n\t    var num_colors = palette.length;\n\t    if (num_colors < 2 || num_colors > 256 ||  num_colors & (num_colors-1))\n\t      throw \"Invalid code/color length, must be power of 2 and 2 .. 256.\";\n\t    return num_colors;\n\t  }\n\t\n\t  // - Header.\n\t  buf[p++] = 0x47; buf[p++] = 0x49; buf[p++] = 0x46;  // GIF\n\t  buf[p++] = 0x38; buf[p++] = 0x39; buf[p++] = 0x61;  // 89a\n\t\n\t  // Handling of Global Color Table (palette) and background index.\n\t  var gp_num_colors_pow2 = 0;\n\t  var background = 0;\n\t  if (global_palette !== null) {\n\t    var gp_num_colors = check_palette_and_num_colors(global_palette);\n\t    while (gp_num_colors >>= 1) ++gp_num_colors_pow2;\n\t    gp_num_colors = 1 << gp_num_colors_pow2;\n\t    --gp_num_colors_pow2;\n\t    if (gopts.background !== undefined) {\n\t      background = gopts.background;\n\t      if (background >= gp_num_colors) throw \"Background index out of range.\";\n\t      // The GIF spec states that a background index of 0 should be ignored, so\n\t      // this is probably a mistake and you really want to set it to another\n\t      // slot in the palette.  But actually in the end most browsers, etc end\n\t      // up ignoring this almost completely (including for dispose background).\n\t      if (background === 0)\n\t        throw \"Background index explicitly passed as 0.\";\n\t    }\n\t  }\n\t\n\t  // - Logical Screen Descriptor.\n\t  // NOTE(deanm): w/h apparently ignored by implementations, but set anyway.\n\t  buf[p++] = width & 0xff; buf[p++] = width >> 8 & 0xff;\n\t  buf[p++] = height & 0xff; buf[p++] = height >> 8 & 0xff;\n\t  // NOTE: Indicates 0-bpp original color resolution (unused?).\n\t  buf[p++] = (global_palette !== null ? 0x80 : 0) |  // Global Color Table Flag.\n\t             gp_num_colors_pow2;  // NOTE: No sort flag (unused?).\n\t  buf[p++] = background;  // Background Color Index.\n\t  buf[p++] = 0;  // Pixel aspect ratio (unused?).\n\t\n\t  // - Global Color Table\n\t  if (global_palette !== null) {\n\t    for (var i = 0, il = global_palette.length; i < il; ++i) {\n\t      var rgb = global_palette[i];\n\t      buf[p++] = rgb >> 16 & 0xff;\n\t      buf[p++] = rgb >> 8 & 0xff;\n\t      buf[p++] = rgb & 0xff;\n\t    }\n\t  }\n\t\n\t  if (loop_count !== null) {  // Netscape block for looping.\n\t    if (loop_count < 0 || loop_count > 65535)\n\t      throw \"Loop count invalid.\"\n\t    // Extension code, label, and length.\n\t    buf[p++] = 0x21; buf[p++] = 0xff; buf[p++] = 0x0b;\n\t    // NETSCAPE2.0\n\t    buf[p++] = 0x4e; buf[p++] = 0x45; buf[p++] = 0x54; buf[p++] = 0x53;\n\t    buf[p++] = 0x43; buf[p++] = 0x41; buf[p++] = 0x50; buf[p++] = 0x45;\n\t    buf[p++] = 0x32; buf[p++] = 0x2e; buf[p++] = 0x30;\n\t    // Sub-block\n\t    buf[p++] = 0x03; buf[p++] = 0x01;\n\t    buf[p++] = loop_count & 0xff; buf[p++] = loop_count >> 8 & 0xff;\n\t    buf[p++] = 0x00;  // Terminator.\n\t  }\n\t\n\t\n\t  var ended = false;\n\t\n\t  this.addFrame = function(x, y, w, h, indexed_pixels, opts) {\n\t    if (ended === true) { --p; ended = false; }  // Un-end.\n\t\n\t    opts = opts === undefined ? { } : opts;\n\t\n\t    // TODO(deanm): Bounds check x, y.  Do they need to be within the virtual\n\t    // canvas width/height, I imagine?\n\t    if (x < 0 || y < 0 || x > 65535 || y > 65535)\n\t      throw \"x/y invalid.\"\n\t\n\t    if (w <= 0 || h <= 0 || w > 65535 || h > 65535)\n\t      throw \"Width/Height invalid.\"\n\t\n\t    if (indexed_pixels.length < w * h)\n\t      throw \"Not enough pixels for the frame size.\";\n\t\n\t    var using_local_palette = true;\n\t    var palette = opts.palette;\n\t    if (palette === undefined || palette === null) {\n\t      using_local_palette = false;\n\t      palette = global_palette;\n\t    }\n\t\n\t    if (palette === undefined || palette === null)\n\t      throw \"Must supply either a local or global palette.\";\n\t\n\t    var num_colors = check_palette_and_num_colors(palette);\n\t\n\t    // Compute the min_code_size (power of 2), destroying num_colors.\n\t    var min_code_size = 0;\n\t    while (num_colors >>= 1) ++min_code_size;\n\t    num_colors = 1 << min_code_size;  // Now we can easily get it back.\n\t\n\t    var delay = opts.delay === undefined ? 0 : opts.delay;\n\t\n\t    // From the spec:\n\t    //     0 -   No disposal specified. The decoder is\n\t    //           not required to take any action.\n\t    //     1 -   Do not dispose. The graphic is to be left\n\t    //           in place.\n\t    //     2 -   Restore to background color. The area used by the\n\t    //           graphic must be restored to the background color.\n\t    //     3 -   Restore to previous. The decoder is required to\n\t    //           restore the area overwritten by the graphic with\n\t    //           what was there prior to rendering the graphic.\n\t    //  4-7 -    To be defined.\n\t    // NOTE(deanm): Dispose background doesn't really work, apparently most\n\t    // browsers ignore the background palette index and clear to transparency.\n\t    var disposal = opts.disposal === undefined ? 0 : opts.disposal;\n\t    if (disposal < 0 || disposal > 3)  // 4-7 is reserved.\n\t      throw \"Disposal out of range.\";\n\t\n\t    var use_transparency = false;\n\t    var transparent_index = 0;\n\t    if (opts.transparent !== undefined && opts.transparent !== null) {\n\t      use_transparency = true;\n\t      transparent_index = opts.transparent;\n\t      if (transparent_index < 0 || transparent_index >= num_colors)\n\t        throw \"Transparent color index.\";\n\t    }\n\t\n\t    if (disposal !== 0 || use_transparency || delay !== 0) {\n\t      // - Graphics Control Extension\n\t      buf[p++] = 0x21; buf[p++] = 0xf9;  // Extension / Label.\n\t      buf[p++] = 4;  // Byte size.\n\t\n\t      buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0);\n\t      buf[p++] = delay & 0xff; buf[p++] = delay >> 8 & 0xff;\n\t      buf[p++] = transparent_index;  // Transparent color index.\n\t      buf[p++] = 0;  // Block Terminator.\n\t    }\n\t\n\t    // - Image Descriptor\n\t    buf[p++] = 0x2c;  // Image Seperator.\n\t    buf[p++] = x & 0xff; buf[p++] = x >> 8 & 0xff;  // Left.\n\t    buf[p++] = y & 0xff; buf[p++] = y >> 8 & 0xff;  // Top.\n\t    buf[p++] = w & 0xff; buf[p++] = w >> 8 & 0xff;\n\t    buf[p++] = h & 0xff; buf[p++] = h >> 8 & 0xff;\n\t    // NOTE: No sort flag (unused?).\n\t    // TODO(deanm): Support interlace.\n\t    buf[p++] = using_local_palette === true ? (0x80 | (min_code_size-1)) : 0;\n\t\n\t    // - Local Color Table\n\t    if (using_local_palette === true) {\n\t      for (var i = 0, il = palette.length; i < il; ++i) {\n\t        var rgb = palette[i];\n\t        buf[p++] = rgb >> 16 & 0xff;\n\t        buf[p++] = rgb >> 8 & 0xff;\n\t        buf[p++] = rgb & 0xff;\n\t      }\n\t    }\n\t\n\t    p = GifWriterOutputLZWCodeStream(\n\t            buf, p, min_code_size < 2 ? 2 : min_code_size, indexed_pixels);\n\t  };\n\t\n\t  this.end = function() {\n\t    if (ended === false) {\n\t      buf[p++] = 0x3b;  // Trailer.\n\t      ended = true;\n\t    }\n\t    return p;\n\t  };\n\t}\n\t\n\t// Main compression routine, palette indexes -> LZW code stream.\n\t// |index_stream| must have at least one entry.\n\tfunction GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {\n\t  buf[p++] = min_code_size;\n\t  var cur_subblock = p++;  // Pointing at the length field.\n\t\n\t  var clear_code = 1 << min_code_size;\n\t  var code_mask = clear_code - 1;\n\t  var eoi_code = clear_code + 1;\n\t  var next_code = eoi_code + 1;\n\t\n\t  var cur_code_size = min_code_size + 1;  // Number of bits per code.\n\t  var cur_shift = 0;\n\t  // We have at most 12-bit codes, so we should have to hold a max of 19\n\t  // bits here (and then we would write out).\n\t  var cur = 0;\n\t\n\t  function emit_bytes_to_buffer(bit_block_size) {\n\t    while (cur_shift >= bit_block_size) {\n\t      buf[p++] = cur & 0xff;\n\t      cur >>= 8; cur_shift -= 8;\n\t      if (p === cur_subblock + 256) {  // Finished a subblock.\n\t        buf[cur_subblock] = 255;\n\t        cur_subblock = p++;\n\t      }\n\t    }\n\t  }\n\t\n\t  function emit_code(c) {\n\t    cur |= c << cur_shift;\n\t    cur_shift += cur_code_size;\n\t    emit_bytes_to_buffer(8);\n\t  }\n\t\n\t  // I am not an expert on the topic, and I don't want to write a thesis.\n\t  // However, it is good to outline here the basic algorithm and the few data\n\t  // structures and optimizations here that make this implementation fast.\n\t  // The basic idea behind LZW is to build a table of previously seen runs\n\t  // addressed by a short id (herein called output code).  All data is\n\t  // referenced by a code, which represents one or more values from the\n\t  // original input stream.  All input bytes can be referenced as the same\n\t  // value as an output code.  So if you didn't want any compression, you\n\t  // could more or less just output the original bytes as codes (there are\n\t  // some details to this, but it is the idea).  In order to achieve\n\t  // compression, values greater then the input range (codes can be up to\n\t  // 12-bit while input only 8-bit) represent a sequence of previously seen\n\t  // inputs.  The decompressor is able to build the same mapping while\n\t  // decoding, so there is always a shared common knowledge between the\n\t  // encoding and decoder, which is also important for \"timing\" aspects like\n\t  // how to handle variable bit width code encoding.\n\t  //\n\t  // One obvious but very important consequence of the table system is there\n\t  // is always a unique id (at most 12-bits) to map the runs.  'A' might be\n\t  // 4, then 'AA' might be 10, 'AAA' 11, 'AAAA' 12, etc.  This relationship\n\t  // can be used for an effecient lookup strategy for the code mapping.  We\n\t  // need to know if a run has been seen before, and be able to map that run\n\t  // to the output code.  Since we start with known unique ids (input bytes),\n\t  // and then from those build more unique ids (table entries), we can\n\t  // continue this chain (almost like a linked list) to always have small\n\t  // integer values that represent the current byte chains in the encoder.\n\t  // This means instead of tracking the input bytes (AAAABCD) to know our\n\t  // current state, we can track the table entry for AAAABC (it is guaranteed\n\t  // to exist by the nature of the algorithm) and the next character D.\n\t  // Therefor the tuple of (table_entry, byte) is guaranteed to also be\n\t  // unique.  This allows us to create a simple lookup key for mapping input\n\t  // sequences to codes (table indices) without having to store or search\n\t  // any of the code sequences.  So if 'AAAA' has a table entry of 12, the\n\t  // tuple of ('AAAA', K) for any input byte K will be unique, and can be our\n\t  // key.  This leads to a integer value at most 20-bits, which can always\n\t  // fit in an SMI value and be used as a fast sparse array / object key.\n\t\n\t  // Output code for the current contents of the index buffer.\n\t  var ib_code = index_stream[0] & code_mask;  // Load first input index.\n\t  var code_table = { };  // Key'd on our 20-bit \"tuple\".\n\t\n\t  emit_code(clear_code);  // Spec says first code should be a clear code.\n\t\n\t  // First index already loaded, process the rest of the stream.\n\t  for (var i = 1, il = index_stream.length; i < il; ++i) {\n\t    var k = index_stream[i] & code_mask;\n\t    var cur_key = ib_code << 8 | k;  // (prev, k) unique tuple.\n\t    var cur_code = code_table[cur_key];  // buffer + k.\n\t\n\t    // Check if we have to create a new code table entry.\n\t    if (cur_code === undefined) {  // We don't have buffer + k.\n\t      // Emit index buffer (without k).\n\t      // This is an inline version of emit_code, because this is the core\n\t      // writing routine of the compressor (and V8 cannot inline emit_code\n\t      // because it is a closure here in a different context).  Additionally\n\t      // we can call emit_byte_to_buffer less often, because we can have\n\t      // 30-bits (from our 31-bit signed SMI), and we know our codes will only\n\t      // be 12-bits, so can safely have 18-bits there without overflow.\n\t      // emit_code(ib_code);\n\t      cur |= ib_code << cur_shift;\n\t      cur_shift += cur_code_size;\n\t      while (cur_shift >= 8) {\n\t        buf[p++] = cur & 0xff;\n\t        cur >>= 8; cur_shift -= 8;\n\t        if (p === cur_subblock + 256) {  // Finished a subblock.\n\t          buf[cur_subblock] = 255;\n\t          cur_subblock = p++;\n\t        }\n\t      }\n\t\n\t      if (next_code === 4096) {  // Table full, need a clear.\n\t        emit_code(clear_code);\n\t        next_code = eoi_code + 1;\n\t        cur_code_size = min_code_size + 1;\n\t        code_table = { };\n\t      } else {  // Table not full, insert a new entry.\n\t        // Increase our variable bit code sizes if necessary.  This is a bit\n\t        // tricky as it is based on \"timing\" between the encoding and\n\t        // decoder.  From the encoders perspective this should happen after\n\t        // we've already emitted the index buffer and are about to create the\n\t        // first table entry that would overflow our current code bit size.\n\t        if (next_code >= (1 << cur_code_size)) ++cur_code_size;\n\t        code_table[cur_key] = next_code++;  // Insert into code table.\n\t      }\n\t\n\t      ib_code = k;  // Index buffer to single input k.\n\t    } else {\n\t      ib_code = cur_code;  // Index buffer to sequence in code table.\n\t    }\n\t  }\n\t\n\t  emit_code(ib_code);  // There will still be something in the index buffer.\n\t  emit_code(eoi_code);  // End Of Information.\n\t\n\t  // Flush / finalize the sub-blocks stream to the buffer.\n\t  emit_bytes_to_buffer(1);\n\t\n\t  // Finish the sub-blocks, writing out any unfinished lengths and\n\t  // terminating with a sub-block of length 0.  If we have already started\n\t  // but not yet used a sub-block it can just become the terminator.\n\t  if (cur_subblock + 1 === p) {  // Started but unused.\n\t    buf[cur_subblock] = 0;\n\t  } else {  // Started and used, write length and additional terminator block.\n\t    buf[cur_subblock] = p - cur_subblock - 1;\n\t    buf[p++] = 0;\n\t  }\n\t  return p;\n\t}\n\t\n\tfunction GifReader(buf) {\n\t  var p = 0;\n\t\n\t  // - Header (GIF87a or GIF89a).\n\t  if (buf[p++] !== 0x47 ||            buf[p++] !== 0x49 || buf[p++] !== 0x46 ||\n\t      buf[p++] !== 0x38 || (buf[p++]+1 & 0xfd) !== 0x38 || buf[p++] !== 0x61) {\n\t    throw \"Invalid GIF 87a/89a header.\";\n\t  }\n\t\n\t  // - Logical Screen Descriptor.\n\t  var width = buf[p++] | buf[p++] << 8;\n\t  var height = buf[p++] | buf[p++] << 8;\n\t  var pf0 = buf[p++];  // <Packed Fields>.\n\t  var global_palette_flag = pf0 >> 7;\n\t  var num_global_colors_pow2 = pf0 & 0x7;\n\t  var num_global_colors = 1 << (num_global_colors_pow2 + 1);\n\t  var background = buf[p++];\n\t  buf[p++];  // Pixel aspect ratio (unused?).\n\t\n\t  var global_palette_offset = null;\n\t\n\t  if (global_palette_flag) {\n\t    global_palette_offset = p;\n\t    p += num_global_colors * 3;  // Seek past palette.\n\t  }\n\t\n\t  var no_eof = true;\n\t\n\t  var frames = [ ];\n\t\n\t  var delay = 0;\n\t  var transparent_index = null;\n\t  var disposal = 0;  // 0 - No disposal specified.\n\t  var loop_count = null;\n\t\n\t  this.width = width;\n\t  this.height = height;\n\t\n\t  while (no_eof && p < buf.length) {\n\t    switch (buf[p++]) {\n\t      case 0x21:  // Graphics Control Extension Block\n\t        switch (buf[p++]) {\n\t          case 0xff:  // Application specific block\n\t            // Try if it's a Netscape block (with animation loop counter).\n\t            if (buf[p   ] !== 0x0b ||  // 21 FF already read, check block size.\n\t                // NETSCAPE2.0\n\t                buf[p+1 ] == 0x4e && buf[p+2 ] == 0x45 && buf[p+3 ] == 0x54 &&\n\t                buf[p+4 ] == 0x53 && buf[p+5 ] == 0x43 && buf[p+6 ] == 0x41 &&\n\t                buf[p+7 ] == 0x50 && buf[p+8 ] == 0x45 && buf[p+9 ] == 0x32 &&\n\t                buf[p+10] == 0x2e && buf[p+11] == 0x30 &&\n\t                // Sub-block\n\t                buf[p+12] == 0x03 && buf[p+13] == 0x01 && buf[p+16] == 0) {\n\t              p += 14;\n\t              loop_count = buf[p++] | buf[p++] << 8;\n\t              p++;  // Skip terminator.\n\t            } else {  // We don't know what it is, just try to get past it.\n\t              p += 12;\n\t              while (true) {  // Seek through subblocks.\n\t                var block_size = buf[p++];\n\t                if (block_size === 0) break;\n\t                p += block_size;\n\t              }\n\t            }\n\t            break;\n\t\n\t          case 0xf9:  // Graphics Control Extension\n\t            if (buf[p++] !== 0x4 || buf[p+4] !== 0)\n\t              throw \"Invalid graphics extension block.\";\n\t            var pf1 = buf[p++];\n\t            delay = buf[p++] | buf[p++] << 8;\n\t            transparent_index = buf[p++];\n\t            if ((pf1 & 1) === 0) transparent_index = null;\n\t            disposal = pf1 >> 2 & 0x7;\n\t            p++;  // Skip terminator.\n\t            break;\n\t\n\t          case 0xfe:  // Comment Extension.\n\t            while (true) {  // Seek through subblocks.\n\t              var block_size = buf[p++];\n\t              if (block_size === 0) break;\n\t              // console.log(buf.slice(p, p+block_size).toString('ascii'));\n\t              p += block_size;\n\t            }\n\t            break;\n\t\n\t          default:\n\t            throw \"Unknown graphic control label: 0x\" + buf[p-1].toString(16);\n\t        }\n\t        break;\n\t\n\t      case 0x2c:  // Image Descriptor.\n\t        var x = buf[p++] | buf[p++] << 8;\n\t        var y = buf[p++] | buf[p++] << 8;\n\t        var w = buf[p++] | buf[p++] << 8;\n\t        var h = buf[p++] | buf[p++] << 8;\n\t        var pf2 = buf[p++];\n\t        var local_palette_flag = pf2 >> 7;\n\t        var interlace_flag = pf2 >> 6 & 1;\n\t        var num_local_colors_pow2 = pf2 & 0x7;\n\t        var num_local_colors = 1 << (num_local_colors_pow2 + 1);\n\t        var palette_offset = global_palette_offset;\n\t        var has_local_palette = false;\n\t        if (local_palette_flag) {\n\t          var has_local_palette = true;\n\t          palette_offset = p;  // Override with local palette.\n\t          p += num_local_colors * 3;  // Seek past palette.\n\t        }\n\t\n\t        var data_offset = p;\n\t\n\t        p++;  // codesize\n\t        while (true) {\n\t          var block_size = buf[p++];\n\t          if (block_size === 0) break;\n\t          p += block_size;\n\t        }\n\t\n\t        frames.push({x: x, y: y, width: w, height: h,\n\t                     has_local_palette: has_local_palette,\n\t                     palette_offset: palette_offset,\n\t                     data_offset: data_offset,\n\t                     data_length: p - data_offset,\n\t                     transparent_index: transparent_index,\n\t                     interlaced: !!interlace_flag,\n\t                     delay: delay,\n\t                     disposal: disposal});\n\t        break;\n\t\n\t      case 0x3b:  // Trailer Marker (end of file).\n\t        no_eof = false;\n\t        break;\n\t\n\t      default:\n\t        throw \"Unknown gif block: 0x\" + buf[p-1].toString(16);\n\t        break;\n\t    }\n\t  }\n\t\n\t  this.numFrames = function() {\n\t    return frames.length;\n\t  };\n\t\n\t  this.loopCount = function() {\n\t    return loop_count;\n\t  };\n\t\n\t  this.frameInfo = function(frame_num) {\n\t    if (frame_num < 0 || frame_num >= frames.length)\n\t      throw \"Frame index out of range.\";\n\t    return frames[frame_num];\n\t  }\n\t\n\t  this.decodeAndBlitFrameBGRA = function(frame_num, pixels) {\n\t    var frame = this.frameInfo(frame_num);\n\t    var num_pixels = frame.width * frame.height;\n\t    var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.\n\t    GifReaderLZWOutputIndexStream(\n\t        buf, frame.data_offset, index_stream, num_pixels);\n\t    var palette_offset = frame.palette_offset;\n\t\n\t    // NOTE(deanm): It seems to be much faster to compare index to 256 than\n\t    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in\n\t    // the profile, not sure if it's related to using a Uint8Array.\n\t    var trans = frame.transparent_index;\n\t    if (trans === null) trans = 256;\n\t\n\t    // We are possibly just blitting to a portion of the entire frame.\n\t    // That is a subrect within the framerect, so the additional pixels\n\t    // must be skipped over after we finished a scanline.\n\t    var framewidth  = frame.width;\n\t    var framestride = width - framewidth;\n\t    var xleft       = framewidth;  // Number of subrect pixels left in scanline.\n\t\n\t    // Output indicies of the top left and bottom right corners of the subrect.\n\t    var opbeg = ((frame.y * width) + frame.x) * 4;\n\t    var opend = ((frame.y + frame.height) * width + frame.x) * 4;\n\t    var op    = opbeg;\n\t\n\t    var scanstride = framestride * 4;\n\t\n\t    // Use scanstride to skip past the rows when interlacing.  This is skipping\n\t    // 7 rows for the first two passes, then 3 then 1.\n\t    if (frame.interlaced === true) {\n\t      scanstride += width * 4 * 7;  // Pass 1.\n\t    }\n\t\n\t    var interlaceskip = 8;  // Tracking the row interval in the current pass.\n\t\n\t    for (var i = 0, il = index_stream.length; i < il; ++i) {\n\t      var index = index_stream[i];\n\t\n\t      if (xleft === 0) {  // Beginning of new scan line\n\t        op += scanstride;\n\t        xleft = framewidth;\n\t        if (op >= opend) { // Catch the wrap to switch passes when interlacing.\n\t          scanstride = framestride * 4 + width * 4 * (interlaceskip-1);\n\t          // interlaceskip / 2 * 4 is interlaceskip << 1.\n\t          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);\n\t          interlaceskip >>= 1;\n\t        }\n\t      }\n\t\n\t      if (index === trans) {\n\t        op += 4;\n\t      } else {\n\t        var r = buf[palette_offset + index * 3];\n\t        var g = buf[palette_offset + index * 3 + 1];\n\t        var b = buf[palette_offset + index * 3 + 2];\n\t        pixels[op++] = b;\n\t        pixels[op++] = g;\n\t        pixels[op++] = r;\n\t        pixels[op++] = 255;\n\t      }\n\t      --xleft;\n\t    }\n\t  };\n\t\n\t  // I will go to copy and paste hell one day...\n\t  this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {\n\t    var frame = this.frameInfo(frame_num);\n\t    var num_pixels = frame.width * frame.height;\n\t    var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.\n\t    GifReaderLZWOutputIndexStream(\n\t        buf, frame.data_offset, index_stream, num_pixels);\n\t    var palette_offset = frame.palette_offset;\n\t\n\t    // NOTE(deanm): It seems to be much faster to compare index to 256 than\n\t    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in\n\t    // the profile, not sure if it's related to using a Uint8Array.\n\t    var trans = frame.transparent_index;\n\t    if (trans === null) trans = 256;\n\t\n\t    // We are possibly just blitting to a portion of the entire frame.\n\t    // That is a subrect within the framerect, so the additional pixels\n\t    // must be skipped over after we finished a scanline.\n\t    var framewidth  = frame.width;\n\t    var framestride = width - framewidth;\n\t    var xleft       = framewidth;  // Number of subrect pixels left in scanline.\n\t\n\t    // Output indicies of the top left and bottom right corners of the subrect.\n\t    var opbeg = ((frame.y * width) + frame.x) * 4;\n\t    var opend = ((frame.y + frame.height) * width + frame.x) * 4;\n\t    var op    = opbeg;\n\t\n\t    var scanstride = framestride * 4;\n\t\n\t    // Use scanstride to skip past the rows when interlacing.  This is skipping\n\t    // 7 rows for the first two passes, then 3 then 1.\n\t    if (frame.interlaced === true) {\n\t      scanstride += width * 4 * 7;  // Pass 1.\n\t    }\n\t\n\t    var interlaceskip = 8;  // Tracking the row interval in the current pass.\n\t\n\t    for (var i = 0, il = index_stream.length; i < il; ++i) {\n\t      var index = index_stream[i];\n\t\n\t      if (xleft === 0) {  // Beginning of new scan line\n\t        op += scanstride;\n\t        xleft = framewidth;\n\t        if (op >= opend) { // Catch the wrap to switch passes when interlacing.\n\t          scanstride = framestride * 4 + width * 4 * (interlaceskip-1);\n\t          // interlaceskip / 2 * 4 is interlaceskip << 1.\n\t          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);\n\t          interlaceskip >>= 1;\n\t        }\n\t      }\n\t\n\t      if (index === trans) {\n\t        op += 4;\n\t      } else {\n\t        var r = buf[palette_offset + index * 3];\n\t        var g = buf[palette_offset + index * 3 + 1];\n\t        var b = buf[palette_offset + index * 3 + 2];\n\t        pixels[op++] = r;\n\t        pixels[op++] = g;\n\t        pixels[op++] = b;\n\t        pixels[op++] = 255;\n\t      }\n\t      --xleft;\n\t    }\n\t  };\n\t}\n\t\n\tfunction GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {\n\t  var min_code_size = code_stream[p++];\n\t\n\t  var clear_code = 1 << min_code_size;\n\t  var eoi_code = clear_code + 1;\n\t  var next_code = eoi_code + 1;\n\t\n\t  var cur_code_size = min_code_size + 1;  // Number of bits per code.\n\t  // NOTE: This shares the same name as the encoder, but has a different\n\t  // meaning here.  Here this masks each code coming from the code stream.\n\t  var code_mask = (1 << cur_code_size) - 1;\n\t  var cur_shift = 0;\n\t  var cur = 0;\n\t\n\t  var op = 0;  // Output pointer.\n\t  \n\t  var subblock_size = code_stream[p++];\n\t\n\t  // TODO(deanm): Would using a TypedArray be any faster?  At least it would\n\t  // solve the fast mode / backing store uncertainty.\n\t  // var code_table = Array(4096);\n\t  var code_table = new Int32Array(4096);  // Can be signed, we only use 20 bits.\n\t\n\t  var prev_code = null;  // Track code-1.\n\t\n\t  while (true) {\n\t    // Read up to two bytes, making sure we always 12-bits for max sized code.\n\t    while (cur_shift < 16) {\n\t      if (subblock_size === 0) break;  // No more data to be read.\n\t\n\t      cur |= code_stream[p++] << cur_shift;\n\t      cur_shift += 8;\n\t\n\t      if (subblock_size === 1) {  // Never let it get to 0 to hold logic above.\n\t        subblock_size = code_stream[p++];  // Next subblock.\n\t      } else {\n\t        --subblock_size;\n\t      }\n\t    }\n\t\n\t    // TODO(deanm): We should never really get here, we should have received\n\t    // and EOI.\n\t    if (cur_shift < cur_code_size)\n\t      break;\n\t\n\t    var code = cur & code_mask;\n\t    cur >>= cur_code_size;\n\t    cur_shift -= cur_code_size;\n\t\n\t    // TODO(deanm): Maybe should check that the first code was a clear code,\n\t    // at least this is what you're supposed to do.  But actually our encoder\n\t    // now doesn't emit a clear code first anyway.\n\t    if (code === clear_code) {\n\t      // We don't actually have to clear the table.  This could be a good idea\n\t      // for greater error checking, but we don't really do any anyway.  We\n\t      // will just track it with next_code and overwrite old entries.\n\t\n\t      next_code = eoi_code + 1;\n\t      cur_code_size = min_code_size + 1;\n\t      code_mask = (1 << cur_code_size) - 1;\n\t\n\t      // Don't update prev_code ?\n\t      prev_code = null;\n\t      continue;\n\t    } else if (code === eoi_code) {\n\t      break;\n\t    }\n\t\n\t    // We have a similar situation as the decoder, where we want to store\n\t    // variable length entries (code table entries), but we want to do in a\n\t    // faster manner than an array of arrays.  The code below stores sort of a\n\t    // linked list within the code table, and then \"chases\" through it to\n\t    // construct the dictionary entries.  When a new entry is created, just the\n\t    // last byte is stored, and the rest (prefix) of the entry is only\n\t    // referenced by its table entry.  Then the code chases through the\n\t    // prefixes until it reaches a single byte code.  We have to chase twice,\n\t    // first to compute the length, and then to actually copy the data to the\n\t    // output (backwards, since we know the length).  The alternative would be\n\t    // storing something in an intermediate stack, but that doesn't make any\n\t    // more sense.  I implemented an approach where it also stored the length\n\t    // in the code table, although it's a bit tricky because you run out of\n\t    // bits (12 + 12 + 8), but I didn't measure much improvements (the table\n\t    // entries are generally not the long).  Even when I created benchmarks for\n\t    // very long table entries the complexity did not seem worth it.\n\t    // The code table stores the prefix entry in 12 bits and then the suffix\n\t    // byte in 8 bits, so each entry is 20 bits.\n\t\n\t    var chase_code = code < next_code ? code : prev_code;\n\t\n\t    // Chase what we will output, either {CODE} or {CODE-1}.\n\t    var chase_length = 0;\n\t    var chase = chase_code;\n\t    while (chase > clear_code) {\n\t      chase = code_table[chase] >> 8;\n\t      ++chase_length;\n\t    }\n\t\n\t    var k = chase;\n\t    \n\t    var op_end = op + chase_length + (chase_code !== code ? 1 : 0);\n\t    if (op_end > output_length) {\n\t      console.log(\"Warning, gif stream longer than expected.\");\n\t      return;\n\t    }\n\t\n\t    // Already have the first byte from the chase, might as well write it fast.\n\t    output[op++] = k;\n\t\n\t    op += chase_length;\n\t    var b = op;  // Track pointer, writing backwards.\n\t\n\t    if (chase_code !== code)  // The case of emitting {CODE-1} + k.\n\t      output[op++] = k;\n\t\n\t    chase = chase_code;\n\t    while (chase_length--) {\n\t      chase = code_table[chase];\n\t      output[--b] = chase & 0xff;  // Write backwards.\n\t      chase >>= 8;  // Pull down to the prefix code.\n\t    }\n\t\n\t    if (prev_code !== null && next_code < 4096) {\n\t      code_table[next_code++] = prev_code << 8 | k;\n\t      // TODO(deanm): Figure out this clearing vs code growth logic better.  I\n\t      // have an feeling that it should just happen somewhere else, for now it\n\t      // is awkward between when we grow past the max and then hit a clear code.\n\t      // For now just check if we hit the max 12-bits (then a clear code should\n\t      // follow, also of course encoded in 12-bits).\n\t      if (next_code >= code_mask+1 && cur_code_size < 12) {\n\t        ++cur_code_size;\n\t        code_mask = code_mask << 1 | 1;\n\t      }\n\t    }\n\t\n\t    prev_code = code;\n\t  }\n\t\n\t  if (op !== output_length) {\n\t    console.log(\"Warning, gif stream shorter than expected.\");\n\t  }\n\t\n\t  return output;\n\t}\n\t\n\ttry { exports.GifWriter = GifWriter; exports.GifReader = GifReader } catch(e) { }  // CommonJS.\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\"\n\t\n\tvar ndarray = __webpack_require__(5)\n\tvar do_convert = __webpack_require__(17)\n\t\n\tmodule.exports = function convert(arr, result) {\n\t  var shape = [], c = arr, sz = 1\n\t  while(c instanceof Array) {\n\t    shape.push(c.length)\n\t    sz *= c.length\n\t    c = c[0]\n\t  }\n\t  if(shape.length === 0) {\n\t    return ndarray()\n\t  }\n\t  if(!result) {\n\t    result = ndarray(new Float64Array(sz), shape)\n\t  }\n\t  do_convert(result, arr)\n\t  return result\n\t}\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports=__webpack_require__(18)({\"args\":[\"array\",\"scalar\",\"index\"],\"pre\":{\"body\":\"{}\",\"args\":[],\"thisVars\":[],\"localVars\":[]},\"body\":{\"body\":\"{\\nvar _inline_1_v=_inline_1_arg1_,_inline_1_i\\nfor(_inline_1_i=0;_inline_1_i<_inline_1_arg2_.length-1;++_inline_1_i) {\\n_inline_1_v=_inline_1_v[_inline_1_arg2_[_inline_1_i]]\\n}\\n_inline_1_arg0_=_inline_1_v[_inline_1_arg2_[_inline_1_arg2_.length-1]]\\n}\",\"args\":[{\"name\":\"_inline_1_arg0_\",\"lvalue\":true,\"rvalue\":false,\"count\":1},{\"name\":\"_inline_1_arg1_\",\"lvalue\":false,\"rvalue\":true,\"count\":1},{\"name\":\"_inline_1_arg2_\",\"lvalue\":false,\"rvalue\":true,\"count\":4}],\"thisVars\":[],\"localVars\":[\"_inline_1_i\",\"_inline_1_v\"]},\"post\":{\"body\":\"{}\",\"args\":[],\"thisVars\":[],\"localVars\":[]},\"funcName\":\"convert\",\"blockSize\":64})\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\"\n\t\n\tvar createThunk = __webpack_require__(19)\n\t\n\tfunction Procedure() {\n\t  this.argTypes = []\n\t  this.shimArgs = []\n\t  this.arrayArgs = []\n\t  this.scalarArgs = []\n\t  this.offsetArgs = []\n\t  this.offsetArgIndex = []\n\t  this.indexArgs = []\n\t  this.shapeArgs = []\n\t  this.funcName = \"\"\n\t  this.pre = null\n\t  this.body = null\n\t  this.post = null\n\t  this.debug = false\n\t}\n\t\n\tfunction compileCwise(user_args) {\n\t  //Create procedure\n\t  var proc = new Procedure()\n\t  \n\t  //Parse blocks\n\t  proc.pre    = user_args.pre\n\t  proc.body   = user_args.body\n\t  proc.post   = user_args.post\n\t\n\t  //Parse arguments\n\t  var proc_args = user_args.args.slice(0)\n\t  proc.argTypes = proc_args.slice(0)\n\t  for(var i=0; i<proc_args.length; ++i) {\n\t    var arg_type = proc_args[i]\n\t    if(arg_type === \"array\") {\n\t      proc.arrayArgs.push(i)\n\t      proc.shimArgs.push(\"array\" + i)\n\t      if(i < proc.pre.args.length && proc.pre.args[i].count>0) {\n\t        throw new Error(\"cwise: pre() block may not reference array args\")\n\t      }\n\t      if(i < proc.post.args.length && proc.post.args[i].count>0) {\n\t        throw new Error(\"cwise: post() block may not reference array args\")\n\t      }\n\t    } else if(arg_type === \"scalar\") {\n\t      proc.scalarArgs.push(i)\n\t      proc.shimArgs.push(\"scalar\" + i)\n\t    } else if(arg_type === \"index\") {\n\t      proc.indexArgs.push(i)\n\t      if(i < proc.pre.args.length && proc.pre.args[i].count > 0) {\n\t        throw new Error(\"cwise: pre() block may not reference array index\")\n\t      }\n\t      if(i < proc.body.args.length && proc.body.args[i].lvalue) {\n\t        throw new Error(\"cwise: body() block may not write to array index\")\n\t      }\n\t      if(i < proc.post.args.length && proc.post.args[i].count > 0) {\n\t        throw new Error(\"cwise: post() block may not reference array index\")\n\t      }\n\t    } else if(arg_type === \"shape\") {\n\t      proc.shapeArgs.push(i)\n\t      if(i < proc.pre.args.length && proc.pre.args[i].lvalue) {\n\t        throw new Error(\"cwise: pre() block may not write to array shape\")\n\t      }\n\t      if(i < proc.body.args.length && proc.body.args[i].lvalue) {\n\t        throw new Error(\"cwise: body() block may not write to array shape\")\n\t      }\n\t      if(i < proc.post.args.length && proc.post.args[i].lvalue) {\n\t        throw new Error(\"cwise: post() block may not write to array shape\")\n\t      }\n\t    } else if(typeof arg_type === \"object\" && arg_type.offset) {\n\t      proc.argTypes[i] = \"offset\"\n\t      proc.offsetArgs.push({ array: arg_type.array, offset:arg_type.offset })\n\t      proc.offsetArgIndex.push(i)\n\t    } else {\n\t      throw new Error(\"cwise: Unknown argument type \" + proc_args[i])\n\t    }\n\t  }\n\t  \n\t  //Make sure at least one array argument was specified\n\t  if(proc.arrayArgs.length <= 0) {\n\t    throw new Error(\"cwise: No array arguments specified\")\n\t  }\n\t  \n\t  //Make sure arguments are correct\n\t  if(proc.pre.args.length > proc_args.length) {\n\t    throw new Error(\"cwise: Too many arguments in pre() block\")\n\t  }\n\t  if(proc.body.args.length > proc_args.length) {\n\t    throw new Error(\"cwise: Too many arguments in body() block\")\n\t  }\n\t  if(proc.post.args.length > proc_args.length) {\n\t    throw new Error(\"cwise: Too many arguments in post() block\")\n\t  }\n\t\n\t  //Check debug flag\n\t  proc.debug = !!user_args.printCode || !!user_args.debug\n\t  \n\t  //Retrieve name\n\t  proc.funcName = user_args.funcName || \"cwise\"\n\t  \n\t  //Read in block size\n\t  proc.blockSize = user_args.blockSize || 64\n\t\n\t  return createThunk(proc)\n\t}\n\t\n\tmodule.exports = compileCwise\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\"\n\t\n\tvar compile = __webpack_require__(20)\n\t\n\tfunction createThunk(proc) {\n\t  var code = [\"'use strict'\", \"var CACHED={}\"]\n\t  var vars = []\n\t  var thunkName = proc.funcName + \"_cwise_thunk\"\n\t  \n\t  //Build thunk\n\t  code.push([\"return function \", thunkName, \"(\", proc.shimArgs.join(\",\"), \"){\"].join(\"\"))\n\t  var typesig = []\n\t  var string_typesig = []\n\t  var proc_args = [[\"array\",proc.arrayArgs[0],\".shape\"].join(\"\")]\n\t  for(var i=0; i<proc.arrayArgs.length; ++i) {\n\t    var j = proc.arrayArgs[i]\n\t    vars.push([\"t\", j, \"=array\", j, \".dtype,\",\n\t               \"r\", j, \"=array\", j, \".order\"].join(\"\"))\n\t    typesig.push(\"t\" + j)\n\t    typesig.push(\"r\" + j)\n\t    string_typesig.push(\"t\"+j)\n\t    string_typesig.push(\"r\"+j+\".join()\")\n\t    proc_args.push(\"array\" + j + \".data\")\n\t    proc_args.push(\"array\" + j + \".stride\")\n\t    proc_args.push(\"array\" + j + \".offset|0\")\n\t  }\n\t  for(var i=0; i<proc.scalarArgs.length; ++i) {\n\t    proc_args.push(\"scalar\" + proc.scalarArgs[i])\n\t  }\n\t  vars.push([\"type=[\", string_typesig.join(\",\"), \"].join()\"].join(\"\"))\n\t  vars.push(\"proc=CACHED[type]\")\n\t  code.push(\"var \" + vars.join(\",\"))\n\t  \n\t  code.push([\"if(!proc){\",\n\t             \"CACHED[type]=proc=compile([\", typesig.join(\",\"), \"])}\",\n\t             \"return proc(\", proc_args.join(\",\"), \")}\"].join(\"\"))\n\t\n\t  if(proc.debug) {\n\t    console.log(\"Generated thunk:\", code.join(\"\\n\"))\n\t  }\n\t  \n\t  //Compile thunk\n\t  var thunk = new Function(\"compile\", code.join(\"\\n\"))\n\t  return thunk(compile.bind(undefined, proc))\n\t}\n\t\n\tmodule.exports = createThunk\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\"\n\t\n\tvar uniq = __webpack_require__(21)\n\t\n\tfunction innerFill(order, proc, body) {\n\t  var dimension = order.length\n\t    , nargs = proc.arrayArgs.length\n\t    , has_index = proc.indexArgs.length>0\n\t    , code = []\n\t    , vars = []\n\t    , idx=0, pidx=0, i, j\n\t  for(i=0; i<dimension; ++i) {\n\t    vars.push([\"i\",i,\"=0\"].join(\"\"))\n\t  }\n\t  //Compute scan deltas\n\t  for(j=0; j<nargs; ++j) {\n\t    for(i=0; i<dimension; ++i) {\n\t      pidx = idx\n\t      idx = order[i]\n\t      if(i === 0) {\n\t        vars.push([\"d\",j,\"s\",i,\"=t\",j,\"[\",idx,\"]\"].join(\"\"))\n\t      } else {\n\t        vars.push([\"d\",j,\"s\",i,\"=(t\",j,\"[\",idx,\"]-s\",pidx,\"*t\",j,\"[\",pidx,\"])\"].join(\"\"))\n\t      }\n\t    }\n\t  }\n\t  code.push(\"var \" + vars.join(\",\"))\n\t  //Scan loop\n\t  for(i=dimension-1; i>=0; --i) {\n\t    idx = order[i]\n\t    code.push([\"for(i\",i,\"=0;i\",i,\"<s\",idx,\";++i\",i,\"){\"].join(\"\"))\n\t  }\n\t  //Push body of inner loop\n\t  code.push(body)\n\t  //Advance scan pointers\n\t  for(i=0; i<dimension; ++i) {\n\t    pidx = idx\n\t    idx = order[i]\n\t    for(j=0; j<nargs; ++j) {\n\t      code.push([\"p\",j,\"+=d\",j,\"s\",i].join(\"\"))\n\t    }\n\t    if(has_index) {\n\t      if(i > 0) {\n\t        code.push([\"index[\",pidx,\"]-=s\",pidx].join(\"\"))\n\t      }\n\t      code.push([\"++index[\",idx,\"]\"].join(\"\"))\n\t    }\n\t    code.push(\"}\")\n\t  }\n\t  return code.join(\"\\n\")\n\t}\n\t\n\tfunction outerFill(matched, order, proc, body) {\n\t  var dimension = order.length\n\t    , nargs = proc.arrayArgs.length\n\t    , blockSize = proc.blockSize\n\t    , has_index = proc.indexArgs.length > 0\n\t    , code = []\n\t  for(var i=0; i<nargs; ++i) {\n\t    code.push([\"var offset\",i,\"=p\",i].join(\"\"))\n\t  }\n\t  //Generate matched loops\n\t  for(var i=matched; i<dimension; ++i) {\n\t    code.push([\"for(var j\"+i+\"=SS[\", order[i], \"]|0;j\", i, \">0;){\"].join(\"\"))\n\t    code.push([\"if(j\",i,\"<\",blockSize,\"){\"].join(\"\"))\n\t    code.push([\"s\",order[i],\"=j\",i].join(\"\"))\n\t    code.push([\"j\",i,\"=0\"].join(\"\"))\n\t    code.push([\"}else{s\",order[i],\"=\",blockSize].join(\"\"))\n\t    code.push([\"j\",i,\"-=\",blockSize,\"}\"].join(\"\"))\n\t    if(has_index) {\n\t      code.push([\"index[\",order[i],\"]=j\",i].join(\"\"))\n\t    }\n\t  }\n\t  for(var i=0; i<nargs; ++i) {\n\t    var indexStr = [\"offset\"+i]\n\t    for(var j=matched; j<dimension; ++j) {\n\t      indexStr.push([\"j\",j,\"*t\",i,\"[\",order[j],\"]\"].join(\"\"))\n\t    }\n\t    code.push([\"p\",i,\"=(\",indexStr.join(\"+\"),\")\"].join(\"\"))\n\t  }\n\t  code.push(innerFill(order, proc, body))\n\t  for(var i=matched; i<dimension; ++i) {\n\t    code.push(\"}\")\n\t  }\n\t  return code.join(\"\\n\")\n\t}\n\t\n\t//Count the number of compatible inner orders\n\tfunction countMatches(orders) {\n\t  var matched = 0, dimension = orders[0].length\n\t  while(matched < dimension) {\n\t    for(var j=1; j<orders.length; ++j) {\n\t      if(orders[j][matched] !== orders[0][matched]) {\n\t        return matched\n\t      }\n\t    }\n\t    ++matched\n\t  }\n\t  return matched\n\t}\n\t\n\t//Processes a block according to the given data types\n\tfunction processBlock(block, proc, dtypes) {\n\t  var code = block.body\n\t  var pre = []\n\t  var post = []\n\t  for(var i=0; i<block.args.length; ++i) {\n\t    var carg = block.args[i]\n\t    if(carg.count <= 0) {\n\t      continue\n\t    }\n\t    var re = new RegExp(carg.name, \"g\")\n\t    var ptrStr = \"\"\n\t    var arrNum = proc.arrayArgs.indexOf(i)\n\t    switch(proc.argTypes[i]) {\n\t      case \"offset\":\n\t        var offArgIndex = proc.offsetArgIndex.indexOf(i)\n\t        var offArg = proc.offsetArgs[offArgIndex]\n\t        arrNum = offArg.array\n\t        ptrStr = \"+q\" + offArgIndex\n\t      case \"array\":\n\t        ptrStr = \"p\" + arrNum + ptrStr\n\t        var localStr = \"l\" + i\n\t        var arrStr = \"a\" + arrNum\n\t        if(carg.count === 1) {\n\t          if(dtypes[arrNum] === \"generic\") {\n\t            if(carg.lvalue) {\n\t              pre.push([\"var \", localStr, \"=\", arrStr, \".get(\", ptrStr, \")\"].join(\"\"))\n\t              code = code.replace(re, localStr)\n\t              post.push([arrStr, \".set(\", ptrStr, \",\", localStr,\")\"].join(\"\"))\n\t            } else {\n\t              code = code.replace(re, [arrStr, \".get(\", ptrStr, \")\"].join(\"\"))\n\t            }\n\t          } else {\n\t            code = code.replace(re, [arrStr, \"[\", ptrStr, \"]\"].join(\"\"))\n\t          }\n\t        } else if(dtypes[arrNum] === \"generic\") {\n\t          pre.push([\"var \", localStr, \"=\", arrStr, \".get(\", ptrStr, \")\"].join(\"\"))\n\t          code = code.replace(re, localStr)\n\t          if(carg.lvalue) {\n\t            post.push([arrStr, \".set(\", ptrStr, \",\", localStr,\")\"].join(\"\"))\n\t          }\n\t        } else {\n\t          pre.push([\"var \", localStr, \"=\", arrStr, \"[\", ptrStr, \"]\"].join(\"\"))\n\t          code = code.replace(re, localStr)\n\t          if(carg.lvalue) {\n\t            post.push([arrStr, \"[\", ptrStr, \"]=\", localStr].join(\"\"))\n\t          }\n\t        }\n\t      break\n\t      case \"scalar\":\n\t        code = code.replace(re, \"Y\" + proc.scalarArgs.indexOf(i))\n\t      break\n\t      case \"index\":\n\t        code = code.replace(re, \"index\")\n\t      break\n\t      case \"shape\":\n\t        code = code.replace(re, \"shape\")\n\t      break\n\t    }\n\t  }\n\t  return [pre.join(\"\\n\"), code, post.join(\"\\n\")].join(\"\\n\").trim()\n\t}\n\t\n\tfunction typeSummary(dtypes) {\n\t  var summary = new Array(dtypes.length)\n\t  var allEqual = true\n\t  for(var i=0; i<dtypes.length; ++i) {\n\t    var t = dtypes[i]\n\t    var digits = t.match(/\\d+/)\n\t    if(!digits) {\n\t      digits = \"\"\n\t    } else {\n\t      digits = digits[0]\n\t    }\n\t    if(t.charAt(0) === 0) {\n\t      summary[i] = \"u\" + t.charAt(1) + digits\n\t    } else {\n\t      summary[i] = t.charAt(0) + digits\n\t    }\n\t    if(i > 0) {\n\t      allEqual = allEqual && summary[i] === summary[i-1]\n\t    }\n\t  }\n\t  if(allEqual) {\n\t    return summary[0]\n\t  }\n\t  return summary.join(\"\")\n\t}\n\t\n\t//Generates a cwise operator\n\tfunction generateCWiseOp(proc, typesig) {\n\t\n\t  //Compute dimension\n\t  var dimension = typesig[1].length|0\n\t  var orders = new Array(proc.arrayArgs.length)\n\t  var dtypes = new Array(proc.arrayArgs.length)\n\t\n\t  //First create arguments for procedure\n\t  var arglist = [\"SS\"]\n\t  var code = [\"'use strict'\"]\n\t  var vars = []\n\t  \n\t  for(var j=0; j<dimension; ++j) {\n\t    vars.push([\"s\", j, \"=SS[\", j, \"]\"].join(\"\"))\n\t  }\n\t  for(var i=0; i<proc.arrayArgs.length; ++i) {\n\t    arglist.push(\"a\"+i)\n\t    arglist.push(\"t\"+i)\n\t    arglist.push(\"p\"+i)\n\t    dtypes[i] = typesig[2*i]\n\t    orders[i] = typesig[2*i+1]\n\t  }\n\t  for(var i=0; i<proc.scalarArgs.length; ++i) {\n\t    arglist.push(\"Y\" + i)\n\t  }\n\t  if(proc.shapeArgs.length > 0) {\n\t    vars.push(\"shape=SS.slice(0)\")\n\t  }\n\t  if(proc.indexArgs.length > 0) {\n\t    var zeros = new Array(dimension)\n\t    for(var i=0; i<dimension; ++i) {\n\t      zeros[i] = \"0\"\n\t    }\n\t    vars.push([\"index=[\", zeros.join(\",\"), \"]\"].join(\"\"))\n\t  }\n\t  for(var i=0; i<proc.offsetArgs.length; ++i) {\n\t    var off_arg = proc.offsetArgs[i]\n\t    var init_string = []\n\t    for(var j=0; j<off_arg.offset.length; ++j) {\n\t      if(off_arg.offset[j] === 0) {\n\t        continue\n\t      } else if(off_arg.offset[j] === 1) {\n\t        init_string.push([\"t\", off_arg.array, \"[\", j, \"]\"].join(\"\"))      \n\t      } else {\n\t        init_string.push([off_arg.offset[j], \"*t\", off_arg.array, \"[\", j, \"]\"].join(\"\"))\n\t      }\n\t    }\n\t    if(init_string.length === 0) {\n\t      vars.push(\"q\" + i + \"=0\")\n\t    } else {\n\t      vars.push([\"q\", i, \"=(\", init_string.join(\"+\"),\")|0\"].join(\"\"))\n\t    }\n\t  }\n\t\n\t  //Prepare this variables\n\t  var thisVars = uniq([].concat(proc.pre.thisVars)\n\t                      .concat(proc.body.thisVars)\n\t                      .concat(proc.post.thisVars))\n\t  vars = vars.concat(thisVars)\n\t  code.push(\"var \" + vars.join(\",\"))\n\t  for(var i=0; i<proc.arrayArgs.length; ++i) {\n\t    code.push(\"p\"+i+\"|=0\")\n\t  }\n\t  \n\t  //Inline prelude\n\t  if(proc.pre.body.length > 3) {\n\t    code.push(processBlock(proc.pre, proc, dtypes))\n\t  }\n\t\n\t  //Process body\n\t  var body = processBlock(proc.body, proc, dtypes)\n\t  var matched = countMatches(orders)\n\t  if(matched < dimension) {\n\t    code.push(outerFill(matched, orders[0], proc, body))\n\t  } else {\n\t    code.push(innerFill(orders[0], proc, body))\n\t  }\n\t\n\t  //Inline epilog\n\t  if(proc.post.body.length > 3) {\n\t    code.push(processBlock(proc.post, proc, dtypes))\n\t  }\n\t  \n\t  if(proc.debug) {\n\t    console.log(\"Generated cwise routine for \", typesig, \":\\n\\n\", code.join(\"\\n\"))\n\t  }\n\t  \n\t  var loopName = [(proc.funcName||\"unnamed\"), \"_cwise_loop_\", orders[0].join(\"s\"),\"m\",matched,typeSummary(dtypes)].join(\"\")\n\t  var f = new Function([\"function \",loopName,\"(\", arglist.join(\",\"),\"){\", code.join(\"\\n\"),\"} return \", loopName].join(\"\"))\n\t  return f()\n\t}\n\tmodule.exports = generateCWiseOp\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t\"use strict\"\n\t\n\tfunction unique_pred(list, compare) {\n\t  var ptr = 1\n\t    , len = list.length\n\t    , a=list[0], b=list[0]\n\t  for(var i=1; i<len; ++i) {\n\t    b = a\n\t    a = list[i]\n\t    if(compare(a, b)) {\n\t      if(i === ptr) {\n\t        ptr++\n\t        continue\n\t      }\n\t      list[ptr++] = a\n\t    }\n\t  }\n\t  list.length = ptr\n\t  return list\n\t}\n\t\n\tfunction unique_eq(list) {\n\t  var ptr = 1\n\t    , len = list.length\n\t    , a=list[0], b = list[0]\n\t  for(var i=1; i<len; ++i, b=a) {\n\t    b = a\n\t    a = list[i]\n\t    if(a !== b) {\n\t      if(i === ptr) {\n\t        ptr++\n\t        continue\n\t      }\n\t      list[ptr++] = a\n\t    }\n\t  }\n\t  list.length = ptr\n\t  return list\n\t}\n\t\n\tfunction unique(list, compare, sorted) {\n\t  if(list.length === 0) {\n\t    return []\n\t  }\n\t  if(compare) {\n\t    if(!sorted) {\n\t      list.sort(compare)\n\t    }\n\t    return unique_pred(list, compare)\n\t  }\n\t  if(!sorted) {\n\t    list.sort()\n\t  }\n\t  return unique_eq(list)\n\t}\n\t\n\tmodule.exports = unique\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {var Stream = __webpack_require__(23)\n\t\n\t// through\n\t//\n\t// a stream that does nothing but re-emit the input.\n\t// useful for aggregating a series of changing but not ending streams into one stream)\n\t\n\texports = module.exports = through\n\tthrough.through = through\n\t\n\t//create a readable writable stream.\n\t\n\tfunction through (write, end, opts) {\n\t  write = write || function (data) { this.queue(data) }\n\t  end = end || function () { this.queue(null) }\n\t\n\t  var ended = false, destroyed = false, buffer = [], _ended = false\n\t  var stream = new Stream()\n\t  stream.readable = stream.writable = true\n\t  stream.paused = false\n\t\n\t//  stream.autoPause   = !(opts && opts.autoPause   === false)\n\t  stream.autoDestroy = !(opts && opts.autoDestroy === false)\n\t\n\t  stream.write = function (data) {\n\t    write.call(this, data)\n\t    return !stream.paused\n\t  }\n\t\n\t  function drain() {\n\t    while(buffer.length && !stream.paused) {\n\t      var data = buffer.shift()\n\t      if(null === data)\n\t        return stream.emit('end')\n\t      else\n\t        stream.emit('data', data)\n\t    }\n\t  }\n\t\n\t  stream.queue = stream.push = function (data) {\n\t//    console.error(ended)\n\t    if(_ended) return stream\n\t    if(data === null) _ended = true\n\t    buffer.push(data)\n\t    drain()\n\t    return stream\n\t  }\n\t\n\t  //this will be registered as the first 'end' listener\n\t  //must call destroy next tick, to make sure we're after any\n\t  //stream piped from here.\n\t  //this is only a problem if end is not emitted synchronously.\n\t  //a nicer way to do this is to make sure this is the last listener for 'end'\n\t\n\t  stream.on('end', function () {\n\t    stream.readable = false\n\t    if(!stream.writable && stream.autoDestroy)\n\t      process.nextTick(function () {\n\t        stream.destroy()\n\t      })\n\t  })\n\t\n\t  function _end () {\n\t    stream.writable = false\n\t    end.call(stream)\n\t    if(!stream.readable && stream.autoDestroy)\n\t      stream.destroy()\n\t  }\n\t\n\t  stream.end = function (data) {\n\t    if(ended) return\n\t    ended = true\n\t    if(arguments.length) stream.write(data)\n\t    _end() // will emit or queue\n\t    return stream\n\t  }\n\t\n\t  stream.destroy = function () {\n\t    if(destroyed) return\n\t    destroyed = true\n\t    ended = true\n\t    buffer.length = 0\n\t    stream.writable = stream.readable = false\n\t    stream.emit('close')\n\t    return stream\n\t  }\n\t\n\t  stream.pause = function () {\n\t    if(stream.paused) return\n\t    stream.paused = true\n\t    return stream\n\t  }\n\t\n\t  stream.resume = function () {\n\t    if(stream.paused) {\n\t      stream.paused = false\n\t      stream.emit('resume')\n\t    }\n\t    drain()\n\t    //may have become paused again,\n\t    //as drain emits 'data'.\n\t    if(!stream.paused)\n\t      stream.emit('drain')\n\t    return stream\n\t  }\n\t  return stream\n\t}\n\t\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)))\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tmodule.exports = Stream;\n\t\n\tvar EE = __webpack_require__(24).EventEmitter;\n\tvar inherits = __webpack_require__(25);\n\t\n\tinherits(Stream, EE);\n\tStream.Readable = __webpack_require__(26);\n\tStream.Writable = __webpack_require__(36);\n\tStream.Duplex = __webpack_require__(37);\n\tStream.Transform = __webpack_require__(38);\n\tStream.PassThrough = __webpack_require__(39);\n\t\n\t// Backwards-compat with node 0.4.x\n\tStream.Stream = Stream;\n\t\n\t\n\t\n\t// old-style streams.  Note that the pipe method (the only relevant\n\t// part of this class) is overridden in the Readable class.\n\t\n\tfunction Stream() {\n\t  EE.call(this);\n\t}\n\t\n\tStream.prototype.pipe = function(dest, options) {\n\t  var source = this;\n\t\n\t  function ondata(chunk) {\n\t    if (dest.writable) {\n\t      if (false === dest.write(chunk) && source.pause) {\n\t        source.pause();\n\t      }\n\t    }\n\t  }\n\t\n\t  source.on('data', ondata);\n\t\n\t  function ondrain() {\n\t    if (source.readable && source.resume) {\n\t      source.resume();\n\t    }\n\t  }\n\t\n\t  dest.on('drain', ondrain);\n\t\n\t  // If the 'end' option is not supplied, dest.end() will be called when\n\t  // source gets the 'end' or 'close' events.  Only dest.end() once.\n\t  if (!dest._isStdio && (!options || options.end !== false)) {\n\t    source.on('end', onend);\n\t    source.on('close', onclose);\n\t  }\n\t\n\t  var didOnEnd = false;\n\t  function onend() {\n\t    if (didOnEnd) return;\n\t    didOnEnd = true;\n\t\n\t    dest.end();\n\t  }\n\t\n\t\n\t  function onclose() {\n\t    if (didOnEnd) return;\n\t    didOnEnd = true;\n\t\n\t    if (typeof dest.destroy === 'function') dest.destroy();\n\t  }\n\t\n\t  // don't leave dangling pipes when there are errors.\n\t  function onerror(er) {\n\t    cleanup();\n\t    if (EE.listenerCount(this, 'error') === 0) {\n\t      throw er; // Unhandled stream error in pipe.\n\t    }\n\t  }\n\t\n\t  source.on('error', onerror);\n\t  dest.on('error', onerror);\n\t\n\t  // remove all the event listeners that were added.\n\t  function cleanup() {\n\t    source.removeListener('data', ondata);\n\t    dest.removeListener('drain', ondrain);\n\t\n\t    source.removeListener('end', onend);\n\t    source.removeListener('close', onclose);\n\t\n\t    source.removeListener('error', onerror);\n\t    dest.removeListener('error', onerror);\n\t\n\t    source.removeListener('end', cleanup);\n\t    source.removeListener('close', cleanup);\n\t\n\t    dest.removeListener('close', cleanup);\n\t  }\n\t\n\t  source.on('end', cleanup);\n\t  source.on('close', cleanup);\n\t\n\t  dest.on('close', cleanup);\n\t\n\t  dest.emit('pipe', source);\n\t\n\t  // Allow for unix-like usage: A.pipe(B).pipe(C)\n\t  return dest;\n\t};\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tfunction EventEmitter() {\n\t  this._events = this._events || {};\n\t  this._maxListeners = this._maxListeners || undefined;\n\t}\n\tmodule.exports = EventEmitter;\n\t\n\t// Backwards-compat with node 0.10.x\n\tEventEmitter.EventEmitter = EventEmitter;\n\t\n\tEventEmitter.prototype._events = undefined;\n\tEventEmitter.prototype._maxListeners = undefined;\n\t\n\t// By default EventEmitters will print a warning if more than 10 listeners are\n\t// added to it. This is a useful default which helps finding memory leaks.\n\tEventEmitter.defaultMaxListeners = 10;\n\t\n\t// Obviously not all Emitters should be limited to 10. This function allows\n\t// that to be increased. Set to zero for unlimited.\n\tEventEmitter.prototype.setMaxListeners = function(n) {\n\t  if (!isNumber(n) || n < 0 || isNaN(n))\n\t    throw TypeError('n must be a positive number');\n\t  this._maxListeners = n;\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.emit = function(type) {\n\t  var er, handler, len, args, i, listeners;\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // If there is no 'error' event listener then throw.\n\t  if (type === 'error') {\n\t    if (!this._events.error ||\n\t        (isObject(this._events.error) && !this._events.error.length)) {\n\t      er = arguments[1];\n\t      if (er instanceof Error) {\n\t        throw er; // Unhandled 'error' event\n\t      }\n\t      throw TypeError('Uncaught, unspecified \"error\" event.');\n\t    }\n\t  }\n\t\n\t  handler = this._events[type];\n\t\n\t  if (isUndefined(handler))\n\t    return false;\n\t\n\t  if (isFunction(handler)) {\n\t    switch (arguments.length) {\n\t      // fast cases\n\t      case 1:\n\t        handler.call(this);\n\t        break;\n\t      case 2:\n\t        handler.call(this, arguments[1]);\n\t        break;\n\t      case 3:\n\t        handler.call(this, arguments[1], arguments[2]);\n\t        break;\n\t      // slower\n\t      default:\n\t        args = Array.prototype.slice.call(arguments, 1);\n\t        handler.apply(this, args);\n\t    }\n\t  } else if (isObject(handler)) {\n\t    args = Array.prototype.slice.call(arguments, 1);\n\t    listeners = handler.slice();\n\t    len = listeners.length;\n\t    for (i = 0; i < len; i++)\n\t      listeners[i].apply(this, args);\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\tEventEmitter.prototype.addListener = function(type, listener) {\n\t  var m;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // To avoid recursion in the case that type === \"newListener\"! Before\n\t  // adding it to the listeners, first emit \"newListener\".\n\t  if (this._events.newListener)\n\t    this.emit('newListener', type,\n\t              isFunction(listener.listener) ?\n\t              listener.listener : listener);\n\t\n\t  if (!this._events[type])\n\t    // Optimize the case of one listener. Don't need the extra array object.\n\t    this._events[type] = listener;\n\t  else if (isObject(this._events[type]))\n\t    // If we've already got an array, just append.\n\t    this._events[type].push(listener);\n\t  else\n\t    // Adding the second element, need to change to array.\n\t    this._events[type] = [this._events[type], listener];\n\t\n\t  // Check for listener leak\n\t  if (isObject(this._events[type]) && !this._events[type].warned) {\n\t    if (!isUndefined(this._maxListeners)) {\n\t      m = this._maxListeners;\n\t    } else {\n\t      m = EventEmitter.defaultMaxListeners;\n\t    }\n\t\n\t    if (m && m > 0 && this._events[type].length > m) {\n\t      this._events[type].warned = true;\n\t      console.error('(node) warning: possible EventEmitter memory ' +\n\t                    'leak detected. %d listeners added. ' +\n\t                    'Use emitter.setMaxListeners() to increase limit.',\n\t                    this._events[type].length);\n\t      if (typeof console.trace === 'function') {\n\t        // not supported in IE 10\n\t        console.trace();\n\t      }\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\t\n\tEventEmitter.prototype.once = function(type, listener) {\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  var fired = false;\n\t\n\t  function g() {\n\t    this.removeListener(type, g);\n\t\n\t    if (!fired) {\n\t      fired = true;\n\t      listener.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  g.listener = listener;\n\t  this.on(type, g);\n\t\n\t  return this;\n\t};\n\t\n\t// emits a 'removeListener' event iff the listener was removed\n\tEventEmitter.prototype.removeListener = function(type, listener) {\n\t  var list, position, length, i;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events || !this._events[type])\n\t    return this;\n\t\n\t  list = this._events[type];\n\t  length = list.length;\n\t  position = -1;\n\t\n\t  if (list === listener ||\n\t      (isFunction(list.listener) && list.listener === listener)) {\n\t    delete this._events[type];\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t\n\t  } else if (isObject(list)) {\n\t    for (i = length; i-- > 0;) {\n\t      if (list[i] === listener ||\n\t          (list[i].listener && list[i].listener === listener)) {\n\t        position = i;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (position < 0)\n\t      return this;\n\t\n\t    if (list.length === 1) {\n\t      list.length = 0;\n\t      delete this._events[type];\n\t    } else {\n\t      list.splice(position, 1);\n\t    }\n\t\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.removeAllListeners = function(type) {\n\t  var key, listeners;\n\t\n\t  if (!this._events)\n\t    return this;\n\t\n\t  // not listening for removeListener, no need to emit\n\t  if (!this._events.removeListener) {\n\t    if (arguments.length === 0)\n\t      this._events = {};\n\t    else if (this._events[type])\n\t      delete this._events[type];\n\t    return this;\n\t  }\n\t\n\t  // emit removeListener for all listeners on all events\n\t  if (arguments.length === 0) {\n\t    for (key in this._events) {\n\t      if (key === 'removeListener') continue;\n\t      this.removeAllListeners(key);\n\t    }\n\t    this.removeAllListeners('removeListener');\n\t    this._events = {};\n\t    return this;\n\t  }\n\t\n\t  listeners = this._events[type];\n\t\n\t  if (isFunction(listeners)) {\n\t    this.removeListener(type, listeners);\n\t  } else if (listeners) {\n\t    // LIFO order\n\t    while (listeners.length)\n\t      this.removeListener(type, listeners[listeners.length - 1]);\n\t  }\n\t  delete this._events[type];\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.listeners = function(type) {\n\t  var ret;\n\t  if (!this._events || !this._events[type])\n\t    ret = [];\n\t  else if (isFunction(this._events[type]))\n\t    ret = [this._events[type]];\n\t  else\n\t    ret = this._events[type].slice();\n\t  return ret;\n\t};\n\t\n\tEventEmitter.prototype.listenerCount = function(type) {\n\t  if (this._events) {\n\t    var evlistener = this._events[type];\n\t\n\t    if (isFunction(evlistener))\n\t      return 1;\n\t    else if (evlistener)\n\t      return evlistener.length;\n\t  }\n\t  return 0;\n\t};\n\t\n\tEventEmitter.listenerCount = function(emitter, type) {\n\t  return emitter.listenerCount(type);\n\t};\n\t\n\tfunction isFunction(arg) {\n\t  return typeof arg === 'function';\n\t}\n\t\n\tfunction isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\t\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\t\n\tfunction isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\tif (typeof Object.create === 'function') {\n\t  // implementation from standard node.js 'util' module\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor\n\t    ctor.prototype = Object.create(superCtor.prototype, {\n\t      constructor: {\n\t        value: ctor,\n\t        enumerable: false,\n\t        writable: true,\n\t        configurable: true\n\t      }\n\t    });\n\t  };\n\t} else {\n\t  // old school shim for old browsers\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor\n\t    var TempCtor = function () {}\n\t    TempCtor.prototype = superCtor.prototype\n\t    ctor.prototype = new TempCtor()\n\t    ctor.prototype.constructor = ctor\n\t  }\n\t}\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(27);\n\texports.Stream = __webpack_require__(23);\n\texports.Readable = exports;\n\texports.Writable = __webpack_require__(32);\n\texports.Duplex = __webpack_require__(31);\n\texports.Transform = __webpack_require__(34);\n\texports.PassThrough = __webpack_require__(35);\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tmodule.exports = Readable;\n\t\n\t/*<replacement>*/\n\tvar isArray = __webpack_require__(28);\n\t/*</replacement>*/\n\t\n\t\n\t/*<replacement>*/\n\tvar Buffer = __webpack_require__(10).Buffer;\n\t/*</replacement>*/\n\t\n\tReadable.ReadableState = ReadableState;\n\t\n\tvar EE = __webpack_require__(24).EventEmitter;\n\t\n\t/*<replacement>*/\n\tif (!EE.listenerCount) EE.listenerCount = function(emitter, type) {\n\t  return emitter.listeners(type).length;\n\t};\n\t/*</replacement>*/\n\t\n\tvar Stream = __webpack_require__(23);\n\t\n\t/*<replacement>*/\n\tvar util = __webpack_require__(29);\n\tutil.inherits = __webpack_require__(25);\n\t/*</replacement>*/\n\t\n\tvar StringDecoder;\n\t\n\t\n\t/*<replacement>*/\n\tvar debug = __webpack_require__(30);\n\tif (debug && debug.debuglog) {\n\t  debug = debug.debuglog('stream');\n\t} else {\n\t  debug = function () {};\n\t}\n\t/*</replacement>*/\n\t\n\t\n\tutil.inherits(Readable, Stream);\n\t\n\tfunction ReadableState(options, stream) {\n\t  var Duplex = __webpack_require__(31);\n\t\n\t  options = options || {};\n\t\n\t  // the point at which it stops calling _read() to fill the buffer\n\t  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\t  var hwm = options.highWaterMark;\n\t  var defaultHwm = options.objectMode ? 16 : 16 * 1024;\n\t  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\t\n\t  // cast to ints.\n\t  this.highWaterMark = ~~this.highWaterMark;\n\t\n\t  this.buffer = [];\n\t  this.length = 0;\n\t  this.pipes = null;\n\t  this.pipesCount = 0;\n\t  this.flowing = null;\n\t  this.ended = false;\n\t  this.endEmitted = false;\n\t  this.reading = false;\n\t\n\t  // a flag to be able to tell if the onwrite cb is called immediately,\n\t  // or on a later tick.  We set this to true at first, because any\n\t  // actions that shouldn't happen until \"later\" should generally also\n\t  // not happen before the first write call.\n\t  this.sync = true;\n\t\n\t  // whenever we return null, then we set a flag to say\n\t  // that we're awaiting a 'readable' event emission.\n\t  this.needReadable = false;\n\t  this.emittedReadable = false;\n\t  this.readableListening = false;\n\t\n\t\n\t  // object stream flag. Used to make read(n) ignore n and to\n\t  // make all the buffer merging and length checks go away\n\t  this.objectMode = !!options.objectMode;\n\t\n\t  if (stream instanceof Duplex)\n\t    this.objectMode = this.objectMode || !!options.readableObjectMode;\n\t\n\t  // Crypto is kind of old and crusty.  Historically, its default string\n\t  // encoding is 'binary' so we have to make this configurable.\n\t  // Everything else in the universe uses 'utf8', though.\n\t  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\t\n\t  // when piping, we only care about 'readable' events that happen\n\t  // after read()ing all the bytes and not getting any pushback.\n\t  this.ranOut = false;\n\t\n\t  // the number of writers that are awaiting a drain event in .pipe()s\n\t  this.awaitDrain = 0;\n\t\n\t  // if true, a maybeReadMore has been scheduled\n\t  this.readingMore = false;\n\t\n\t  this.decoder = null;\n\t  this.encoding = null;\n\t  if (options.encoding) {\n\t    if (!StringDecoder)\n\t      StringDecoder = __webpack_require__(33).StringDecoder;\n\t    this.decoder = new StringDecoder(options.encoding);\n\t    this.encoding = options.encoding;\n\t  }\n\t}\n\t\n\tfunction Readable(options) {\n\t  var Duplex = __webpack_require__(31);\n\t\n\t  if (!(this instanceof Readable))\n\t    return new Readable(options);\n\t\n\t  this._readableState = new ReadableState(options, this);\n\t\n\t  // legacy\n\t  this.readable = true;\n\t\n\t  Stream.call(this);\n\t}\n\t\n\t// Manually shove something into the read() buffer.\n\t// This returns true if the highWaterMark has not been hit yet,\n\t// similar to how Writable.write() returns true if you should\n\t// write() some more.\n\tReadable.prototype.push = function(chunk, encoding) {\n\t  var state = this._readableState;\n\t\n\t  if (util.isString(chunk) && !state.objectMode) {\n\t    encoding = encoding || state.defaultEncoding;\n\t    if (encoding !== state.encoding) {\n\t      chunk = new Buffer(chunk, encoding);\n\t      encoding = '';\n\t    }\n\t  }\n\t\n\t  return readableAddChunk(this, state, chunk, encoding, false);\n\t};\n\t\n\t// Unshift should *always* be something directly out of read()\n\tReadable.prototype.unshift = function(chunk) {\n\t  var state = this._readableState;\n\t  return readableAddChunk(this, state, chunk, '', true);\n\t};\n\t\n\tfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n\t  var er = chunkInvalid(state, chunk);\n\t  if (er) {\n\t    stream.emit('error', er);\n\t  } else if (util.isNullOrUndefined(chunk)) {\n\t    state.reading = false;\n\t    if (!state.ended)\n\t      onEofChunk(stream, state);\n\t  } else if (state.objectMode || chunk && chunk.length > 0) {\n\t    if (state.ended && !addToFront) {\n\t      var e = new Error('stream.push() after EOF');\n\t      stream.emit('error', e);\n\t    } else if (state.endEmitted && addToFront) {\n\t      var e = new Error('stream.unshift() after end event');\n\t      stream.emit('error', e);\n\t    } else {\n\t      if (state.decoder && !addToFront && !encoding)\n\t        chunk = state.decoder.write(chunk);\n\t\n\t      if (!addToFront)\n\t        state.reading = false;\n\t\n\t      // if we want the data now, just emit it.\n\t      if (state.flowing && state.length === 0 && !state.sync) {\n\t        stream.emit('data', chunk);\n\t        stream.read(0);\n\t      } else {\n\t        // update the buffer info.\n\t        state.length += state.objectMode ? 1 : chunk.length;\n\t        if (addToFront)\n\t          state.buffer.unshift(chunk);\n\t        else\n\t          state.buffer.push(chunk);\n\t\n\t        if (state.needReadable)\n\t          emitReadable(stream);\n\t      }\n\t\n\t      maybeReadMore(stream, state);\n\t    }\n\t  } else if (!addToFront) {\n\t    state.reading = false;\n\t  }\n\t\n\t  return needMoreData(state);\n\t}\n\t\n\t\n\t\n\t// if it's past the high water mark, we can push in some more.\n\t// Also, if we have no data yet, we can stand some\n\t// more bytes.  This is to work around cases where hwm=0,\n\t// such as the repl.  Also, if the push() triggered a\n\t// readable event, and the user called read(largeNumber) such that\n\t// needReadable was set, then we ought to push more, so that another\n\t// 'readable' event will be triggered.\n\tfunction needMoreData(state) {\n\t  return !state.ended &&\n\t         (state.needReadable ||\n\t          state.length < state.highWaterMark ||\n\t          state.length === 0);\n\t}\n\t\n\t// backwards compatibility.\n\tReadable.prototype.setEncoding = function(enc) {\n\t  if (!StringDecoder)\n\t    StringDecoder = __webpack_require__(33).StringDecoder;\n\t  this._readableState.decoder = new StringDecoder(enc);\n\t  this._readableState.encoding = enc;\n\t  return this;\n\t};\n\t\n\t// Don't raise the hwm > 128MB\n\tvar MAX_HWM = 0x800000;\n\tfunction roundUpToNextPowerOf2(n) {\n\t  if (n >= MAX_HWM) {\n\t    n = MAX_HWM;\n\t  } else {\n\t    // Get the next highest power of 2\n\t    n--;\n\t    for (var p = 1; p < 32; p <<= 1) n |= n >> p;\n\t    n++;\n\t  }\n\t  return n;\n\t}\n\t\n\tfunction howMuchToRead(n, state) {\n\t  if (state.length === 0 && state.ended)\n\t    return 0;\n\t\n\t  if (state.objectMode)\n\t    return n === 0 ? 0 : 1;\n\t\n\t  if (isNaN(n) || util.isNull(n)) {\n\t    // only flow one buffer at a time\n\t    if (state.flowing && state.buffer.length)\n\t      return state.buffer[0].length;\n\t    else\n\t      return state.length;\n\t  }\n\t\n\t  if (n <= 0)\n\t    return 0;\n\t\n\t  // If we're asking for more than the target buffer level,\n\t  // then raise the water mark.  Bump up to the next highest\n\t  // power of 2, to prevent increasing it excessively in tiny\n\t  // amounts.\n\t  if (n > state.highWaterMark)\n\t    state.highWaterMark = roundUpToNextPowerOf2(n);\n\t\n\t  // don't have that much.  return null, unless we've ended.\n\t  if (n > state.length) {\n\t    if (!state.ended) {\n\t      state.needReadable = true;\n\t      return 0;\n\t    } else\n\t      return state.length;\n\t  }\n\t\n\t  return n;\n\t}\n\t\n\t// you can override either this method, or the async _read(n) below.\n\tReadable.prototype.read = function(n) {\n\t  debug('read', n);\n\t  var state = this._readableState;\n\t  var nOrig = n;\n\t\n\t  if (!util.isNumber(n) || n > 0)\n\t    state.emittedReadable = false;\n\t\n\t  // if we're doing read(0) to trigger a readable event, but we\n\t  // already have a bunch of data in the buffer, then just trigger\n\t  // the 'readable' event and move on.\n\t  if (n === 0 &&\n\t      state.needReadable &&\n\t      (state.length >= state.highWaterMark || state.ended)) {\n\t    debug('read: emitReadable', state.length, state.ended);\n\t    if (state.length === 0 && state.ended)\n\t      endReadable(this);\n\t    else\n\t      emitReadable(this);\n\t    return null;\n\t  }\n\t\n\t  n = howMuchToRead(n, state);\n\t\n\t  // if we've ended, and we're now clear, then finish it up.\n\t  if (n === 0 && state.ended) {\n\t    if (state.length === 0)\n\t      endReadable(this);\n\t    return null;\n\t  }\n\t\n\t  // All the actual chunk generation logic needs to be\n\t  // *below* the call to _read.  The reason is that in certain\n\t  // synthetic stream cases, such as passthrough streams, _read\n\t  // may be a completely synchronous operation which may change\n\t  // the state of the read buffer, providing enough data when\n\t  // before there was *not* enough.\n\t  //\n\t  // So, the steps are:\n\t  // 1. Figure out what the state of things will be after we do\n\t  // a read from the buffer.\n\t  //\n\t  // 2. If that resulting state will trigger a _read, then call _read.\n\t  // Note that this may be asynchronous, or synchronous.  Yes, it is\n\t  // deeply ugly to write APIs this way, but that still doesn't mean\n\t  // that the Readable class should behave improperly, as streams are\n\t  // designed to be sync/async agnostic.\n\t  // Take note if the _read call is sync or async (ie, if the read call\n\t  // has returned yet), so that we know whether or not it's safe to emit\n\t  // 'readable' etc.\n\t  //\n\t  // 3. Actually pull the requested chunks out of the buffer and return.\n\t\n\t  // if we need a readable event, then we need to do some reading.\n\t  var doRead = state.needReadable;\n\t  debug('need readable', doRead);\n\t\n\t  // if we currently have less than the highWaterMark, then also read some\n\t  if (state.length === 0 || state.length - n < state.highWaterMark) {\n\t    doRead = true;\n\t    debug('length less than watermark', doRead);\n\t  }\n\t\n\t  // however, if we've ended, then there's no point, and if we're already\n\t  // reading, then it's unnecessary.\n\t  if (state.ended || state.reading) {\n\t    doRead = false;\n\t    debug('reading or ended', doRead);\n\t  }\n\t\n\t  if (doRead) {\n\t    debug('do read');\n\t    state.reading = true;\n\t    state.sync = true;\n\t    // if the length is currently zero, then we *need* a readable event.\n\t    if (state.length === 0)\n\t      state.needReadable = true;\n\t    // call internal read method\n\t    this._read(state.highWaterMark);\n\t    state.sync = false;\n\t  }\n\t\n\t  // If _read pushed data synchronously, then `reading` will be false,\n\t  // and we need to re-evaluate how much data we can return to the user.\n\t  if (doRead && !state.reading)\n\t    n = howMuchToRead(nOrig, state);\n\t\n\t  var ret;\n\t  if (n > 0)\n\t    ret = fromList(n, state);\n\t  else\n\t    ret = null;\n\t\n\t  if (util.isNull(ret)) {\n\t    state.needReadable = true;\n\t    n = 0;\n\t  }\n\t\n\t  state.length -= n;\n\t\n\t  // If we have nothing in the buffer, then we want to know\n\t  // as soon as we *do* get something into the buffer.\n\t  if (state.length === 0 && !state.ended)\n\t    state.needReadable = true;\n\t\n\t  // If we tried to read() past the EOF, then emit end on the next tick.\n\t  if (nOrig !== n && state.ended && state.length === 0)\n\t    endReadable(this);\n\t\n\t  if (!util.isNull(ret))\n\t    this.emit('data', ret);\n\t\n\t  return ret;\n\t};\n\t\n\tfunction chunkInvalid(state, chunk) {\n\t  var er = null;\n\t  if (!util.isBuffer(chunk) &&\n\t      !util.isString(chunk) &&\n\t      !util.isNullOrUndefined(chunk) &&\n\t      !state.objectMode) {\n\t    er = new TypeError('Invalid non-string/buffer chunk');\n\t  }\n\t  return er;\n\t}\n\t\n\t\n\tfunction onEofChunk(stream, state) {\n\t  if (state.decoder && !state.ended) {\n\t    var chunk = state.decoder.end();\n\t    if (chunk && chunk.length) {\n\t      state.buffer.push(chunk);\n\t      state.length += state.objectMode ? 1 : chunk.length;\n\t    }\n\t  }\n\t  state.ended = true;\n\t\n\t  // emit 'readable' now to make sure it gets picked up.\n\t  emitReadable(stream);\n\t}\n\t\n\t// Don't emit readable right away in sync mode, because this can trigger\n\t// another read() call => stack overflow.  This way, it might trigger\n\t// a nextTick recursion warning, but that's not so bad.\n\tfunction emitReadable(stream) {\n\t  var state = stream._readableState;\n\t  state.needReadable = false;\n\t  if (!state.emittedReadable) {\n\t    debug('emitReadable', state.flowing);\n\t    state.emittedReadable = true;\n\t    if (state.sync)\n\t      process.nextTick(function() {\n\t        emitReadable_(stream);\n\t      });\n\t    else\n\t      emitReadable_(stream);\n\t  }\n\t}\n\t\n\tfunction emitReadable_(stream) {\n\t  debug('emit readable');\n\t  stream.emit('readable');\n\t  flow(stream);\n\t}\n\t\n\t\n\t// at this point, the user has presumably seen the 'readable' event,\n\t// and called read() to consume some data.  that may have triggered\n\t// in turn another _read(n) call, in which case reading = true if\n\t// it's in progress.\n\t// However, if we're not ended, or reading, and the length < hwm,\n\t// then go ahead and try to read some more preemptively.\n\tfunction maybeReadMore(stream, state) {\n\t  if (!state.readingMore) {\n\t    state.readingMore = true;\n\t    process.nextTick(function() {\n\t      maybeReadMore_(stream, state);\n\t    });\n\t  }\n\t}\n\t\n\tfunction maybeReadMore_(stream, state) {\n\t  var len = state.length;\n\t  while (!state.reading && !state.flowing && !state.ended &&\n\t         state.length < state.highWaterMark) {\n\t    debug('maybeReadMore read 0');\n\t    stream.read(0);\n\t    if (len === state.length)\n\t      // didn't get any data, stop spinning.\n\t      break;\n\t    else\n\t      len = state.length;\n\t  }\n\t  state.readingMore = false;\n\t}\n\t\n\t// abstract method.  to be overridden in specific implementation classes.\n\t// call cb(er, data) where data is <= n in length.\n\t// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n\t// arbitrary, and perhaps not very meaningful.\n\tReadable.prototype._read = function(n) {\n\t  this.emit('error', new Error('not implemented'));\n\t};\n\t\n\tReadable.prototype.pipe = function(dest, pipeOpts) {\n\t  var src = this;\n\t  var state = this._readableState;\n\t\n\t  switch (state.pipesCount) {\n\t    case 0:\n\t      state.pipes = dest;\n\t      break;\n\t    case 1:\n\t      state.pipes = [state.pipes, dest];\n\t      break;\n\t    default:\n\t      state.pipes.push(dest);\n\t      break;\n\t  }\n\t  state.pipesCount += 1;\n\t  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\t\n\t  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n\t              dest !== process.stdout &&\n\t              dest !== process.stderr;\n\t\n\t  var endFn = doEnd ? onend : cleanup;\n\t  if (state.endEmitted)\n\t    process.nextTick(endFn);\n\t  else\n\t    src.once('end', endFn);\n\t\n\t  dest.on('unpipe', onunpipe);\n\t  function onunpipe(readable) {\n\t    debug('onunpipe');\n\t    if (readable === src) {\n\t      cleanup();\n\t    }\n\t  }\n\t\n\t  function onend() {\n\t    debug('onend');\n\t    dest.end();\n\t  }\n\t\n\t  // when the dest drains, it reduces the awaitDrain counter\n\t  // on the source.  This would be more elegant with a .once()\n\t  // handler in flow(), but adding and removing repeatedly is\n\t  // too slow.\n\t  var ondrain = pipeOnDrain(src);\n\t  dest.on('drain', ondrain);\n\t\n\t  function cleanup() {\n\t    debug('cleanup');\n\t    // cleanup event handlers once the pipe is broken\n\t    dest.removeListener('close', onclose);\n\t    dest.removeListener('finish', onfinish);\n\t    dest.removeListener('drain', ondrain);\n\t    dest.removeListener('error', onerror);\n\t    dest.removeListener('unpipe', onunpipe);\n\t    src.removeListener('end', onend);\n\t    src.removeListener('end', cleanup);\n\t    src.removeListener('data', ondata);\n\t\n\t    // if the reader is waiting for a drain event from this\n\t    // specific writer, then it would cause it to never start\n\t    // flowing again.\n\t    // So, if this is awaiting a drain, then we just call it now.\n\t    // If we don't know, then assume that we are waiting for one.\n\t    if (state.awaitDrain &&\n\t        (!dest._writableState || dest._writableState.needDrain))\n\t      ondrain();\n\t  }\n\t\n\t  src.on('data', ondata);\n\t  function ondata(chunk) {\n\t    debug('ondata');\n\t    var ret = dest.write(chunk);\n\t    if (false === ret) {\n\t      debug('false write response, pause',\n\t            src._readableState.awaitDrain);\n\t      src._readableState.awaitDrain++;\n\t      src.pause();\n\t    }\n\t  }\n\t\n\t  // if the dest has an error, then stop piping into it.\n\t  // however, don't suppress the throwing behavior for this.\n\t  function onerror(er) {\n\t    debug('onerror', er);\n\t    unpipe();\n\t    dest.removeListener('error', onerror);\n\t    if (EE.listenerCount(dest, 'error') === 0)\n\t      dest.emit('error', er);\n\t  }\n\t  // This is a brutally ugly hack to make sure that our error handler\n\t  // is attached before any userland ones.  NEVER DO THIS.\n\t  if (!dest._events || !dest._events.error)\n\t    dest.on('error', onerror);\n\t  else if (isArray(dest._events.error))\n\t    dest._events.error.unshift(onerror);\n\t  else\n\t    dest._events.error = [onerror, dest._events.error];\n\t\n\t\n\t\n\t  // Both close and finish should trigger unpipe, but only once.\n\t  function onclose() {\n\t    dest.removeListener('finish', onfinish);\n\t    unpipe();\n\t  }\n\t  dest.once('close', onclose);\n\t  function onfinish() {\n\t    debug('onfinish');\n\t    dest.removeListener('close', onclose);\n\t    unpipe();\n\t  }\n\t  dest.once('finish', onfinish);\n\t\n\t  function unpipe() {\n\t    debug('unpipe');\n\t    src.unpipe(dest);\n\t  }\n\t\n\t  // tell the dest that it's being piped to\n\t  dest.emit('pipe', src);\n\t\n\t  // start the flow if it hasn't been started already.\n\t  if (!state.flowing) {\n\t    debug('pipe resume');\n\t    src.resume();\n\t  }\n\t\n\t  return dest;\n\t};\n\t\n\tfunction pipeOnDrain(src) {\n\t  return function() {\n\t    var state = src._readableState;\n\t    debug('pipeOnDrain', state.awaitDrain);\n\t    if (state.awaitDrain)\n\t      state.awaitDrain--;\n\t    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {\n\t      state.flowing = true;\n\t      flow(src);\n\t    }\n\t  };\n\t}\n\t\n\t\n\tReadable.prototype.unpipe = function(dest) {\n\t  var state = this._readableState;\n\t\n\t  // if we're not piping anywhere, then do nothing.\n\t  if (state.pipesCount === 0)\n\t    return this;\n\t\n\t  // just one destination.  most common case.\n\t  if (state.pipesCount === 1) {\n\t    // passed in one, but it's not the right one.\n\t    if (dest && dest !== state.pipes)\n\t      return this;\n\t\n\t    if (!dest)\n\t      dest = state.pipes;\n\t\n\t    // got a match.\n\t    state.pipes = null;\n\t    state.pipesCount = 0;\n\t    state.flowing = false;\n\t    if (dest)\n\t      dest.emit('unpipe', this);\n\t    return this;\n\t  }\n\t\n\t  // slow case. multiple pipe destinations.\n\t\n\t  if (!dest) {\n\t    // remove all.\n\t    var dests = state.pipes;\n\t    var len = state.pipesCount;\n\t    state.pipes = null;\n\t    state.pipesCount = 0;\n\t    state.flowing = false;\n\t\n\t    for (var i = 0; i < len; i++)\n\t      dests[i].emit('unpipe', this);\n\t    return this;\n\t  }\n\t\n\t  // try to find the right one.\n\t  var i = indexOf(state.pipes, dest);\n\t  if (i === -1)\n\t    return this;\n\t\n\t  state.pipes.splice(i, 1);\n\t  state.pipesCount -= 1;\n\t  if (state.pipesCount === 1)\n\t    state.pipes = state.pipes[0];\n\t\n\t  dest.emit('unpipe', this);\n\t\n\t  return this;\n\t};\n\t\n\t// set up data events if they are asked for\n\t// Ensure readable listeners eventually get something\n\tReadable.prototype.on = function(ev, fn) {\n\t  var res = Stream.prototype.on.call(this, ev, fn);\n\t\n\t  // If listening to data, and it has not explicitly been paused,\n\t  // then call resume to start the flow of data on the next tick.\n\t  if (ev === 'data' && false !== this._readableState.flowing) {\n\t    this.resume();\n\t  }\n\t\n\t  if (ev === 'readable' && this.readable) {\n\t    var state = this._readableState;\n\t    if (!state.readableListening) {\n\t      state.readableListening = true;\n\t      state.emittedReadable = false;\n\t      state.needReadable = true;\n\t      if (!state.reading) {\n\t        var self = this;\n\t        process.nextTick(function() {\n\t          debug('readable nexttick read 0');\n\t          self.read(0);\n\t        });\n\t      } else if (state.length) {\n\t        emitReadable(this, state);\n\t      }\n\t    }\n\t  }\n\t\n\t  return res;\n\t};\n\tReadable.prototype.addListener = Readable.prototype.on;\n\t\n\t// pause() and resume() are remnants of the legacy readable stream API\n\t// If the user uses them, then switch into old mode.\n\tReadable.prototype.resume = function() {\n\t  var state = this._readableState;\n\t  if (!state.flowing) {\n\t    debug('resume');\n\t    state.flowing = true;\n\t    if (!state.reading) {\n\t      debug('resume read 0');\n\t      this.read(0);\n\t    }\n\t    resume(this, state);\n\t  }\n\t  return this;\n\t};\n\t\n\tfunction resume(stream, state) {\n\t  if (!state.resumeScheduled) {\n\t    state.resumeScheduled = true;\n\t    process.nextTick(function() {\n\t      resume_(stream, state);\n\t    });\n\t  }\n\t}\n\t\n\tfunction resume_(stream, state) {\n\t  state.resumeScheduled = false;\n\t  stream.emit('resume');\n\t  flow(stream);\n\t  if (state.flowing && !state.reading)\n\t    stream.read(0);\n\t}\n\t\n\tReadable.prototype.pause = function() {\n\t  debug('call pause flowing=%j', this._readableState.flowing);\n\t  if (false !== this._readableState.flowing) {\n\t    debug('pause');\n\t    this._readableState.flowing = false;\n\t    this.emit('pause');\n\t  }\n\t  return this;\n\t};\n\t\n\tfunction flow(stream) {\n\t  var state = stream._readableState;\n\t  debug('flow', state.flowing);\n\t  if (state.flowing) {\n\t    do {\n\t      var chunk = stream.read();\n\t    } while (null !== chunk && state.flowing);\n\t  }\n\t}\n\t\n\t// wrap an old-style stream as the async data source.\n\t// This is *not* part of the readable stream interface.\n\t// It is an ugly unfortunate mess of history.\n\tReadable.prototype.wrap = function(stream) {\n\t  var state = this._readableState;\n\t  var paused = false;\n\t\n\t  var self = this;\n\t  stream.on('end', function() {\n\t    debug('wrapped end');\n\t    if (state.decoder && !state.ended) {\n\t      var chunk = state.decoder.end();\n\t      if (chunk && chunk.length)\n\t        self.push(chunk);\n\t    }\n\t\n\t    self.push(null);\n\t  });\n\t\n\t  stream.on('data', function(chunk) {\n\t    debug('wrapped data');\n\t    if (state.decoder)\n\t      chunk = state.decoder.write(chunk);\n\t    if (!chunk || !state.objectMode && !chunk.length)\n\t      return;\n\t\n\t    var ret = self.push(chunk);\n\t    if (!ret) {\n\t      paused = true;\n\t      stream.pause();\n\t    }\n\t  });\n\t\n\t  // proxy all the other methods.\n\t  // important when wrapping filters and duplexes.\n\t  for (var i in stream) {\n\t    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {\n\t      this[i] = function(method) { return function() {\n\t        return stream[method].apply(stream, arguments);\n\t      }}(i);\n\t    }\n\t  }\n\t\n\t  // proxy certain important events.\n\t  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n\t  forEach(events, function(ev) {\n\t    stream.on(ev, self.emit.bind(self, ev));\n\t  });\n\t\n\t  // when we try to consume some more bytes, simply unpause the\n\t  // underlying stream.\n\t  self._read = function(n) {\n\t    debug('wrapped _read', n);\n\t    if (paused) {\n\t      paused = false;\n\t      stream.resume();\n\t    }\n\t  };\n\t\n\t  return self;\n\t};\n\t\n\t\n\t\n\t// exposed for testing purposes only.\n\tReadable._fromList = fromList;\n\t\n\t// Pluck off n bytes from an array of buffers.\n\t// Length is the combined lengths of all the buffers in the list.\n\tfunction fromList(n, state) {\n\t  var list = state.buffer;\n\t  var length = state.length;\n\t  var stringMode = !!state.decoder;\n\t  var objectMode = !!state.objectMode;\n\t  var ret;\n\t\n\t  // nothing in the list, definitely empty.\n\t  if (list.length === 0)\n\t    return null;\n\t\n\t  if (length === 0)\n\t    ret = null;\n\t  else if (objectMode)\n\t    ret = list.shift();\n\t  else if (!n || n >= length) {\n\t    // read it all, truncate the array.\n\t    if (stringMode)\n\t      ret = list.join('');\n\t    else\n\t      ret = Buffer.concat(list, length);\n\t    list.length = 0;\n\t  } else {\n\t    // read just some of it.\n\t    if (n < list[0].length) {\n\t      // just take a part of the first list item.\n\t      // slice is the same for buffers and strings.\n\t      var buf = list[0];\n\t      ret = buf.slice(0, n);\n\t      list[0] = buf.slice(n);\n\t    } else if (n === list[0].length) {\n\t      // first list is a perfect match\n\t      ret = list.shift();\n\t    } else {\n\t      // complex case.\n\t      // we have enough to cover it, but it spans past the first buffer.\n\t      if (stringMode)\n\t        ret = '';\n\t      else\n\t        ret = new Buffer(n);\n\t\n\t      var c = 0;\n\t      for (var i = 0, l = list.length; i < l && c < n; i++) {\n\t        var buf = list[0];\n\t        var cpy = Math.min(n - c, buf.length);\n\t\n\t        if (stringMode)\n\t          ret += buf.slice(0, cpy);\n\t        else\n\t          buf.copy(ret, c, 0, cpy);\n\t\n\t        if (cpy < buf.length)\n\t          list[0] = buf.slice(cpy);\n\t        else\n\t          list.shift();\n\t\n\t        c += cpy;\n\t      }\n\t    }\n\t  }\n\t\n\t  return ret;\n\t}\n\t\n\tfunction endReadable(stream) {\n\t  var state = stream._readableState;\n\t\n\t  // If we get here before consuming all the bytes, then that is a\n\t  // bug in node.  Should never happen.\n\t  if (state.length > 0)\n\t    throw new Error('endReadable called on non-empty stream');\n\t\n\t  if (!state.endEmitted) {\n\t    state.ended = true;\n\t    process.nextTick(function() {\n\t      // Check that we didn't get one last unshift.\n\t      if (!state.endEmitted && state.length === 0) {\n\t        state.endEmitted = true;\n\t        stream.readable = false;\n\t        stream.emit('end');\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\tfunction forEach (xs, f) {\n\t  for (var i = 0, l = xs.length; i < l; i++) {\n\t    f(xs[i], i);\n\t  }\n\t}\n\t\n\tfunction indexOf (xs, x) {\n\t  for (var i = 0, l = xs.length; i < l; i++) {\n\t    if (xs[i] === x) return i;\n\t  }\n\t  return -1;\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)))\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\n\tmodule.exports = Array.isArray || function (arr) {\n\t  return Object.prototype.toString.call(arr) == '[object Array]';\n\t};\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\t// NOTE: These type checking functions intentionally don't use `instanceof`\n\t// because it is fragile and can be easily faked with `Object.create()`.\n\t\n\tfunction isArray(arg) {\n\t  if (Array.isArray) {\n\t    return Array.isArray(arg);\n\t  }\n\t  return objectToString(arg) === '[object Array]';\n\t}\n\texports.isArray = isArray;\n\t\n\tfunction isBoolean(arg) {\n\t  return typeof arg === 'boolean';\n\t}\n\texports.isBoolean = isBoolean;\n\t\n\tfunction isNull(arg) {\n\t  return arg === null;\n\t}\n\texports.isNull = isNull;\n\t\n\tfunction isNullOrUndefined(arg) {\n\t  return arg == null;\n\t}\n\texports.isNullOrUndefined = isNullOrUndefined;\n\t\n\tfunction isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\texports.isNumber = isNumber;\n\t\n\tfunction isString(arg) {\n\t  return typeof arg === 'string';\n\t}\n\texports.isString = isString;\n\t\n\tfunction isSymbol(arg) {\n\t  return typeof arg === 'symbol';\n\t}\n\texports.isSymbol = isSymbol;\n\t\n\tfunction isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\texports.isUndefined = isUndefined;\n\t\n\tfunction isRegExp(re) {\n\t  return objectToString(re) === '[object RegExp]';\n\t}\n\texports.isRegExp = isRegExp;\n\t\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\texports.isObject = isObject;\n\t\n\tfunction isDate(d) {\n\t  return objectToString(d) === '[object Date]';\n\t}\n\texports.isDate = isDate;\n\t\n\tfunction isError(e) {\n\t  return (objectToString(e) === '[object Error]' || e instanceof Error);\n\t}\n\texports.isError = isError;\n\t\n\tfunction isFunction(arg) {\n\t  return typeof arg === 'function';\n\t}\n\texports.isFunction = isFunction;\n\t\n\tfunction isPrimitive(arg) {\n\t  return arg === null ||\n\t         typeof arg === 'boolean' ||\n\t         typeof arg === 'number' ||\n\t         typeof arg === 'string' ||\n\t         typeof arg === 'symbol' ||  // ES6 symbol\n\t         typeof arg === 'undefined';\n\t}\n\texports.isPrimitive = isPrimitive;\n\t\n\texports.isBuffer = Buffer.isBuffer;\n\t\n\tfunction objectToString(o) {\n\t  return Object.prototype.toString.call(o);\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10).Buffer))\n\n/***/ },\n/* 30 */\n/***/ function(module, exports) {\n\n\t/* (ignored) */\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\t// a duplex stream is just a stream that is both readable and writable.\n\t// Since JS doesn't have multiple prototypal inheritance, this class\n\t// prototypally inherits from Readable, and then parasitically from\n\t// Writable.\n\t\n\tmodule.exports = Duplex;\n\t\n\t/*<replacement>*/\n\tvar objectKeys = Object.keys || function (obj) {\n\t  var keys = [];\n\t  for (var key in obj) keys.push(key);\n\t  return keys;\n\t}\n\t/*</replacement>*/\n\t\n\t\n\t/*<replacement>*/\n\tvar util = __webpack_require__(29);\n\tutil.inherits = __webpack_require__(25);\n\t/*</replacement>*/\n\t\n\tvar Readable = __webpack_require__(27);\n\tvar Writable = __webpack_require__(32);\n\t\n\tutil.inherits(Duplex, Readable);\n\t\n\tforEach(objectKeys(Writable.prototype), function(method) {\n\t  if (!Duplex.prototype[method])\n\t    Duplex.prototype[method] = Writable.prototype[method];\n\t});\n\t\n\tfunction Duplex(options) {\n\t  if (!(this instanceof Duplex))\n\t    return new Duplex(options);\n\t\n\t  Readable.call(this, options);\n\t  Writable.call(this, options);\n\t\n\t  if (options && options.readable === false)\n\t    this.readable = false;\n\t\n\t  if (options && options.writable === false)\n\t    this.writable = false;\n\t\n\t  this.allowHalfOpen = true;\n\t  if (options && options.allowHalfOpen === false)\n\t    this.allowHalfOpen = false;\n\t\n\t  this.once('end', onend);\n\t}\n\t\n\t// the no-half-open enforcer\n\tfunction onend() {\n\t  // if we allow half-open state, or if the writable side ended,\n\t  // then we're ok.\n\t  if (this.allowHalfOpen || this._writableState.ended)\n\t    return;\n\t\n\t  // no more data can be written.\n\t  // But allow more writes to happen in this tick.\n\t  process.nextTick(this.end.bind(this));\n\t}\n\t\n\tfunction forEach (xs, f) {\n\t  for (var i = 0, l = xs.length; i < l; i++) {\n\t    f(xs[i], i);\n\t  }\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)))\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\t// A bit simpler than readable streams.\n\t// Implement an async ._write(chunk, cb), and it'll handle all\n\t// the drain event emission and buffering.\n\t\n\tmodule.exports = Writable;\n\t\n\t/*<replacement>*/\n\tvar Buffer = __webpack_require__(10).Buffer;\n\t/*</replacement>*/\n\t\n\tWritable.WritableState = WritableState;\n\t\n\t\n\t/*<replacement>*/\n\tvar util = __webpack_require__(29);\n\tutil.inherits = __webpack_require__(25);\n\t/*</replacement>*/\n\t\n\tvar Stream = __webpack_require__(23);\n\t\n\tutil.inherits(Writable, Stream);\n\t\n\tfunction WriteReq(chunk, encoding, cb) {\n\t  this.chunk = chunk;\n\t  this.encoding = encoding;\n\t  this.callback = cb;\n\t}\n\t\n\tfunction WritableState(options, stream) {\n\t  var Duplex = __webpack_require__(31);\n\t\n\t  options = options || {};\n\t\n\t  // the point at which write() starts returning false\n\t  // Note: 0 is a valid value, means that we always return false if\n\t  // the entire buffer is not flushed immediately on write()\n\t  var hwm = options.highWaterMark;\n\t  var defaultHwm = options.objectMode ? 16 : 16 * 1024;\n\t  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\t\n\t  // object stream flag to indicate whether or not this stream\n\t  // contains buffers or objects.\n\t  this.objectMode = !!options.objectMode;\n\t\n\t  if (stream instanceof Duplex)\n\t    this.objectMode = this.objectMode || !!options.writableObjectMode;\n\t\n\t  // cast to ints.\n\t  this.highWaterMark = ~~this.highWaterMark;\n\t\n\t  this.needDrain = false;\n\t  // at the start of calling end()\n\t  this.ending = false;\n\t  // when end() has been called, and returned\n\t  this.ended = false;\n\t  // when 'finish' is emitted\n\t  this.finished = false;\n\t\n\t  // should we decode strings into buffers before passing to _write?\n\t  // this is here so that some node-core streams can optimize string\n\t  // handling at a lower level.\n\t  var noDecode = options.decodeStrings === false;\n\t  this.decodeStrings = !noDecode;\n\t\n\t  // Crypto is kind of old and crusty.  Historically, its default string\n\t  // encoding is 'binary' so we have to make this configurable.\n\t  // Everything else in the universe uses 'utf8', though.\n\t  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\t\n\t  // not an actual buffer we keep track of, but a measurement\n\t  // of how much we're waiting to get pushed to some underlying\n\t  // socket or file.\n\t  this.length = 0;\n\t\n\t  // a flag to see when we're in the middle of a write.\n\t  this.writing = false;\n\t\n\t  // when true all writes will be buffered until .uncork() call\n\t  this.corked = 0;\n\t\n\t  // a flag to be able to tell if the onwrite cb is called immediately,\n\t  // or on a later tick.  We set this to true at first, because any\n\t  // actions that shouldn't happen until \"later\" should generally also\n\t  // not happen before the first write call.\n\t  this.sync = true;\n\t\n\t  // a flag to know if we're processing previously buffered items, which\n\t  // may call the _write() callback in the same tick, so that we don't\n\t  // end up in an overlapped onwrite situation.\n\t  this.bufferProcessing = false;\n\t\n\t  // the callback that's passed to _write(chunk,cb)\n\t  this.onwrite = function(er) {\n\t    onwrite(stream, er);\n\t  };\n\t\n\t  // the callback that the user supplies to write(chunk,encoding,cb)\n\t  this.writecb = null;\n\t\n\t  // the amount that is being written when _write is called.\n\t  this.writelen = 0;\n\t\n\t  this.buffer = [];\n\t\n\t  // number of pending user-supplied write callbacks\n\t  // this must be 0 before 'finish' can be emitted\n\t  this.pendingcb = 0;\n\t\n\t  // emit prefinish if the only thing we're waiting for is _write cbs\n\t  // This is relevant for synchronous Transform streams\n\t  this.prefinished = false;\n\t\n\t  // True if the error was already emitted and should not be thrown again\n\t  this.errorEmitted = false;\n\t}\n\t\n\tfunction Writable(options) {\n\t  var Duplex = __webpack_require__(31);\n\t\n\t  // Writable ctor is applied to Duplexes, though they're not\n\t  // instanceof Writable, they're instanceof Readable.\n\t  if (!(this instanceof Writable) && !(this instanceof Duplex))\n\t    return new Writable(options);\n\t\n\t  this._writableState = new WritableState(options, this);\n\t\n\t  // legacy.\n\t  this.writable = true;\n\t\n\t  Stream.call(this);\n\t}\n\t\n\t// Otherwise people can pipe Writable streams, which is just wrong.\n\tWritable.prototype.pipe = function() {\n\t  this.emit('error', new Error('Cannot pipe. Not readable.'));\n\t};\n\t\n\t\n\tfunction writeAfterEnd(stream, state, cb) {\n\t  var er = new Error('write after end');\n\t  // TODO: defer error events consistently everywhere, not just the cb\n\t  stream.emit('error', er);\n\t  process.nextTick(function() {\n\t    cb(er);\n\t  });\n\t}\n\t\n\t// If we get something that is not a buffer, string, null, or undefined,\n\t// and we're not in objectMode, then that's an error.\n\t// Otherwise stream chunks are all considered to be of length=1, and the\n\t// watermarks determine how many objects to keep in the buffer, rather than\n\t// how many bytes or characters.\n\tfunction validChunk(stream, state, chunk, cb) {\n\t  var valid = true;\n\t  if (!util.isBuffer(chunk) &&\n\t      !util.isString(chunk) &&\n\t      !util.isNullOrUndefined(chunk) &&\n\t      !state.objectMode) {\n\t    var er = new TypeError('Invalid non-string/buffer chunk');\n\t    stream.emit('error', er);\n\t    process.nextTick(function() {\n\t      cb(er);\n\t    });\n\t    valid = false;\n\t  }\n\t  return valid;\n\t}\n\t\n\tWritable.prototype.write = function(chunk, encoding, cb) {\n\t  var state = this._writableState;\n\t  var ret = false;\n\t\n\t  if (util.isFunction(encoding)) {\n\t    cb = encoding;\n\t    encoding = null;\n\t  }\n\t\n\t  if (util.isBuffer(chunk))\n\t    encoding = 'buffer';\n\t  else if (!encoding)\n\t    encoding = state.defaultEncoding;\n\t\n\t  if (!util.isFunction(cb))\n\t    cb = function() {};\n\t\n\t  if (state.ended)\n\t    writeAfterEnd(this, state, cb);\n\t  else if (validChunk(this, state, chunk, cb)) {\n\t    state.pendingcb++;\n\t    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n\t  }\n\t\n\t  return ret;\n\t};\n\t\n\tWritable.prototype.cork = function() {\n\t  var state = this._writableState;\n\t\n\t  state.corked++;\n\t};\n\t\n\tWritable.prototype.uncork = function() {\n\t  var state = this._writableState;\n\t\n\t  if (state.corked) {\n\t    state.corked--;\n\t\n\t    if (!state.writing &&\n\t        !state.corked &&\n\t        !state.finished &&\n\t        !state.bufferProcessing &&\n\t        state.buffer.length)\n\t      clearBuffer(this, state);\n\t  }\n\t};\n\t\n\tfunction decodeChunk(state, chunk, encoding) {\n\t  if (!state.objectMode &&\n\t      state.decodeStrings !== false &&\n\t      util.isString(chunk)) {\n\t    chunk = new Buffer(chunk, encoding);\n\t  }\n\t  return chunk;\n\t}\n\t\n\t// if we're already writing something, then just put this\n\t// in the queue, and wait our turn.  Otherwise, call _write\n\t// If we return false, then we need a drain event, so set that flag.\n\tfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n\t  chunk = decodeChunk(state, chunk, encoding);\n\t  if (util.isBuffer(chunk))\n\t    encoding = 'buffer';\n\t  var len = state.objectMode ? 1 : chunk.length;\n\t\n\t  state.length += len;\n\t\n\t  var ret = state.length < state.highWaterMark;\n\t  // we must ensure that previous needDrain will not be reset to false.\n\t  if (!ret)\n\t    state.needDrain = true;\n\t\n\t  if (state.writing || state.corked)\n\t    state.buffer.push(new WriteReq(chunk, encoding, cb));\n\t  else\n\t    doWrite(stream, state, false, len, chunk, encoding, cb);\n\t\n\t  return ret;\n\t}\n\t\n\tfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n\t  state.writelen = len;\n\t  state.writecb = cb;\n\t  state.writing = true;\n\t  state.sync = true;\n\t  if (writev)\n\t    stream._writev(chunk, state.onwrite);\n\t  else\n\t    stream._write(chunk, encoding, state.onwrite);\n\t  state.sync = false;\n\t}\n\t\n\tfunction onwriteError(stream, state, sync, er, cb) {\n\t  if (sync)\n\t    process.nextTick(function() {\n\t      state.pendingcb--;\n\t      cb(er);\n\t    });\n\t  else {\n\t    state.pendingcb--;\n\t    cb(er);\n\t  }\n\t\n\t  stream._writableState.errorEmitted = true;\n\t  stream.emit('error', er);\n\t}\n\t\n\tfunction onwriteStateUpdate(state) {\n\t  state.writing = false;\n\t  state.writecb = null;\n\t  state.length -= state.writelen;\n\t  state.writelen = 0;\n\t}\n\t\n\tfunction onwrite(stream, er) {\n\t  var state = stream._writableState;\n\t  var sync = state.sync;\n\t  var cb = state.writecb;\n\t\n\t  onwriteStateUpdate(state);\n\t\n\t  if (er)\n\t    onwriteError(stream, state, sync, er, cb);\n\t  else {\n\t    // Check if we're actually ready to finish, but don't emit yet\n\t    var finished = needFinish(stream, state);\n\t\n\t    if (!finished &&\n\t        !state.corked &&\n\t        !state.bufferProcessing &&\n\t        state.buffer.length) {\n\t      clearBuffer(stream, state);\n\t    }\n\t\n\t    if (sync) {\n\t      process.nextTick(function() {\n\t        afterWrite(stream, state, finished, cb);\n\t      });\n\t    } else {\n\t      afterWrite(stream, state, finished, cb);\n\t    }\n\t  }\n\t}\n\t\n\tfunction afterWrite(stream, state, finished, cb) {\n\t  if (!finished)\n\t    onwriteDrain(stream, state);\n\t  state.pendingcb--;\n\t  cb();\n\t  finishMaybe(stream, state);\n\t}\n\t\n\t// Must force callback to be called on nextTick, so that we don't\n\t// emit 'drain' before the write() consumer gets the 'false' return\n\t// value, and has a chance to attach a 'drain' listener.\n\tfunction onwriteDrain(stream, state) {\n\t  if (state.length === 0 && state.needDrain) {\n\t    state.needDrain = false;\n\t    stream.emit('drain');\n\t  }\n\t}\n\t\n\t\n\t// if there's something in the buffer waiting, then process it\n\tfunction clearBuffer(stream, state) {\n\t  state.bufferProcessing = true;\n\t\n\t  if (stream._writev && state.buffer.length > 1) {\n\t    // Fast case, write everything using _writev()\n\t    var cbs = [];\n\t    for (var c = 0; c < state.buffer.length; c++)\n\t      cbs.push(state.buffer[c].callback);\n\t\n\t    // count the one we are adding, as well.\n\t    // TODO(isaacs) clean this up\n\t    state.pendingcb++;\n\t    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {\n\t      for (var i = 0; i < cbs.length; i++) {\n\t        state.pendingcb--;\n\t        cbs[i](err);\n\t      }\n\t    });\n\t\n\t    // Clear buffer\n\t    state.buffer = [];\n\t  } else {\n\t    // Slow case, write chunks one-by-one\n\t    for (var c = 0; c < state.buffer.length; c++) {\n\t      var entry = state.buffer[c];\n\t      var chunk = entry.chunk;\n\t      var encoding = entry.encoding;\n\t      var cb = entry.callback;\n\t      var len = state.objectMode ? 1 : chunk.length;\n\t\n\t      doWrite(stream, state, false, len, chunk, encoding, cb);\n\t\n\t      // if we didn't call the onwrite immediately, then\n\t      // it means that we need to wait until it does.\n\t      // also, that means that the chunk and cb are currently\n\t      // being processed, so move the buffer counter past them.\n\t      if (state.writing) {\n\t        c++;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (c < state.buffer.length)\n\t      state.buffer = state.buffer.slice(c);\n\t    else\n\t      state.buffer.length = 0;\n\t  }\n\t\n\t  state.bufferProcessing = false;\n\t}\n\t\n\tWritable.prototype._write = function(chunk, encoding, cb) {\n\t  cb(new Error('not implemented'));\n\t\n\t};\n\t\n\tWritable.prototype._writev = null;\n\t\n\tWritable.prototype.end = function(chunk, encoding, cb) {\n\t  var state = this._writableState;\n\t\n\t  if (util.isFunction(chunk)) {\n\t    cb = chunk;\n\t    chunk = null;\n\t    encoding = null;\n\t  } else if (util.isFunction(encoding)) {\n\t    cb = encoding;\n\t    encoding = null;\n\t  }\n\t\n\t  if (!util.isNullOrUndefined(chunk))\n\t    this.write(chunk, encoding);\n\t\n\t  // .end() fully uncorks\n\t  if (state.corked) {\n\t    state.corked = 1;\n\t    this.uncork();\n\t  }\n\t\n\t  // ignore unnecessary end() calls.\n\t  if (!state.ending && !state.finished)\n\t    endWritable(this, state, cb);\n\t};\n\t\n\t\n\tfunction needFinish(stream, state) {\n\t  return (state.ending &&\n\t          state.length === 0 &&\n\t          !state.finished &&\n\t          !state.writing);\n\t}\n\t\n\tfunction prefinish(stream, state) {\n\t  if (!state.prefinished) {\n\t    state.prefinished = true;\n\t    stream.emit('prefinish');\n\t  }\n\t}\n\t\n\tfunction finishMaybe(stream, state) {\n\t  var need = needFinish(stream, state);\n\t  if (need) {\n\t    if (state.pendingcb === 0) {\n\t      prefinish(stream, state);\n\t      state.finished = true;\n\t      stream.emit('finish');\n\t    } else\n\t      prefinish(stream, state);\n\t  }\n\t  return need;\n\t}\n\t\n\tfunction endWritable(stream, state, cb) {\n\t  state.ending = true;\n\t  finishMaybe(stream, state);\n\t  if (cb) {\n\t    if (state.finished)\n\t      process.nextTick(cb);\n\t    else\n\t      stream.once('finish', cb);\n\t  }\n\t  state.ended = true;\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)))\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tvar Buffer = __webpack_require__(10).Buffer;\n\t\n\tvar isBufferEncoding = Buffer.isEncoding\n\t  || function(encoding) {\n\t       switch (encoding && encoding.toLowerCase()) {\n\t         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n\t         default: return false;\n\t       }\n\t     }\n\t\n\t\n\tfunction assertEncoding(encoding) {\n\t  if (encoding && !isBufferEncoding(encoding)) {\n\t    throw new Error('Unknown encoding: ' + encoding);\n\t  }\n\t}\n\t\n\t// StringDecoder provides an interface for efficiently splitting a series of\n\t// buffers into a series of JS strings without breaking apart multi-byte\n\t// characters. CESU-8 is handled as part of the UTF-8 encoding.\n\t//\n\t// @TODO Handling all encodings inside a single object makes it very difficult\n\t// to reason about this code, so it should be split up in the future.\n\t// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n\t// points as used by CESU-8.\n\tvar StringDecoder = exports.StringDecoder = function(encoding) {\n\t  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n\t  assertEncoding(encoding);\n\t  switch (this.encoding) {\n\t    case 'utf8':\n\t      // CESU-8 represents each of Surrogate Pair by 3-bytes\n\t      this.surrogateSize = 3;\n\t      break;\n\t    case 'ucs2':\n\t    case 'utf16le':\n\t      // UTF-16 represents each of Surrogate Pair by 2-bytes\n\t      this.surrogateSize = 2;\n\t      this.detectIncompleteChar = utf16DetectIncompleteChar;\n\t      break;\n\t    case 'base64':\n\t      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n\t      this.surrogateSize = 3;\n\t      this.detectIncompleteChar = base64DetectIncompleteChar;\n\t      break;\n\t    default:\n\t      this.write = passThroughWrite;\n\t      return;\n\t  }\n\t\n\t  // Enough space to store all bytes of a single character. UTF-8 needs 4\n\t  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n\t  this.charBuffer = new Buffer(6);\n\t  // Number of bytes received for the current incomplete multi-byte character.\n\t  this.charReceived = 0;\n\t  // Number of bytes expected for the current incomplete multi-byte character.\n\t  this.charLength = 0;\n\t};\n\t\n\t\n\t// write decodes the given buffer and returns it as JS string that is\n\t// guaranteed to not contain any partial multi-byte characters. Any partial\n\t// character found at the end of the buffer is buffered up, and will be\n\t// returned when calling write again with the remaining bytes.\n\t//\n\t// Note: Converting a Buffer containing an orphan surrogate to a String\n\t// currently works, but converting a String to a Buffer (via `new Buffer`, or\n\t// Buffer#write) will replace incomplete surrogates with the unicode\n\t// replacement character. See https://codereview.chromium.org/121173009/ .\n\tStringDecoder.prototype.write = function(buffer) {\n\t  var charStr = '';\n\t  // if our last write ended with an incomplete multibyte character\n\t  while (this.charLength) {\n\t    // determine how many remaining bytes this buffer has to offer for this char\n\t    var available = (buffer.length >= this.charLength - this.charReceived) ?\n\t        this.charLength - this.charReceived :\n\t        buffer.length;\n\t\n\t    // add the new bytes to the char buffer\n\t    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n\t    this.charReceived += available;\n\t\n\t    if (this.charReceived < this.charLength) {\n\t      // still not enough chars in this buffer? wait for more ...\n\t      return '';\n\t    }\n\t\n\t    // remove bytes belonging to the current character from the buffer\n\t    buffer = buffer.slice(available, buffer.length);\n\t\n\t    // get the character that was split\n\t    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\t\n\t    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n\t    var charCode = charStr.charCodeAt(charStr.length - 1);\n\t    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n\t      this.charLength += this.surrogateSize;\n\t      charStr = '';\n\t      continue;\n\t    }\n\t    this.charReceived = this.charLength = 0;\n\t\n\t    // if there are no more bytes in this buffer, just emit our char\n\t    if (buffer.length === 0) {\n\t      return charStr;\n\t    }\n\t    break;\n\t  }\n\t\n\t  // determine and set charLength / charReceived\n\t  this.detectIncompleteChar(buffer);\n\t\n\t  var end = buffer.length;\n\t  if (this.charLength) {\n\t    // buffer the incomplete character bytes we got\n\t    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n\t    end -= this.charReceived;\n\t  }\n\t\n\t  charStr += buffer.toString(this.encoding, 0, end);\n\t\n\t  var end = charStr.length - 1;\n\t  var charCode = charStr.charCodeAt(end);\n\t  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n\t  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n\t    var size = this.surrogateSize;\n\t    this.charLength += size;\n\t    this.charReceived += size;\n\t    this.charBuffer.copy(this.charBuffer, size, 0, size);\n\t    buffer.copy(this.charBuffer, 0, 0, size);\n\t    return charStr.substring(0, end);\n\t  }\n\t\n\t  // or just emit the charStr\n\t  return charStr;\n\t};\n\t\n\t// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n\t// the end of the given buffer. If so, it sets this.charLength to the byte\n\t// length that character, and sets this.charReceived to the number of bytes\n\t// that are available for this character.\n\tStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n\t  // determine how many bytes we have to check at the end of this buffer\n\t  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\t\n\t  // Figure out if one of the last i bytes of our buffer announces an\n\t  // incomplete char.\n\t  for (; i > 0; i--) {\n\t    var c = buffer[buffer.length - i];\n\t\n\t    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\t\n\t    // 110XXXXX\n\t    if (i == 1 && c >> 5 == 0x06) {\n\t      this.charLength = 2;\n\t      break;\n\t    }\n\t\n\t    // 1110XXXX\n\t    if (i <= 2 && c >> 4 == 0x0E) {\n\t      this.charLength = 3;\n\t      break;\n\t    }\n\t\n\t    // 11110XXX\n\t    if (i <= 3 && c >> 3 == 0x1E) {\n\t      this.charLength = 4;\n\t      break;\n\t    }\n\t  }\n\t  this.charReceived = i;\n\t};\n\t\n\tStringDecoder.prototype.end = function(buffer) {\n\t  var res = '';\n\t  if (buffer && buffer.length)\n\t    res = this.write(buffer);\n\t\n\t  if (this.charReceived) {\n\t    var cr = this.charReceived;\n\t    var buf = this.charBuffer;\n\t    var enc = this.encoding;\n\t    res += buf.slice(0, cr).toString(enc);\n\t  }\n\t\n\t  return res;\n\t};\n\t\n\tfunction passThroughWrite(buffer) {\n\t  return buffer.toString(this.encoding);\n\t}\n\t\n\tfunction utf16DetectIncompleteChar(buffer) {\n\t  this.charReceived = buffer.length % 2;\n\t  this.charLength = this.charReceived ? 2 : 0;\n\t}\n\t\n\tfunction base64DetectIncompleteChar(buffer) {\n\t  this.charReceived = buffer.length % 3;\n\t  this.charLength = this.charReceived ? 3 : 0;\n\t}\n\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\t\n\t// a transform stream is a readable/writable stream where you do\n\t// something with the data.  Sometimes it's called a \"filter\",\n\t// but that's not a great name for it, since that implies a thing where\n\t// some bits pass through, and others are simply ignored.  (That would\n\t// be a valid example of a transform, of course.)\n\t//\n\t// While the output is causally related to the input, it's not a\n\t// necessarily symmetric or synchronous transformation.  For example,\n\t// a zlib stream might take multiple plain-text writes(), and then\n\t// emit a single compressed chunk some time in the future.\n\t//\n\t// Here's how this works:\n\t//\n\t// The Transform stream has all the aspects of the readable and writable\n\t// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n\t// internally, and returns false if there's a lot of pending writes\n\t// buffered up.  When you call read(), that calls _read(n) until\n\t// there's enough pending readable data buffered up.\n\t//\n\t// In a transform stream, the written data is placed in a buffer.  When\n\t// _read(n) is called, it transforms the queued up data, calling the\n\t// buffered _write cb's as it consumes chunks.  If consuming a single\n\t// written chunk would result in multiple output chunks, then the first\n\t// outputted bit calls the readcb, and subsequent chunks just go into\n\t// the read buffer, and will cause it to emit 'readable' if necessary.\n\t//\n\t// This way, back-pressure is actually determined by the reading side,\n\t// since _read has to be called to start processing a new chunk.  However,\n\t// a pathological inflate type of transform can cause excessive buffering\n\t// here.  For example, imagine a stream where every byte of input is\n\t// interpreted as an integer from 0-255, and then results in that many\n\t// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n\t// 1kb of data being output.  In this case, you could write a very small\n\t// amount of input, and end up with a very large amount of output.  In\n\t// such a pathological inflating mechanism, there'd be no way to tell\n\t// the system to stop doing the transform.  A single 4MB write could\n\t// cause the system to run out of memory.\n\t//\n\t// However, even in such a pathological case, only a single written chunk\n\t// would be consumed, and then the rest would wait (un-transformed) until\n\t// the results of the previous transformed chunk were consumed.\n\t\n\tmodule.exports = Transform;\n\t\n\tvar Duplex = __webpack_require__(31);\n\t\n\t/*<replacement>*/\n\tvar util = __webpack_require__(29);\n\tutil.inherits = __webpack_require__(25);\n\t/*</replacement>*/\n\t\n\tutil.inherits(Transform, Duplex);\n\t\n\t\n\tfunction TransformState(options, stream) {\n\t  this.afterTransform = function(er, data) {\n\t    return afterTransform(stream, er, data);\n\t  };\n\t\n\t  this.needTransform = false;\n\t  this.transforming = false;\n\t  this.writecb = null;\n\t  this.writechunk = null;\n\t}\n\t\n\tfunction afterTransform(stream, er, data) {\n\t  var ts = stream._transformState;\n\t  ts.transforming = false;\n\t\n\t  var cb = ts.writecb;\n\t\n\t  if (!cb)\n\t    return stream.emit('error', new Error('no writecb in Transform class'));\n\t\n\t  ts.writechunk = null;\n\t  ts.writecb = null;\n\t\n\t  if (!util.isNullOrUndefined(data))\n\t    stream.push(data);\n\t\n\t  if (cb)\n\t    cb(er);\n\t\n\t  var rs = stream._readableState;\n\t  rs.reading = false;\n\t  if (rs.needReadable || rs.length < rs.highWaterMark) {\n\t    stream._read(rs.highWaterMark);\n\t  }\n\t}\n\t\n\t\n\tfunction Transform(options) {\n\t  if (!(this instanceof Transform))\n\t    return new Transform(options);\n\t\n\t  Duplex.call(this, options);\n\t\n\t  this._transformState = new TransformState(options, this);\n\t\n\t  // when the writable side finishes, then flush out anything remaining.\n\t  var stream = this;\n\t\n\t  // start out asking for a readable event once data is transformed.\n\t  this._readableState.needReadable = true;\n\t\n\t  // we have implemented the _read method, and done the other things\n\t  // that Readable wants before the first _read call, so unset the\n\t  // sync guard flag.\n\t  this._readableState.sync = false;\n\t\n\t  this.once('prefinish', function() {\n\t    if (util.isFunction(this._flush))\n\t      this._flush(function(er) {\n\t        done(stream, er);\n\t      });\n\t    else\n\t      done(stream);\n\t  });\n\t}\n\t\n\tTransform.prototype.push = function(chunk, encoding) {\n\t  this._transformState.needTransform = false;\n\t  return Duplex.prototype.push.call(this, chunk, encoding);\n\t};\n\t\n\t// This is the part where you do stuff!\n\t// override this function in implementation classes.\n\t// 'chunk' is an input chunk.\n\t//\n\t// Call `push(newChunk)` to pass along transformed output\n\t// to the readable side.  You may call 'push' zero or more times.\n\t//\n\t// Call `cb(err)` when you are done with this chunk.  If you pass\n\t// an error, then that'll put the hurt on the whole operation.  If you\n\t// never call cb(), then you'll never get another chunk.\n\tTransform.prototype._transform = function(chunk, encoding, cb) {\n\t  throw new Error('not implemented');\n\t};\n\t\n\tTransform.prototype._write = function(chunk, encoding, cb) {\n\t  var ts = this._transformState;\n\t  ts.writecb = cb;\n\t  ts.writechunk = chunk;\n\t  ts.writeencoding = encoding;\n\t  if (!ts.transforming) {\n\t    var rs = this._readableState;\n\t    if (ts.needTransform ||\n\t        rs.needReadable ||\n\t        rs.length < rs.highWaterMark)\n\t      this._read(rs.highWaterMark);\n\t  }\n\t};\n\t\n\t// Doesn't matter what the args are here.\n\t// _transform does all the work.\n\t// That we got here means that the readable side wants more data.\n\tTransform.prototype._read = function(n) {\n\t  var ts = this._transformState;\n\t\n\t  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {\n\t    ts.transforming = true;\n\t    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n\t  } else {\n\t    // mark that we need a transform, so that any data that comes in\n\t    // will get processed, now that we've asked for it.\n\t    ts.needTransform = true;\n\t  }\n\t};\n\t\n\t\n\tfunction done(stream, er) {\n\t  if (er)\n\t    return stream.emit('error', er);\n\t\n\t  // if there's nothing in the write buffer, then that means\n\t  // that nothing more will ever be provided\n\t  var ws = stream._writableState;\n\t  var ts = stream._transformState;\n\t\n\t  if (ws.length)\n\t    throw new Error('calling transform done when ws.length != 0');\n\t\n\t  if (ts.transforming)\n\t    throw new Error('calling transform done when still transforming');\n\t\n\t  return stream.push(null);\n\t}\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\t// a passthrough stream.\n\t// basically just the most minimal sort of Transform stream.\n\t// Every written chunk gets output as-is.\n\t\n\tmodule.exports = PassThrough;\n\t\n\tvar Transform = __webpack_require__(34);\n\t\n\t/*<replacement>*/\n\tvar util = __webpack_require__(29);\n\tutil.inherits = __webpack_require__(25);\n\t/*</replacement>*/\n\t\n\tutil.inherits(PassThrough, Transform);\n\t\n\tfunction PassThrough(options) {\n\t  if (!(this instanceof PassThrough))\n\t    return new PassThrough(options);\n\t\n\t  Transform.call(this, options);\n\t}\n\t\n\tPassThrough.prototype._transform = function(chunk, encoding, cb) {\n\t  cb(null, chunk);\n\t};\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(32)\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(31)\n\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(34)\n\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(35)\n\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer) {\n\t/**\n\t * Module exports.\n\t */\n\t\n\tmodule.exports = dataUriToBuffer;\n\t\n\t/**\n\t * Returns a `Buffer` instance from the given data URI `uri`.\n\t *\n\t * @param {String} uri Data URI to turn into a Buffer instance\n\t * @return {Buffer} Buffer instance from Data URI\n\t * @api public\n\t */\n\t\n\tfunction dataUriToBuffer (uri) {\n\t  if (!/^data\\:/i.test(uri)) {\n\t    throw new TypeError('`uri` does not appear to be a Data URI (must begin with \"data:\")');\n\t  }\n\t\n\t  // strip newlines\n\t  uri = uri.replace(/\\r?\\n/g, '');\n\t\n\t  // split the URI up into the \"metadata\" and the \"data\" portions\n\t  var firstComma = uri.indexOf(',');\n\t  if (-1 === firstComma || firstComma <= 4) throw new TypeError('malformed data: URI');\n\t\n\t  // remove the \"data:\" scheme and parse the metadata\n\t  var meta = uri.substring(5, firstComma).split(';');\n\t\n\t  var base64 = false;\n\t  var charset = 'US-ASCII';\n\t  for (var i = 0; i < meta.length; i++) {\n\t    if ('base64' == meta[i]) {\n\t      base64 = true;\n\t    } else if (0 == meta[i].indexOf('charset=')) {\n\t      charset = meta[i].substring(8);\n\t    }\n\t  }\n\t\n\t  // get the encoded data portion and decode URI-encoded chars\n\t  var data = unescape(uri.substring(firstComma + 1));\n\t\n\t  var encoding = base64 ? 'base64' : 'ascii';\n\t  var buffer = new Buffer(data, encoding);\n\t\n\t  // set `.type` property to MIME type\n\t  buffer.type = meta[0] || 'text/plain';\n\t\n\t  // set the `.charset` property\n\t  buffer.charset = charset;\n\t\n\t  return buffer;\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10).Buffer))\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar ndarray = __webpack_require__(5);\n\t\n\tvar getRows = function getRows(array, X, Y) {\n\t  var arr = ndarray(array, [X, Y]);\n\t  var res = [];\n\t\n\t  for (var y = 0; y < Y; y++) {\n\t    var row = [];\n\t    for (var x = 0; x < X; x++) {\n\t      row.push(arr.get(x, y));\n\t    }\n\t    res.push(row.join(''));\n\t  }\n\t  return res;\n\t};\n\t\n\tmodule.exports = getRows;\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** asciizer.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 1c323d4a2a86b279f14b\n **/","\"use strict\";\n\nconst equalizeHistogram = require('./equalize')\nconst assignCharacters = require('./assignCharacters')\nconst readSums = require('./readSums-browser')\nconst getRows = require('./getRows')\n\n// options {src, x, y, chars}\nconst asciize = (options, cb) => {\n  if (!options.src)\n    throw \"Missing src\"\n  options.chars = options.chars || \" .-:*+=%#@\"\n\n  readSums(\n    options.src,\n    options.x,\n    options.y,\n    (sum, meta) => {\n      const equalizedData = equalizeHistogram([...sum.data], meta.maxval, options.chars.length - 1)\n      const asciized = assignCharacters(equalizedData, options.chars)\n      const formatted = getRows(asciized,  meta.sizeX, meta.sizeY)\n\n      cb(formatted)\n    }\n  )\n}\n\nmodule.exports = asciize;\n\n\n\n/** WEBPACK FOOTER **\n ** ./asciizer-browser.js\n **/","const equalizeHistogram = function(src, inMax, outMax) {\n  const step = (inMax + 1)  / (outMax + 1)\n\n  return src.map( n => Math.floor(n / step))\n}\n\nmodule.exports = equalizeHistogram\n\n\n\n/** WEBPACK FOOTER **\n ** ./equalize.js\n **/","const assignCharacters =\n  (counts, chars) => counts.map(\n    val => Array.isArray(chars) ? chars[Math.floor(val)] : chars.charAt(Math.floor(val))\n  )\n\nmodule.exports = assignCharacters\n\n\n\n/** WEBPACK FOOTER **\n ** ./assignCharacters.js\n **/","\"use strict\"\n\n// const getPixels = require('get-pixels')\nconst ndarray = require('ndarray')\nconst getPixels = require(\"./vendor/dom-pixels.js\")\n\nconst readSums = function (img, sizeX, sizeY, cb) {\n  getPixels(img, function  (err, pixels) {\n    const picX = pixels.shape[0]\n    const picY = pixels.shape[1]\n    const ratio = picX / picY\n\n    sizeX = !sizeX && sizeY ? Math.floor(sizeY * ratio) : sizeX\n    sizeY = !sizeY && sizeX ? Math.floor(sizeX / ratio) : sizeY\n\n\n    let sum = ndarray(new Uint16Array(sizeX*sizeY), [sizeX, sizeY])\n    const stepX = Math.floor(picX / sizeX)\n    const stepY = Math.floor(picY / sizeY)\n    const maxval = stepX*stepY*255*3\n\n\n    for (let y = 0; y < picY / stepY; y++) {\n      for (let x = 0; x < picX / stepX; x++) {\n        let count = 0\n        for (let py = 0; py < stepY; py++) {\n          for (let px = 0; px < stepX; px++) {\n            const R = pixels.get(x * stepX + px, y * stepY + py, 0)\n            const G = pixels.get(x * stepX + px, y * stepY + py, 1)\n            const B = pixels.get(x * stepX + px, y * stepY + py, 2)\n            // const A = pixels.get(x * stepX + px, y * stepY + py, 3)\n            count += R + G + B\n          }\n        }\n        sum.set(x, y, count)\n      }\n    }\n    cb(sum, {maxval, sizeX, sizeY})\n  })\n}\n\nmodule.exports = readSums\n\n\n\n/** WEBPACK FOOTER **\n ** ./readSums-browser.js\n **/","var iota = require(\"iota-array\")\nvar isBuffer = require(\"is-buffer\")\n\nvar hasTypedArrays  = ((typeof Float64Array) !== \"undefined\")\n\nfunction compare1st(a, b) {\n  return a[0] - b[0]\n}\n\nfunction order() {\n  var stride = this.stride\n  var terms = new Array(stride.length)\n  var i\n  for(i=0; i<terms.length; ++i) {\n    terms[i] = [Math.abs(stride[i]), i]\n  }\n  terms.sort(compare1st)\n  var result = new Array(terms.length)\n  for(i=0; i<result.length; ++i) {\n    result[i] = terms[i][1]\n  }\n  return result\n}\n\nfunction compileConstructor(dtype, dimension) {\n  var className = [\"View\", dimension, \"d\", dtype].join(\"\")\n  if(dimension < 0) {\n    className = \"View_Nil\" + dtype\n  }\n  var useGetters = (dtype === \"generic\")\n\n  if(dimension === -1) {\n    //Special case for trivial arrays\n    var code =\n      \"function \"+className+\"(a){this.data=a;};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return -1};\\\nproto.size=0;\\\nproto.dimension=-1;\\\nproto.shape=proto.stride=proto.order=[];\\\nproto.lo=proto.hi=proto.transpose=proto.step=\\\nfunction(){return new \"+className+\"(this.data);};\\\nproto.get=proto.set=function(){};\\\nproto.pick=function(){return null};\\\nreturn function construct_\"+className+\"(a){return new \"+className+\"(a);}\"\n    var procedure = new Function(code)\n    return procedure()\n  } else if(dimension === 0) {\n    //Special case for 0d arrays\n    var code =\n      \"function \"+className+\"(a,d) {\\\nthis.data = a;\\\nthis.offset = d\\\n};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return this.offset};\\\nproto.dimension=0;\\\nproto.size=1;\\\nproto.shape=\\\nproto.stride=\\\nproto.order=[];\\\nproto.lo=\\\nproto.hi=\\\nproto.transpose=\\\nproto.step=function \"+className+\"_copy() {\\\nreturn new \"+className+\"(this.data,this.offset)\\\n};\\\nproto.pick=function \"+className+\"_pick(){\\\nreturn TrivialArray(this.data);\\\n};\\\nproto.valueOf=proto.get=function \"+className+\"_get(){\\\nreturn \"+(useGetters ? \"this.data.get(this.offset)\" : \"this.data[this.offset]\")+\n\"};\\\nproto.set=function \"+className+\"_set(v){\\\nreturn \"+(useGetters ? \"this.data.set(this.offset,v)\" : \"this.data[this.offset]=v\")+\"\\\n};\\\nreturn function construct_\"+className+\"(a,b,c,d){return new \"+className+\"(a,d)}\"\n    var procedure = new Function(\"TrivialArray\", code)\n    return procedure(CACHED_CONSTRUCTORS[dtype][0])\n  }\n\n  var code = [\"'use strict'\"]\n\n  //Create constructor for view\n  var indices = iota(dimension)\n  var args = indices.map(function(i) { return \"i\"+i })\n  var index_str = \"this.offset+\" + indices.map(function(i) {\n        return \"this.stride[\" + i + \"]*i\" + i\n      }).join(\"+\")\n  var shapeArg = indices.map(function(i) {\n      return \"b\"+i\n    }).join(\",\")\n  var strideArg = indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")\n  code.push(\n    \"function \"+className+\"(a,\" + shapeArg + \",\" + strideArg + \",d){this.data=a\",\n      \"this.shape=[\" + shapeArg + \"]\",\n      \"this.stride=[\" + strideArg + \"]\",\n      \"this.offset=d|0}\",\n    \"var proto=\"+className+\".prototype\",\n    \"proto.dtype='\"+dtype+\"'\",\n    \"proto.dimension=\"+dimension)\n\n  //view.size:\n  code.push(\"Object.defineProperty(proto,'size',{get:function \"+className+\"_size(){\\\nreturn \"+indices.map(function(i) { return \"this.shape[\"+i+\"]\" }).join(\"*\"),\n\"}})\")\n\n  //view.order:\n  if(dimension === 1) {\n    code.push(\"proto.order=[0]\")\n  } else {\n    code.push(\"Object.defineProperty(proto,'order',{get:\")\n    if(dimension < 4) {\n      code.push(\"function \"+className+\"_order(){\")\n      if(dimension === 2) {\n        code.push(\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\")\n      } else if(dimension === 3) {\n        code.push(\n\"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\\\nif(s0>s1){\\\nif(s1>s2){\\\nreturn [2,1,0];\\\n}else if(s0>s2){\\\nreturn [1,2,0];\\\n}else{\\\nreturn [1,0,2];\\\n}\\\n}else if(s0>s2){\\\nreturn [2,0,1];\\\n}else if(s2>s1){\\\nreturn [0,1,2];\\\n}else{\\\nreturn [0,2,1];\\\n}}})\")\n      }\n    } else {\n      code.push(\"ORDER})\")\n    }\n  }\n\n  //view.set(i0, ..., v):\n  code.push(\n\"proto.set=function \"+className+\"_set(\"+args.join(\",\")+\",v){\")\n  if(useGetters) {\n    code.push(\"return this.data.set(\"+index_str+\",v)}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]=v}\")\n  }\n\n  //view.get(i0, ...):\n  code.push(\"proto.get=function \"+className+\"_get(\"+args.join(\",\")+\"){\")\n  if(useGetters) {\n    code.push(\"return this.data.get(\"+index_str+\")}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]}\")\n  }\n\n  //view.index:\n  code.push(\n    \"proto.index=function \"+className+\"_index(\", args.join(), \"){return \"+index_str+\"}\")\n\n  //view.hi():\n  code.push(\"proto.hi=function \"+className+\"_hi(\"+args.join(\",\")+\"){return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return [\"(typeof i\",i,\"!=='number'||i\",i,\"<0)?this.shape[\", i, \"]:i\", i,\"|0\"].join(\"\")\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"this.stride[\"+i + \"]\"\n    }).join(\",\")+\",this.offset)}\")\n\n  //view.lo():\n  var a_vars = indices.map(function(i) { return \"a\"+i+\"=this.shape[\"+i+\"]\" })\n  var c_vars = indices.map(function(i) { return \"c\"+i+\"=this.stride[\"+i+\"]\" })\n  code.push(\"proto.lo=function \"+className+\"_lo(\"+args.join(\",\")+\"){var b=this.offset,d=0,\"+a_vars.join(\",\")+\",\"+c_vars.join(\",\"))\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){\\\nd=i\"+i+\"|0;\\\nb+=c\"+i+\"*d;\\\na\"+i+\"-=d}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\"+i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")+\",b)}\")\n\n  //view.step():\n  code.push(\"proto.step=function \"+className+\"_step(\"+args.join(\",\")+\"){var \"+\n    indices.map(function(i) {\n      return \"a\"+i+\"=this.shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\"+i+\"=this.stride[\"+i+\"]\"\n    }).join(\",\")+\",c=this.offset,d=0,ceil=Math.ceil\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'){\\\nd=i\"+i+\"|0;\\\nif(d<0){\\\nc+=b\"+i+\"*(a\"+i+\"-1);\\\na\"+i+\"=ceil(-a\"+i+\"/d)\\\n}else{\\\na\"+i+\"=ceil(a\"+i+\"/d)\\\n}\\\nb\"+i+\"*=d\\\n}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\" + i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\" + i\n    }).join(\",\")+\",c)}\")\n\n  //view.transpose():\n  var tShape = new Array(dimension)\n  var tStride = new Array(dimension)\n  for(var i=0; i<dimension; ++i) {\n    tShape[i] = \"a[i\"+i+\"]\"\n    tStride[i] = \"b[i\"+i+\"]\"\n  }\n  code.push(\"proto.transpose=function \"+className+\"_transpose(\"+args+\"){\"+\n    args.map(function(n,idx) { return n + \"=(\" + n + \"===undefined?\" + idx + \":\" + n + \"|0)\"}).join(\";\"),\n    \"var a=this.shape,b=this.stride;return new \"+className+\"(this.data,\"+tShape.join(\",\")+\",\"+tStride.join(\",\")+\",this.offset)}\")\n\n  //view.pick():\n  code.push(\"proto.pick=function \"+className+\"_pick(\"+args+\"){var a=[],b=[],c=this.offset\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){c=(c+this.stride[\"+i+\"]*i\"+i+\")|0}else{a.push(this.shape[\"+i+\"]);b.push(this.stride[\"+i+\"])}\")\n  }\n  code.push(\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\")\n\n  //Add return statement\n  code.push(\"return function construct_\"+className+\"(data,shape,stride,offset){return new \"+className+\"(data,\"+\n    indices.map(function(i) {\n      return \"shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"stride[\"+i+\"]\"\n    }).join(\",\")+\",offset)}\")\n\n  //Compile procedure\n  var procedure = new Function(\"CTOR_LIST\", \"ORDER\", code.join(\"\\n\"))\n  return procedure(CACHED_CONSTRUCTORS[dtype], order)\n}\n\nfunction arrayDType(data) {\n  if(isBuffer(data)) {\n    return \"buffer\"\n  }\n  if(hasTypedArrays) {\n    switch(Object.prototype.toString.call(data)) {\n      case \"[object Float64Array]\":\n        return \"float64\"\n      case \"[object Float32Array]\":\n        return \"float32\"\n      case \"[object Int8Array]\":\n        return \"int8\"\n      case \"[object Int16Array]\":\n        return \"int16\"\n      case \"[object Int32Array]\":\n        return \"int32\"\n      case \"[object Uint8Array]\":\n        return \"uint8\"\n      case \"[object Uint16Array]\":\n        return \"uint16\"\n      case \"[object Uint32Array]\":\n        return \"uint32\"\n      case \"[object Uint8ClampedArray]\":\n        return \"uint8_clamped\"\n    }\n  }\n  if(Array.isArray(data)) {\n    return \"array\"\n  }\n  return \"generic\"\n}\n\nvar CACHED_CONSTRUCTORS = {\n  \"float32\":[],\n  \"float64\":[],\n  \"int8\":[],\n  \"int16\":[],\n  \"int32\":[],\n  \"uint8\":[],\n  \"uint16\":[],\n  \"uint32\":[],\n  \"array\":[],\n  \"uint8_clamped\":[],\n  \"buffer\":[],\n  \"generic\":[]\n}\n\n;(function() {\n  for(var id in CACHED_CONSTRUCTORS) {\n    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))\n  }\n});\n\nfunction wrappedNDArrayCtor(data, shape, stride, offset) {\n  if(data === undefined) {\n    var ctor = CACHED_CONSTRUCTORS.array[0]\n    return ctor([])\n  } else if(typeof data === \"number\") {\n    data = [data]\n  }\n  if(shape === undefined) {\n    shape = [ data.length ]\n  }\n  var d = shape.length\n  if(stride === undefined) {\n    stride = new Array(d)\n    for(var i=d-1, sz=1; i>=0; --i) {\n      stride[i] = sz\n      sz *= shape[i]\n    }\n  }\n  if(offset === undefined) {\n    offset = 0\n    for(var i=0; i<d; ++i) {\n      if(stride[i] < 0) {\n        offset -= (shape[i]-1)*stride[i]\n      }\n    }\n  }\n  var dtype = arrayDType(data)\n  var ctor_list = CACHED_CONSTRUCTORS[dtype]\n  while(ctor_list.length <= d+1) {\n    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))\n  }\n  var ctor = ctor_list[d+1]\n  return ctor(data, shape, stride, offset)\n}\n\nmodule.exports = wrappedNDArrayCtor\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/ndarray/ndarray.js\n ** module id = 5\n ** module chunks = 0\n **/","\"use strict\"\n\nfunction iota(n) {\n  var result = new Array(n)\n  for(var i=0; i<n; ++i) {\n    result[i] = i\n  }\n  return result\n}\n\nmodule.exports = iota\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/iota-array/iota.js\n ** module id = 6\n ** module chunks = 0\n **/","/**\n * Determine if an object is Buffer\n *\n * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * License:  MIT\n *\n * `npm install is-buffer`\n */\n\nmodule.exports = function (obj) {\n  return !!(obj != null &&\n    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)\n      (obj.constructor &&\n      typeof obj.constructor.isBuffer === 'function' &&\n      obj.constructor.isBuffer(obj))\n    ))\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/is-buffer/index.js\n ** module id = 7\n ** module chunks = 0\n **/","// https://github.com/scijs/get-pixels/blob/master/dom-pixels.js\n'use strict'\n\nvar path          = require('path')\nvar ndarray       = require('ndarray')\nvar GifReader     = require('omggif').GifReader\nvar pack          = require('ndarray-pack')\nvar through       = require('through')\nvar parseDataURI  = require('data-uri-to-buffer')\n\nfunction defaultImage(url, cb) {\n  var img = new Image()\n  img.crossOrigin = \"Anonymous\"\n  img.onload = function() {\n    var canvas = document.createElement('canvas')\n    canvas.width = img.width\n    canvas.height = img.height\n    var context = canvas.getContext('2d')\n    context.drawImage(img, 0, 0)\n    var pixels = context.getImageData(0, 0, img.width, img.height)\n    cb(null, ndarray(new Uint8Array(pixels.data), [img.width, img.height, 4], [4, 4*img.width, 1], 0))\n  }\n  img.onerror = function(err) {\n    cb(err)\n  }\n  img.src = url\n}\n\n//Animated gif loading\nfunction handleGif(data, cb) {\n  var reader\n  try {\n    reader = new GifReader(data)\n  } catch(err) {\n    cb(err)\n    return\n  }\n  if(reader.numFrames() > 0) {\n    var nshape = [reader.numFrames(), reader.height, reader.width, 4]\n    var ndata = new Uint8Array(nshape[0] * nshape[1] * nshape[2] * nshape[3])\n    var result = ndarray(ndata, nshape)\n    try {\n      for(var i=0; i<reader.numFrames(); ++i) {\n        reader.decodeAndBlitFrameRGBA(i, ndata.subarray(\n          result.index(i, 0, 0, 0),\n          result.index(i+1, 0, 0, 0)))\n      }\n    } catch(err) {\n      cb(err)\n      return\n    }\n    cb(null, result.transpose(0,2,1))\n  } else {\n    var nshape = [reader.height, reader.width, 4]\n    var ndata = new Uint8Array(nshape[0] * nshape[1] * nshape[2])\n    var result = ndarray(ndata, nshape)\n    try {\n      reader.decodeAndBlitFrameRGBA(0, ndata)\n    } catch(err) {\n      cb(err)\n      return\n    }\n    cb(null, result.transpose(1,0))\n  }\n}\n\nfunction httpGif(url, cb) {\n  var xhr          = new XMLHttpRequest()\n  xhr.open('GET', url, true)\n  xhr.responseType = 'arraybuffer'\n  if(xhr.overrideMimeType){\n    xhr.overrideMimeType('application/binary')\n  }\n  xhr.onerror = function(err) {\n    cb(err)\n  }\n  xhr.onload = function() {\n    if(xhr.readyState !== 4) {\n      return\n    }\n    var data = new Uint8Array(xhr.response)\n    handleGif(data, cb)\n    return\n  }\n  xhr.send()\n}\n\nfunction copyBuffer(buffer) {\n  if(buffer[0] === undefined) {\n    var n = buffer.length\n    var result = new Uint8Array(n)\n    for(var i=0; i<n; ++i) {\n      result[i] = buffer.get(i)\n    }\n    return result\n  } else {\n    return new Uint8Array(buffer)\n  }\n}\n\nfunction dataGif(url, cb) {\n  process.nextTick(function() {\n    try {\n      var buffer = parseDataURI(url)\n      if(buffer) {\n        handleGif(copyBuffer(buffer), cb)\n      } else {\n        cb(new Error('Error parsing data URI'))\n      }\n    } catch(err) {\n      cb(err)\n    }\n  })\n}\n\nmodule.exports = function getPixels(url, type, cb) {\n  if(!cb) {\n    cb = type\n    type = ''\n  }\n  var ext = path.extname(url)\n  switch(type || ext.toUpperCase()) {\n    case '.GIF':\n      httpGif(url, cb)\n    break\n    default:\n      if(Buffer.isBuffer(url)) {\n        url = 'data:' + type + ';base64,' + url.toString('base64')\n      }\n      if(url.indexOf('data:image/gif;') === 0) {\n        dataGif(url, cb)\n      } else {\n        defaultImage(url, cb)\n      }\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./vendor/dom-pixels.js\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/process/browser.js\n ** module id = 9\n ** module chunks = 0\n **/","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192 // not used by this implementation\n\nvar rootParent = {}\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property\n *     on objects.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\nfunction typedArraySupport () {\n  function Bar () {}\n  try {\n    var arr = new Uint8Array(1)\n    arr.foo = function () { return 42 }\n    arr.constructor = Bar\n    return arr.foo() === 42 && // typed array instances can be augmented\n        arr.constructor === Bar && // constructor can be set\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (arg) {\n  if (!(this instanceof Buffer)) {\n    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n    return new Buffer(arg)\n  }\n\n  this.length = 0\n  this.parent = undefined\n\n  // Common case.\n  if (typeof arg === 'number') {\n    return fromNumber(this, arg)\n  }\n\n  // Slightly less common case.\n  if (typeof arg === 'string') {\n    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n  }\n\n  // Unusual.\n  return fromObject(this, arg)\n}\n\nfunction fromNumber (that, length) {\n  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < length; i++) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\n  // Assumption: byteLength() return value is always < kMaxLength.\n  var length = byteLength(string, encoding) | 0\n  that = allocate(that, length)\n\n  that.write(string, encoding)\n  return that\n}\n\nfunction fromObject (that, object) {\n  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\n  if (isArray(object)) return fromArray(that, object)\n\n  if (object == null) {\n    throw new TypeError('must start with number, buffer, array or string')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined') {\n    if (object.buffer instanceof ArrayBuffer) {\n      return fromTypedArray(that, object)\n    }\n    if (object instanceof ArrayBuffer) {\n      return fromArrayBuffer(that, object)\n    }\n  }\n\n  if (object.length) return fromArrayLike(that, object)\n\n  return fromJsonObject(that, object)\n}\n\nfunction fromBuffer (that, buffer) {\n  var length = checked(buffer.length) | 0\n  that = allocate(that, length)\n  buffer.copy(that, 0, 0, length)\n  return that\n}\n\nfunction fromArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Duplicate of fromArray() to keep fromArray() monomorphic.\nfunction fromTypedArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  // Truncating the elements is probably not what people expect from typed\n  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n  // of the old Buffer constructor.\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    array.byteLength\n    that = Buffer._augment(new Uint8Array(array))\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromTypedArray(that, new Uint8Array(array))\n  }\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n// Returns a zero-length buffer for inputs that don't conform to the spec.\nfunction fromJsonObject (that, object) {\n  var array\n  var length = 0\n\n  if (object.type === 'Buffer' && isArray(object.data)) {\n    array = object.data\n    length = checked(array.length) | 0\n  }\n  that = allocate(that, length)\n\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n}\n\nfunction allocate (that, length) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = Buffer._augment(new Uint8Array(length))\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that.length = length\n    that._isBuffer = true\n  }\n\n  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n  if (fromPool) that.parent = rootParent\n\n  return that\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (subject, encoding) {\n  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\n  var buf = new Buffer(subject, encoding)\n  delete buf.parent\n  return buf\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  var i = 0\n  var len = Math.min(x, y)\n  while (i < len) {\n    if (a[i] !== b[i]) break\n\n    ++i\n  }\n\n  if (i !== len) {\n    x = a[i]\n    y = b[i]\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; i++) {\n      length += list[i].length\n    }\n  }\n\n  var buf = new Buffer(length)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\nfunction byteLength (string, encoding) {\n  if (typeof string !== 'string') string = '' + string\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'binary':\n      // Deprecated\n      case 'raw':\n      case 'raws':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\n// pre-set for values that may exist in the future\nBuffer.prototype.length = undefined\nBuffer.prototype.parent = undefined\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  start = start | 0\n  end = end === undefined || end === Infinity ? this.length : end | 0\n\n  if (!encoding) encoding = 'utf8'\n  if (start < 0) start = 0\n  if (end > this.length) end = this.length\n  if (end <= start) return ''\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'binary':\n        return binarySlice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return 0\n  return Buffer.compare(this, b)\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n  byteOffset >>= 0\n\n  if (this.length === 0) return -1\n  if (byteOffset >= this.length) return -1\n\n  // Negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\n  if (typeof val === 'string') {\n    if (val.length === 0) return -1 // special case: looking for empty string always fails\n    return String.prototype.indexOf.call(this, val, byteOffset)\n  }\n  if (Buffer.isBuffer(val)) {\n    return arrayIndexOf(this, val, byteOffset)\n  }\n  if (typeof val === 'number') {\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n    }\n    return arrayIndexOf(this, [ val ], byteOffset)\n  }\n\n  function arrayIndexOf (arr, val, byteOffset) {\n    var foundIndex = -1\n    for (var i = 0; byteOffset + i < arr.length; i++) {\n      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n      } else {\n        foundIndex = -1\n      }\n    }\n    return -1\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\n// `get` is deprecated\nBuffer.prototype.get = function get (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` is deprecated\nBuffer.prototype.set = function set (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) throw new Error('Invalid hex string')\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction binaryWrite (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    var swap = encoding\n    encoding = offset\n    offset = length | 0\n    length = swap\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'binary':\n        return binaryWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction binarySlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  if (newBuf.length) newBuf.parent = this.parent || this\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n  if (offset < 0) throw new RangeError('index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; i--) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; i++) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    target._set(this.subarray(start, start + len), targetStart)\n  }\n\n  return len\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (end < start) throw new RangeError('end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\n  var i\n  if (typeof value === 'number') {\n    for (i = start; i < end; i++) {\n      this[i] = value\n    }\n  } else {\n    var bytes = utf8ToBytes(value.toString())\n    var len = bytes.length\n    for (i = start; i < end; i++) {\n      this[i] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function toArrayBuffer () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1) {\n        buf[i] = this[i]\n      }\n      return buf.buffer\n    }\n  } else {\n    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function _augment (arr) {\n  arr.constructor = Buffer\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array set method before overwriting\n  arr._set = arr.set\n\n  // deprecated\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.equals = BP.equals\n  arr.compare = BP.compare\n  arr.indexOf = BP.indexOf\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUIntLE = BP.readUIntLE\n  arr.readUIntBE = BP.readUIntBE\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readIntLE = BP.readIntLE\n  arr.readIntBE = BP.readIntBE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUIntLE = BP.writeUIntLE\n  arr.writeUIntBE = BP.writeUIntBE\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeIntLE = BP.writeIntLE\n  arr.writeIntBE = BP.writeIntBE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; i++) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/buffer/index.js\n ** module id = 10\n ** module chunks = 0\n **/","var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n\t'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n\tvar PLUS   = '+'.charCodeAt(0)\n\tvar SLASH  = '/'.charCodeAt(0)\n\tvar NUMBER = '0'.charCodeAt(0)\n\tvar LOWER  = 'a'.charCodeAt(0)\n\tvar UPPER  = 'A'.charCodeAt(0)\n\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\n\tfunction decode (elt) {\n\t\tvar code = elt.charCodeAt(0)\n\t\tif (code === PLUS ||\n\t\t    code === PLUS_URL_SAFE)\n\t\t\treturn 62 // '+'\n\t\tif (code === SLASH ||\n\t\t    code === SLASH_URL_SAFE)\n\t\t\treturn 63 // '/'\n\t\tif (code < NUMBER)\n\t\t\treturn -1 //no match\n\t\tif (code < NUMBER + 10)\n\t\t\treturn code - NUMBER + 26 + 26\n\t\tif (code < UPPER + 26)\n\t\t\treturn code - UPPER\n\t\tif (code < LOWER + 26)\n\t\t\treturn code - LOWER + 26\n\t}\n\n\tfunction b64ToByteArray (b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr\n\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tvar len = b64.length\n\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\n\t\tvar L = 0\n\n\t\tfunction push (v) {\n\t\t\tarr[L++] = v\n\t\t}\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\tpush(tmp & 0xFF)\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\treturn arr\n\t}\n\n\tfunction uint8ToBase64 (uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length\n\n\t\tfunction encode (num) {\n\t\t\treturn lookup.charAt(num)\n\t\t}\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t}\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\toutput += tripletToBase64(temp)\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\toutput += '=='\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\toutput += '='\n\t\t\t\tbreak\n\t\t}\n\n\t\treturn output\n\t}\n\n\texports.toByteArray = b64ToByteArray\n\texports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/base64-js/lib/b64.js\n ** module id = 11\n ** module chunks = 0\n **/","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/ieee754/index.js\n ** module id = 12\n ** module chunks = 0\n **/","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/buffer/~/isarray/index.js\n ** module id = 13\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/path-browserify/index.js\n ** module id = 14\n ** module chunks = 0\n **/","// (c) Dean McNamee <dean@gmail.com>, 2013.\n//\n// https://github.com/deanm/omggif\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n//\n// omggif is a JavaScript implementation of a GIF 89a encoder and decoder,\n// including animation and compression.  It does not rely on any specific\n// underlying system, so should run in the browser, Node, or Plask.\n\nfunction GifWriter(buf, width, height, gopts) {\n  var p = 0;\n\n  var gopts = gopts === undefined ? { } : gopts;\n  var loop_count = gopts.loop === undefined ? null : gopts.loop;\n  var global_palette = gopts.palette === undefined ? null : gopts.palette;\n\n  if (width <= 0 || height <= 0 || width > 65535 || height > 65535)\n    throw \"Width/Height invalid.\"\n\n  function check_palette_and_num_colors(palette) {\n    var num_colors = palette.length;\n    if (num_colors < 2 || num_colors > 256 ||  num_colors & (num_colors-1))\n      throw \"Invalid code/color length, must be power of 2 and 2 .. 256.\";\n    return num_colors;\n  }\n\n  // - Header.\n  buf[p++] = 0x47; buf[p++] = 0x49; buf[p++] = 0x46;  // GIF\n  buf[p++] = 0x38; buf[p++] = 0x39; buf[p++] = 0x61;  // 89a\n\n  // Handling of Global Color Table (palette) and background index.\n  var gp_num_colors_pow2 = 0;\n  var background = 0;\n  if (global_palette !== null) {\n    var gp_num_colors = check_palette_and_num_colors(global_palette);\n    while (gp_num_colors >>= 1) ++gp_num_colors_pow2;\n    gp_num_colors = 1 << gp_num_colors_pow2;\n    --gp_num_colors_pow2;\n    if (gopts.background !== undefined) {\n      background = gopts.background;\n      if (background >= gp_num_colors) throw \"Background index out of range.\";\n      // The GIF spec states that a background index of 0 should be ignored, so\n      // this is probably a mistake and you really want to set it to another\n      // slot in the palette.  But actually in the end most browsers, etc end\n      // up ignoring this almost completely (including for dispose background).\n      if (background === 0)\n        throw \"Background index explicitly passed as 0.\";\n    }\n  }\n\n  // - Logical Screen Descriptor.\n  // NOTE(deanm): w/h apparently ignored by implementations, but set anyway.\n  buf[p++] = width & 0xff; buf[p++] = width >> 8 & 0xff;\n  buf[p++] = height & 0xff; buf[p++] = height >> 8 & 0xff;\n  // NOTE: Indicates 0-bpp original color resolution (unused?).\n  buf[p++] = (global_palette !== null ? 0x80 : 0) |  // Global Color Table Flag.\n             gp_num_colors_pow2;  // NOTE: No sort flag (unused?).\n  buf[p++] = background;  // Background Color Index.\n  buf[p++] = 0;  // Pixel aspect ratio (unused?).\n\n  // - Global Color Table\n  if (global_palette !== null) {\n    for (var i = 0, il = global_palette.length; i < il; ++i) {\n      var rgb = global_palette[i];\n      buf[p++] = rgb >> 16 & 0xff;\n      buf[p++] = rgb >> 8 & 0xff;\n      buf[p++] = rgb & 0xff;\n    }\n  }\n\n  if (loop_count !== null) {  // Netscape block for looping.\n    if (loop_count < 0 || loop_count > 65535)\n      throw \"Loop count invalid.\"\n    // Extension code, label, and length.\n    buf[p++] = 0x21; buf[p++] = 0xff; buf[p++] = 0x0b;\n    // NETSCAPE2.0\n    buf[p++] = 0x4e; buf[p++] = 0x45; buf[p++] = 0x54; buf[p++] = 0x53;\n    buf[p++] = 0x43; buf[p++] = 0x41; buf[p++] = 0x50; buf[p++] = 0x45;\n    buf[p++] = 0x32; buf[p++] = 0x2e; buf[p++] = 0x30;\n    // Sub-block\n    buf[p++] = 0x03; buf[p++] = 0x01;\n    buf[p++] = loop_count & 0xff; buf[p++] = loop_count >> 8 & 0xff;\n    buf[p++] = 0x00;  // Terminator.\n  }\n\n\n  var ended = false;\n\n  this.addFrame = function(x, y, w, h, indexed_pixels, opts) {\n    if (ended === true) { --p; ended = false; }  // Un-end.\n\n    opts = opts === undefined ? { } : opts;\n\n    // TODO(deanm): Bounds check x, y.  Do they need to be within the virtual\n    // canvas width/height, I imagine?\n    if (x < 0 || y < 0 || x > 65535 || y > 65535)\n      throw \"x/y invalid.\"\n\n    if (w <= 0 || h <= 0 || w > 65535 || h > 65535)\n      throw \"Width/Height invalid.\"\n\n    if (indexed_pixels.length < w * h)\n      throw \"Not enough pixels for the frame size.\";\n\n    var using_local_palette = true;\n    var palette = opts.palette;\n    if (palette === undefined || palette === null) {\n      using_local_palette = false;\n      palette = global_palette;\n    }\n\n    if (palette === undefined || palette === null)\n      throw \"Must supply either a local or global palette.\";\n\n    var num_colors = check_palette_and_num_colors(palette);\n\n    // Compute the min_code_size (power of 2), destroying num_colors.\n    var min_code_size = 0;\n    while (num_colors >>= 1) ++min_code_size;\n    num_colors = 1 << min_code_size;  // Now we can easily get it back.\n\n    var delay = opts.delay === undefined ? 0 : opts.delay;\n\n    // From the spec:\n    //     0 -   No disposal specified. The decoder is\n    //           not required to take any action.\n    //     1 -   Do not dispose. The graphic is to be left\n    //           in place.\n    //     2 -   Restore to background color. The area used by the\n    //           graphic must be restored to the background color.\n    //     3 -   Restore to previous. The decoder is required to\n    //           restore the area overwritten by the graphic with\n    //           what was there prior to rendering the graphic.\n    //  4-7 -    To be defined.\n    // NOTE(deanm): Dispose background doesn't really work, apparently most\n    // browsers ignore the background palette index and clear to transparency.\n    var disposal = opts.disposal === undefined ? 0 : opts.disposal;\n    if (disposal < 0 || disposal > 3)  // 4-7 is reserved.\n      throw \"Disposal out of range.\";\n\n    var use_transparency = false;\n    var transparent_index = 0;\n    if (opts.transparent !== undefined && opts.transparent !== null) {\n      use_transparency = true;\n      transparent_index = opts.transparent;\n      if (transparent_index < 0 || transparent_index >= num_colors)\n        throw \"Transparent color index.\";\n    }\n\n    if (disposal !== 0 || use_transparency || delay !== 0) {\n      // - Graphics Control Extension\n      buf[p++] = 0x21; buf[p++] = 0xf9;  // Extension / Label.\n      buf[p++] = 4;  // Byte size.\n\n      buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0);\n      buf[p++] = delay & 0xff; buf[p++] = delay >> 8 & 0xff;\n      buf[p++] = transparent_index;  // Transparent color index.\n      buf[p++] = 0;  // Block Terminator.\n    }\n\n    // - Image Descriptor\n    buf[p++] = 0x2c;  // Image Seperator.\n    buf[p++] = x & 0xff; buf[p++] = x >> 8 & 0xff;  // Left.\n    buf[p++] = y & 0xff; buf[p++] = y >> 8 & 0xff;  // Top.\n    buf[p++] = w & 0xff; buf[p++] = w >> 8 & 0xff;\n    buf[p++] = h & 0xff; buf[p++] = h >> 8 & 0xff;\n    // NOTE: No sort flag (unused?).\n    // TODO(deanm): Support interlace.\n    buf[p++] = using_local_palette === true ? (0x80 | (min_code_size-1)) : 0;\n\n    // - Local Color Table\n    if (using_local_palette === true) {\n      for (var i = 0, il = palette.length; i < il; ++i) {\n        var rgb = palette[i];\n        buf[p++] = rgb >> 16 & 0xff;\n        buf[p++] = rgb >> 8 & 0xff;\n        buf[p++] = rgb & 0xff;\n      }\n    }\n\n    p = GifWriterOutputLZWCodeStream(\n            buf, p, min_code_size < 2 ? 2 : min_code_size, indexed_pixels);\n  };\n\n  this.end = function() {\n    if (ended === false) {\n      buf[p++] = 0x3b;  // Trailer.\n      ended = true;\n    }\n    return p;\n  };\n}\n\n// Main compression routine, palette indexes -> LZW code stream.\n// |index_stream| must have at least one entry.\nfunction GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {\n  buf[p++] = min_code_size;\n  var cur_subblock = p++;  // Pointing at the length field.\n\n  var clear_code = 1 << min_code_size;\n  var code_mask = clear_code - 1;\n  var eoi_code = clear_code + 1;\n  var next_code = eoi_code + 1;\n\n  var cur_code_size = min_code_size + 1;  // Number of bits per code.\n  var cur_shift = 0;\n  // We have at most 12-bit codes, so we should have to hold a max of 19\n  // bits here (and then we would write out).\n  var cur = 0;\n\n  function emit_bytes_to_buffer(bit_block_size) {\n    while (cur_shift >= bit_block_size) {\n      buf[p++] = cur & 0xff;\n      cur >>= 8; cur_shift -= 8;\n      if (p === cur_subblock + 256) {  // Finished a subblock.\n        buf[cur_subblock] = 255;\n        cur_subblock = p++;\n      }\n    }\n  }\n\n  function emit_code(c) {\n    cur |= c << cur_shift;\n    cur_shift += cur_code_size;\n    emit_bytes_to_buffer(8);\n  }\n\n  // I am not an expert on the topic, and I don't want to write a thesis.\n  // However, it is good to outline here the basic algorithm and the few data\n  // structures and optimizations here that make this implementation fast.\n  // The basic idea behind LZW is to build a table of previously seen runs\n  // addressed by a short id (herein called output code).  All data is\n  // referenced by a code, which represents one or more values from the\n  // original input stream.  All input bytes can be referenced as the same\n  // value as an output code.  So if you didn't want any compression, you\n  // could more or less just output the original bytes as codes (there are\n  // some details to this, but it is the idea).  In order to achieve\n  // compression, values greater then the input range (codes can be up to\n  // 12-bit while input only 8-bit) represent a sequence of previously seen\n  // inputs.  The decompressor is able to build the same mapping while\n  // decoding, so there is always a shared common knowledge between the\n  // encoding and decoder, which is also important for \"timing\" aspects like\n  // how to handle variable bit width code encoding.\n  //\n  // One obvious but very important consequence of the table system is there\n  // is always a unique id (at most 12-bits) to map the runs.  'A' might be\n  // 4, then 'AA' might be 10, 'AAA' 11, 'AAAA' 12, etc.  This relationship\n  // can be used for an effecient lookup strategy for the code mapping.  We\n  // need to know if a run has been seen before, and be able to map that run\n  // to the output code.  Since we start with known unique ids (input bytes),\n  // and then from those build more unique ids (table entries), we can\n  // continue this chain (almost like a linked list) to always have small\n  // integer values that represent the current byte chains in the encoder.\n  // This means instead of tracking the input bytes (AAAABCD) to know our\n  // current state, we can track the table entry for AAAABC (it is guaranteed\n  // to exist by the nature of the algorithm) and the next character D.\n  // Therefor the tuple of (table_entry, byte) is guaranteed to also be\n  // unique.  This allows us to create a simple lookup key for mapping input\n  // sequences to codes (table indices) without having to store or search\n  // any of the code sequences.  So if 'AAAA' has a table entry of 12, the\n  // tuple of ('AAAA', K) for any input byte K will be unique, and can be our\n  // key.  This leads to a integer value at most 20-bits, which can always\n  // fit in an SMI value and be used as a fast sparse array / object key.\n\n  // Output code for the current contents of the index buffer.\n  var ib_code = index_stream[0] & code_mask;  // Load first input index.\n  var code_table = { };  // Key'd on our 20-bit \"tuple\".\n\n  emit_code(clear_code);  // Spec says first code should be a clear code.\n\n  // First index already loaded, process the rest of the stream.\n  for (var i = 1, il = index_stream.length; i < il; ++i) {\n    var k = index_stream[i] & code_mask;\n    var cur_key = ib_code << 8 | k;  // (prev, k) unique tuple.\n    var cur_code = code_table[cur_key];  // buffer + k.\n\n    // Check if we have to create a new code table entry.\n    if (cur_code === undefined) {  // We don't have buffer + k.\n      // Emit index buffer (without k).\n      // This is an inline version of emit_code, because this is the core\n      // writing routine of the compressor (and V8 cannot inline emit_code\n      // because it is a closure here in a different context).  Additionally\n      // we can call emit_byte_to_buffer less often, because we can have\n      // 30-bits (from our 31-bit signed SMI), and we know our codes will only\n      // be 12-bits, so can safely have 18-bits there without overflow.\n      // emit_code(ib_code);\n      cur |= ib_code << cur_shift;\n      cur_shift += cur_code_size;\n      while (cur_shift >= 8) {\n        buf[p++] = cur & 0xff;\n        cur >>= 8; cur_shift -= 8;\n        if (p === cur_subblock + 256) {  // Finished a subblock.\n          buf[cur_subblock] = 255;\n          cur_subblock = p++;\n        }\n      }\n\n      if (next_code === 4096) {  // Table full, need a clear.\n        emit_code(clear_code);\n        next_code = eoi_code + 1;\n        cur_code_size = min_code_size + 1;\n        code_table = { };\n      } else {  // Table not full, insert a new entry.\n        // Increase our variable bit code sizes if necessary.  This is a bit\n        // tricky as it is based on \"timing\" between the encoding and\n        // decoder.  From the encoders perspective this should happen after\n        // we've already emitted the index buffer and are about to create the\n        // first table entry that would overflow our current code bit size.\n        if (next_code >= (1 << cur_code_size)) ++cur_code_size;\n        code_table[cur_key] = next_code++;  // Insert into code table.\n      }\n\n      ib_code = k;  // Index buffer to single input k.\n    } else {\n      ib_code = cur_code;  // Index buffer to sequence in code table.\n    }\n  }\n\n  emit_code(ib_code);  // There will still be something in the index buffer.\n  emit_code(eoi_code);  // End Of Information.\n\n  // Flush / finalize the sub-blocks stream to the buffer.\n  emit_bytes_to_buffer(1);\n\n  // Finish the sub-blocks, writing out any unfinished lengths and\n  // terminating with a sub-block of length 0.  If we have already started\n  // but not yet used a sub-block it can just become the terminator.\n  if (cur_subblock + 1 === p) {  // Started but unused.\n    buf[cur_subblock] = 0;\n  } else {  // Started and used, write length and additional terminator block.\n    buf[cur_subblock] = p - cur_subblock - 1;\n    buf[p++] = 0;\n  }\n  return p;\n}\n\nfunction GifReader(buf) {\n  var p = 0;\n\n  // - Header (GIF87a or GIF89a).\n  if (buf[p++] !== 0x47 ||            buf[p++] !== 0x49 || buf[p++] !== 0x46 ||\n      buf[p++] !== 0x38 || (buf[p++]+1 & 0xfd) !== 0x38 || buf[p++] !== 0x61) {\n    throw \"Invalid GIF 87a/89a header.\";\n  }\n\n  // - Logical Screen Descriptor.\n  var width = buf[p++] | buf[p++] << 8;\n  var height = buf[p++] | buf[p++] << 8;\n  var pf0 = buf[p++];  // <Packed Fields>.\n  var global_palette_flag = pf0 >> 7;\n  var num_global_colors_pow2 = pf0 & 0x7;\n  var num_global_colors = 1 << (num_global_colors_pow2 + 1);\n  var background = buf[p++];\n  buf[p++];  // Pixel aspect ratio (unused?).\n\n  var global_palette_offset = null;\n\n  if (global_palette_flag) {\n    global_palette_offset = p;\n    p += num_global_colors * 3;  // Seek past palette.\n  }\n\n  var no_eof = true;\n\n  var frames = [ ];\n\n  var delay = 0;\n  var transparent_index = null;\n  var disposal = 0;  // 0 - No disposal specified.\n  var loop_count = null;\n\n  this.width = width;\n  this.height = height;\n\n  while (no_eof && p < buf.length) {\n    switch (buf[p++]) {\n      case 0x21:  // Graphics Control Extension Block\n        switch (buf[p++]) {\n          case 0xff:  // Application specific block\n            // Try if it's a Netscape block (with animation loop counter).\n            if (buf[p   ] !== 0x0b ||  // 21 FF already read, check block size.\n                // NETSCAPE2.0\n                buf[p+1 ] == 0x4e && buf[p+2 ] == 0x45 && buf[p+3 ] == 0x54 &&\n                buf[p+4 ] == 0x53 && buf[p+5 ] == 0x43 && buf[p+6 ] == 0x41 &&\n                buf[p+7 ] == 0x50 && buf[p+8 ] == 0x45 && buf[p+9 ] == 0x32 &&\n                buf[p+10] == 0x2e && buf[p+11] == 0x30 &&\n                // Sub-block\n                buf[p+12] == 0x03 && buf[p+13] == 0x01 && buf[p+16] == 0) {\n              p += 14;\n              loop_count = buf[p++] | buf[p++] << 8;\n              p++;  // Skip terminator.\n            } else {  // We don't know what it is, just try to get past it.\n              p += 12;\n              while (true) {  // Seek through subblocks.\n                var block_size = buf[p++];\n                if (block_size === 0) break;\n                p += block_size;\n              }\n            }\n            break;\n\n          case 0xf9:  // Graphics Control Extension\n            if (buf[p++] !== 0x4 || buf[p+4] !== 0)\n              throw \"Invalid graphics extension block.\";\n            var pf1 = buf[p++];\n            delay = buf[p++] | buf[p++] << 8;\n            transparent_index = buf[p++];\n            if ((pf1 & 1) === 0) transparent_index = null;\n            disposal = pf1 >> 2 & 0x7;\n            p++;  // Skip terminator.\n            break;\n\n          case 0xfe:  // Comment Extension.\n            while (true) {  // Seek through subblocks.\n              var block_size = buf[p++];\n              if (block_size === 0) break;\n              // console.log(buf.slice(p, p+block_size).toString('ascii'));\n              p += block_size;\n            }\n            break;\n\n          default:\n            throw \"Unknown graphic control label: 0x\" + buf[p-1].toString(16);\n        }\n        break;\n\n      case 0x2c:  // Image Descriptor.\n        var x = buf[p++] | buf[p++] << 8;\n        var y = buf[p++] | buf[p++] << 8;\n        var w = buf[p++] | buf[p++] << 8;\n        var h = buf[p++] | buf[p++] << 8;\n        var pf2 = buf[p++];\n        var local_palette_flag = pf2 >> 7;\n        var interlace_flag = pf2 >> 6 & 1;\n        var num_local_colors_pow2 = pf2 & 0x7;\n        var num_local_colors = 1 << (num_local_colors_pow2 + 1);\n        var palette_offset = global_palette_offset;\n        var has_local_palette = false;\n        if (local_palette_flag) {\n          var has_local_palette = true;\n          palette_offset = p;  // Override with local palette.\n          p += num_local_colors * 3;  // Seek past palette.\n        }\n\n        var data_offset = p;\n\n        p++;  // codesize\n        while (true) {\n          var block_size = buf[p++];\n          if (block_size === 0) break;\n          p += block_size;\n        }\n\n        frames.push({x: x, y: y, width: w, height: h,\n                     has_local_palette: has_local_palette,\n                     palette_offset: palette_offset,\n                     data_offset: data_offset,\n                     data_length: p - data_offset,\n                     transparent_index: transparent_index,\n                     interlaced: !!interlace_flag,\n                     delay: delay,\n                     disposal: disposal});\n        break;\n\n      case 0x3b:  // Trailer Marker (end of file).\n        no_eof = false;\n        break;\n\n      default:\n        throw \"Unknown gif block: 0x\" + buf[p-1].toString(16);\n        break;\n    }\n  }\n\n  this.numFrames = function() {\n    return frames.length;\n  };\n\n  this.loopCount = function() {\n    return loop_count;\n  };\n\n  this.frameInfo = function(frame_num) {\n    if (frame_num < 0 || frame_num >= frames.length)\n      throw \"Frame index out of range.\";\n    return frames[frame_num];\n  }\n\n  this.decodeAndBlitFrameBGRA = function(frame_num, pixels) {\n    var frame = this.frameInfo(frame_num);\n    var num_pixels = frame.width * frame.height;\n    var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.\n    GifReaderLZWOutputIndexStream(\n        buf, frame.data_offset, index_stream, num_pixels);\n    var palette_offset = frame.palette_offset;\n\n    // NOTE(deanm): It seems to be much faster to compare index to 256 than\n    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in\n    // the profile, not sure if it's related to using a Uint8Array.\n    var trans = frame.transparent_index;\n    if (trans === null) trans = 256;\n\n    // We are possibly just blitting to a portion of the entire frame.\n    // That is a subrect within the framerect, so the additional pixels\n    // must be skipped over after we finished a scanline.\n    var framewidth  = frame.width;\n    var framestride = width - framewidth;\n    var xleft       = framewidth;  // Number of subrect pixels left in scanline.\n\n    // Output indicies of the top left and bottom right corners of the subrect.\n    var opbeg = ((frame.y * width) + frame.x) * 4;\n    var opend = ((frame.y + frame.height) * width + frame.x) * 4;\n    var op    = opbeg;\n\n    var scanstride = framestride * 4;\n\n    // Use scanstride to skip past the rows when interlacing.  This is skipping\n    // 7 rows for the first two passes, then 3 then 1.\n    if (frame.interlaced === true) {\n      scanstride += width * 4 * 7;  // Pass 1.\n    }\n\n    var interlaceskip = 8;  // Tracking the row interval in the current pass.\n\n    for (var i = 0, il = index_stream.length; i < il; ++i) {\n      var index = index_stream[i];\n\n      if (xleft === 0) {  // Beginning of new scan line\n        op += scanstride;\n        xleft = framewidth;\n        if (op >= opend) { // Catch the wrap to switch passes when interlacing.\n          scanstride = framestride * 4 + width * 4 * (interlaceskip-1);\n          // interlaceskip / 2 * 4 is interlaceskip << 1.\n          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);\n          interlaceskip >>= 1;\n        }\n      }\n\n      if (index === trans) {\n        op += 4;\n      } else {\n        var r = buf[palette_offset + index * 3];\n        var g = buf[palette_offset + index * 3 + 1];\n        var b = buf[palette_offset + index * 3 + 2];\n        pixels[op++] = b;\n        pixels[op++] = g;\n        pixels[op++] = r;\n        pixels[op++] = 255;\n      }\n      --xleft;\n    }\n  };\n\n  // I will go to copy and paste hell one day...\n  this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {\n    var frame = this.frameInfo(frame_num);\n    var num_pixels = frame.width * frame.height;\n    var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.\n    GifReaderLZWOutputIndexStream(\n        buf, frame.data_offset, index_stream, num_pixels);\n    var palette_offset = frame.palette_offset;\n\n    // NOTE(deanm): It seems to be much faster to compare index to 256 than\n    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in\n    // the profile, not sure if it's related to using a Uint8Array.\n    var trans = frame.transparent_index;\n    if (trans === null) trans = 256;\n\n    // We are possibly just blitting to a portion of the entire frame.\n    // That is a subrect within the framerect, so the additional pixels\n    // must be skipped over after we finished a scanline.\n    var framewidth  = frame.width;\n    var framestride = width - framewidth;\n    var xleft       = framewidth;  // Number of subrect pixels left in scanline.\n\n    // Output indicies of the top left and bottom right corners of the subrect.\n    var opbeg = ((frame.y * width) + frame.x) * 4;\n    var opend = ((frame.y + frame.height) * width + frame.x) * 4;\n    var op    = opbeg;\n\n    var scanstride = framestride * 4;\n\n    // Use scanstride to skip past the rows when interlacing.  This is skipping\n    // 7 rows for the first two passes, then 3 then 1.\n    if (frame.interlaced === true) {\n      scanstride += width * 4 * 7;  // Pass 1.\n    }\n\n    var interlaceskip = 8;  // Tracking the row interval in the current pass.\n\n    for (var i = 0, il = index_stream.length; i < il; ++i) {\n      var index = index_stream[i];\n\n      if (xleft === 0) {  // Beginning of new scan line\n        op += scanstride;\n        xleft = framewidth;\n        if (op >= opend) { // Catch the wrap to switch passes when interlacing.\n          scanstride = framestride * 4 + width * 4 * (interlaceskip-1);\n          // interlaceskip / 2 * 4 is interlaceskip << 1.\n          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);\n          interlaceskip >>= 1;\n        }\n      }\n\n      if (index === trans) {\n        op += 4;\n      } else {\n        var r = buf[palette_offset + index * 3];\n        var g = buf[palette_offset + index * 3 + 1];\n        var b = buf[palette_offset + index * 3 + 2];\n        pixels[op++] = r;\n        pixels[op++] = g;\n        pixels[op++] = b;\n        pixels[op++] = 255;\n      }\n      --xleft;\n    }\n  };\n}\n\nfunction GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {\n  var min_code_size = code_stream[p++];\n\n  var clear_code = 1 << min_code_size;\n  var eoi_code = clear_code + 1;\n  var next_code = eoi_code + 1;\n\n  var cur_code_size = min_code_size + 1;  // Number of bits per code.\n  // NOTE: This shares the same name as the encoder, but has a different\n  // meaning here.  Here this masks each code coming from the code stream.\n  var code_mask = (1 << cur_code_size) - 1;\n  var cur_shift = 0;\n  var cur = 0;\n\n  var op = 0;  // Output pointer.\n  \n  var subblock_size = code_stream[p++];\n\n  // TODO(deanm): Would using a TypedArray be any faster?  At least it would\n  // solve the fast mode / backing store uncertainty.\n  // var code_table = Array(4096);\n  var code_table = new Int32Array(4096);  // Can be signed, we only use 20 bits.\n\n  var prev_code = null;  // Track code-1.\n\n  while (true) {\n    // Read up to two bytes, making sure we always 12-bits for max sized code.\n    while (cur_shift < 16) {\n      if (subblock_size === 0) break;  // No more data to be read.\n\n      cur |= code_stream[p++] << cur_shift;\n      cur_shift += 8;\n\n      if (subblock_size === 1) {  // Never let it get to 0 to hold logic above.\n        subblock_size = code_stream[p++];  // Next subblock.\n      } else {\n        --subblock_size;\n      }\n    }\n\n    // TODO(deanm): We should never really get here, we should have received\n    // and EOI.\n    if (cur_shift < cur_code_size)\n      break;\n\n    var code = cur & code_mask;\n    cur >>= cur_code_size;\n    cur_shift -= cur_code_size;\n\n    // TODO(deanm): Maybe should check that the first code was a clear code,\n    // at least this is what you're supposed to do.  But actually our encoder\n    // now doesn't emit a clear code first anyway.\n    if (code === clear_code) {\n      // We don't actually have to clear the table.  This could be a good idea\n      // for greater error checking, but we don't really do any anyway.  We\n      // will just track it with next_code and overwrite old entries.\n\n      next_code = eoi_code + 1;\n      cur_code_size = min_code_size + 1;\n      code_mask = (1 << cur_code_size) - 1;\n\n      // Don't update prev_code ?\n      prev_code = null;\n      continue;\n    } else if (code === eoi_code) {\n      break;\n    }\n\n    // We have a similar situation as the decoder, where we want to store\n    // variable length entries (code table entries), but we want to do in a\n    // faster manner than an array of arrays.  The code below stores sort of a\n    // linked list within the code table, and then \"chases\" through it to\n    // construct the dictionary entries.  When a new entry is created, just the\n    // last byte is stored, and the rest (prefix) of the entry is only\n    // referenced by its table entry.  Then the code chases through the\n    // prefixes until it reaches a single byte code.  We have to chase twice,\n    // first to compute the length, and then to actually copy the data to the\n    // output (backwards, since we know the length).  The alternative would be\n    // storing something in an intermediate stack, but that doesn't make any\n    // more sense.  I implemented an approach where it also stored the length\n    // in the code table, although it's a bit tricky because you run out of\n    // bits (12 + 12 + 8), but I didn't measure much improvements (the table\n    // entries are generally not the long).  Even when I created benchmarks for\n    // very long table entries the complexity did not seem worth it.\n    // The code table stores the prefix entry in 12 bits and then the suffix\n    // byte in 8 bits, so each entry is 20 bits.\n\n    var chase_code = code < next_code ? code : prev_code;\n\n    // Chase what we will output, either {CODE} or {CODE-1}.\n    var chase_length = 0;\n    var chase = chase_code;\n    while (chase > clear_code) {\n      chase = code_table[chase] >> 8;\n      ++chase_length;\n    }\n\n    var k = chase;\n    \n    var op_end = op + chase_length + (chase_code !== code ? 1 : 0);\n    if (op_end > output_length) {\n      console.log(\"Warning, gif stream longer than expected.\");\n      return;\n    }\n\n    // Already have the first byte from the chase, might as well write it fast.\n    output[op++] = k;\n\n    op += chase_length;\n    var b = op;  // Track pointer, writing backwards.\n\n    if (chase_code !== code)  // The case of emitting {CODE-1} + k.\n      output[op++] = k;\n\n    chase = chase_code;\n    while (chase_length--) {\n      chase = code_table[chase];\n      output[--b] = chase & 0xff;  // Write backwards.\n      chase >>= 8;  // Pull down to the prefix code.\n    }\n\n    if (prev_code !== null && next_code < 4096) {\n      code_table[next_code++] = prev_code << 8 | k;\n      // TODO(deanm): Figure out this clearing vs code growth logic better.  I\n      // have an feeling that it should just happen somewhere else, for now it\n      // is awkward between when we grow past the max and then hit a clear code.\n      // For now just check if we hit the max 12-bits (then a clear code should\n      // follow, also of course encoded in 12-bits).\n      if (next_code >= code_mask+1 && cur_code_size < 12) {\n        ++cur_code_size;\n        code_mask = code_mask << 1 | 1;\n      }\n    }\n\n    prev_code = code;\n  }\n\n  if (op !== output_length) {\n    console.log(\"Warning, gif stream shorter than expected.\");\n  }\n\n  return output;\n}\n\ntry { exports.GifWriter = GifWriter; exports.GifReader = GifReader } catch(e) { }  // CommonJS.\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/omggif/omggif.js\n ** module id = 15\n ** module chunks = 0\n **/","\"use strict\"\n\nvar ndarray = require(\"ndarray\")\nvar do_convert = require(\"./doConvert.js\")\n\nmodule.exports = function convert(arr, result) {\n  var shape = [], c = arr, sz = 1\n  while(c instanceof Array) {\n    shape.push(c.length)\n    sz *= c.length\n    c = c[0]\n  }\n  if(shape.length === 0) {\n    return ndarray()\n  }\n  if(!result) {\n    result = ndarray(new Float64Array(sz), shape)\n  }\n  do_convert(result, arr)\n  return result\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/ndarray-pack/convert.js\n ** module id = 16\n ** module chunks = 0\n **/","module.exports=require('cwise-compiler')({\"args\":[\"array\",\"scalar\",\"index\"],\"pre\":{\"body\":\"{}\",\"args\":[],\"thisVars\":[],\"localVars\":[]},\"body\":{\"body\":\"{\\nvar _inline_1_v=_inline_1_arg1_,_inline_1_i\\nfor(_inline_1_i=0;_inline_1_i<_inline_1_arg2_.length-1;++_inline_1_i) {\\n_inline_1_v=_inline_1_v[_inline_1_arg2_[_inline_1_i]]\\n}\\n_inline_1_arg0_=_inline_1_v[_inline_1_arg2_[_inline_1_arg2_.length-1]]\\n}\",\"args\":[{\"name\":\"_inline_1_arg0_\",\"lvalue\":true,\"rvalue\":false,\"count\":1},{\"name\":\"_inline_1_arg1_\",\"lvalue\":false,\"rvalue\":true,\"count\":1},{\"name\":\"_inline_1_arg2_\",\"lvalue\":false,\"rvalue\":true,\"count\":4}],\"thisVars\":[],\"localVars\":[\"_inline_1_i\",\"_inline_1_v\"]},\"post\":{\"body\":\"{}\",\"args\":[],\"thisVars\":[],\"localVars\":[]},\"funcName\":\"convert\",\"blockSize\":64})\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/ndarray-pack/doConvert.js\n ** module id = 17\n ** module chunks = 0\n **/","\"use strict\"\n\nvar createThunk = require(\"./lib/thunk.js\")\n\nfunction Procedure() {\n  this.argTypes = []\n  this.shimArgs = []\n  this.arrayArgs = []\n  this.scalarArgs = []\n  this.offsetArgs = []\n  this.offsetArgIndex = []\n  this.indexArgs = []\n  this.shapeArgs = []\n  this.funcName = \"\"\n  this.pre = null\n  this.body = null\n  this.post = null\n  this.debug = false\n}\n\nfunction compileCwise(user_args) {\n  //Create procedure\n  var proc = new Procedure()\n  \n  //Parse blocks\n  proc.pre    = user_args.pre\n  proc.body   = user_args.body\n  proc.post   = user_args.post\n\n  //Parse arguments\n  var proc_args = user_args.args.slice(0)\n  proc.argTypes = proc_args.slice(0)\n  for(var i=0; i<proc_args.length; ++i) {\n    var arg_type = proc_args[i]\n    if(arg_type === \"array\") {\n      proc.arrayArgs.push(i)\n      proc.shimArgs.push(\"array\" + i)\n      if(i < proc.pre.args.length && proc.pre.args[i].count>0) {\n        throw new Error(\"cwise: pre() block may not reference array args\")\n      }\n      if(i < proc.post.args.length && proc.post.args[i].count>0) {\n        throw new Error(\"cwise: post() block may not reference array args\")\n      }\n    } else if(arg_type === \"scalar\") {\n      proc.scalarArgs.push(i)\n      proc.shimArgs.push(\"scalar\" + i)\n    } else if(arg_type === \"index\") {\n      proc.indexArgs.push(i)\n      if(i < proc.pre.args.length && proc.pre.args[i].count > 0) {\n        throw new Error(\"cwise: pre() block may not reference array index\")\n      }\n      if(i < proc.body.args.length && proc.body.args[i].lvalue) {\n        throw new Error(\"cwise: body() block may not write to array index\")\n      }\n      if(i < proc.post.args.length && proc.post.args[i].count > 0) {\n        throw new Error(\"cwise: post() block may not reference array index\")\n      }\n    } else if(arg_type === \"shape\") {\n      proc.shapeArgs.push(i)\n      if(i < proc.pre.args.length && proc.pre.args[i].lvalue) {\n        throw new Error(\"cwise: pre() block may not write to array shape\")\n      }\n      if(i < proc.body.args.length && proc.body.args[i].lvalue) {\n        throw new Error(\"cwise: body() block may not write to array shape\")\n      }\n      if(i < proc.post.args.length && proc.post.args[i].lvalue) {\n        throw new Error(\"cwise: post() block may not write to array shape\")\n      }\n    } else if(typeof arg_type === \"object\" && arg_type.offset) {\n      proc.argTypes[i] = \"offset\"\n      proc.offsetArgs.push({ array: arg_type.array, offset:arg_type.offset })\n      proc.offsetArgIndex.push(i)\n    } else {\n      throw new Error(\"cwise: Unknown argument type \" + proc_args[i])\n    }\n  }\n  \n  //Make sure at least one array argument was specified\n  if(proc.arrayArgs.length <= 0) {\n    throw new Error(\"cwise: No array arguments specified\")\n  }\n  \n  //Make sure arguments are correct\n  if(proc.pre.args.length > proc_args.length) {\n    throw new Error(\"cwise: Too many arguments in pre() block\")\n  }\n  if(proc.body.args.length > proc_args.length) {\n    throw new Error(\"cwise: Too many arguments in body() block\")\n  }\n  if(proc.post.args.length > proc_args.length) {\n    throw new Error(\"cwise: Too many arguments in post() block\")\n  }\n\n  //Check debug flag\n  proc.debug = !!user_args.printCode || !!user_args.debug\n  \n  //Retrieve name\n  proc.funcName = user_args.funcName || \"cwise\"\n  \n  //Read in block size\n  proc.blockSize = user_args.blockSize || 64\n\n  return createThunk(proc)\n}\n\nmodule.exports = compileCwise\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/cwise-compiler/compiler.js\n ** module id = 18\n ** module chunks = 0\n **/","\"use strict\"\n\nvar compile = require(\"./compile.js\")\n\nfunction createThunk(proc) {\n  var code = [\"'use strict'\", \"var CACHED={}\"]\n  var vars = []\n  var thunkName = proc.funcName + \"_cwise_thunk\"\n  \n  //Build thunk\n  code.push([\"return function \", thunkName, \"(\", proc.shimArgs.join(\",\"), \"){\"].join(\"\"))\n  var typesig = []\n  var string_typesig = []\n  var proc_args = [[\"array\",proc.arrayArgs[0],\".shape\"].join(\"\")]\n  for(var i=0; i<proc.arrayArgs.length; ++i) {\n    var j = proc.arrayArgs[i]\n    vars.push([\"t\", j, \"=array\", j, \".dtype,\",\n               \"r\", j, \"=array\", j, \".order\"].join(\"\"))\n    typesig.push(\"t\" + j)\n    typesig.push(\"r\" + j)\n    string_typesig.push(\"t\"+j)\n    string_typesig.push(\"r\"+j+\".join()\")\n    proc_args.push(\"array\" + j + \".data\")\n    proc_args.push(\"array\" + j + \".stride\")\n    proc_args.push(\"array\" + j + \".offset|0\")\n  }\n  for(var i=0; i<proc.scalarArgs.length; ++i) {\n    proc_args.push(\"scalar\" + proc.scalarArgs[i])\n  }\n  vars.push([\"type=[\", string_typesig.join(\",\"), \"].join()\"].join(\"\"))\n  vars.push(\"proc=CACHED[type]\")\n  code.push(\"var \" + vars.join(\",\"))\n  \n  code.push([\"if(!proc){\",\n             \"CACHED[type]=proc=compile([\", typesig.join(\",\"), \"])}\",\n             \"return proc(\", proc_args.join(\",\"), \")}\"].join(\"\"))\n\n  if(proc.debug) {\n    console.log(\"Generated thunk:\", code.join(\"\\n\"))\n  }\n  \n  //Compile thunk\n  var thunk = new Function(\"compile\", code.join(\"\\n\"))\n  return thunk(compile.bind(undefined, proc))\n}\n\nmodule.exports = createThunk\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/cwise-compiler/lib/thunk.js\n ** module id = 19\n ** module chunks = 0\n **/","\"use strict\"\n\nvar uniq = require(\"uniq\")\n\nfunction innerFill(order, proc, body) {\n  var dimension = order.length\n    , nargs = proc.arrayArgs.length\n    , has_index = proc.indexArgs.length>0\n    , code = []\n    , vars = []\n    , idx=0, pidx=0, i, j\n  for(i=0; i<dimension; ++i) {\n    vars.push([\"i\",i,\"=0\"].join(\"\"))\n  }\n  //Compute scan deltas\n  for(j=0; j<nargs; ++j) {\n    for(i=0; i<dimension; ++i) {\n      pidx = idx\n      idx = order[i]\n      if(i === 0) {\n        vars.push([\"d\",j,\"s\",i,\"=t\",j,\"[\",idx,\"]\"].join(\"\"))\n      } else {\n        vars.push([\"d\",j,\"s\",i,\"=(t\",j,\"[\",idx,\"]-s\",pidx,\"*t\",j,\"[\",pidx,\"])\"].join(\"\"))\n      }\n    }\n  }\n  code.push(\"var \" + vars.join(\",\"))\n  //Scan loop\n  for(i=dimension-1; i>=0; --i) {\n    idx = order[i]\n    code.push([\"for(i\",i,\"=0;i\",i,\"<s\",idx,\";++i\",i,\"){\"].join(\"\"))\n  }\n  //Push body of inner loop\n  code.push(body)\n  //Advance scan pointers\n  for(i=0; i<dimension; ++i) {\n    pidx = idx\n    idx = order[i]\n    for(j=0; j<nargs; ++j) {\n      code.push([\"p\",j,\"+=d\",j,\"s\",i].join(\"\"))\n    }\n    if(has_index) {\n      if(i > 0) {\n        code.push([\"index[\",pidx,\"]-=s\",pidx].join(\"\"))\n      }\n      code.push([\"++index[\",idx,\"]\"].join(\"\"))\n    }\n    code.push(\"}\")\n  }\n  return code.join(\"\\n\")\n}\n\nfunction outerFill(matched, order, proc, body) {\n  var dimension = order.length\n    , nargs = proc.arrayArgs.length\n    , blockSize = proc.blockSize\n    , has_index = proc.indexArgs.length > 0\n    , code = []\n  for(var i=0; i<nargs; ++i) {\n    code.push([\"var offset\",i,\"=p\",i].join(\"\"))\n  }\n  //Generate matched loops\n  for(var i=matched; i<dimension; ++i) {\n    code.push([\"for(var j\"+i+\"=SS[\", order[i], \"]|0;j\", i, \">0;){\"].join(\"\"))\n    code.push([\"if(j\",i,\"<\",blockSize,\"){\"].join(\"\"))\n    code.push([\"s\",order[i],\"=j\",i].join(\"\"))\n    code.push([\"j\",i,\"=0\"].join(\"\"))\n    code.push([\"}else{s\",order[i],\"=\",blockSize].join(\"\"))\n    code.push([\"j\",i,\"-=\",blockSize,\"}\"].join(\"\"))\n    if(has_index) {\n      code.push([\"index[\",order[i],\"]=j\",i].join(\"\"))\n    }\n  }\n  for(var i=0; i<nargs; ++i) {\n    var indexStr = [\"offset\"+i]\n    for(var j=matched; j<dimension; ++j) {\n      indexStr.push([\"j\",j,\"*t\",i,\"[\",order[j],\"]\"].join(\"\"))\n    }\n    code.push([\"p\",i,\"=(\",indexStr.join(\"+\"),\")\"].join(\"\"))\n  }\n  code.push(innerFill(order, proc, body))\n  for(var i=matched; i<dimension; ++i) {\n    code.push(\"}\")\n  }\n  return code.join(\"\\n\")\n}\n\n//Count the number of compatible inner orders\nfunction countMatches(orders) {\n  var matched = 0, dimension = orders[0].length\n  while(matched < dimension) {\n    for(var j=1; j<orders.length; ++j) {\n      if(orders[j][matched] !== orders[0][matched]) {\n        return matched\n      }\n    }\n    ++matched\n  }\n  return matched\n}\n\n//Processes a block according to the given data types\nfunction processBlock(block, proc, dtypes) {\n  var code = block.body\n  var pre = []\n  var post = []\n  for(var i=0; i<block.args.length; ++i) {\n    var carg = block.args[i]\n    if(carg.count <= 0) {\n      continue\n    }\n    var re = new RegExp(carg.name, \"g\")\n    var ptrStr = \"\"\n    var arrNum = proc.arrayArgs.indexOf(i)\n    switch(proc.argTypes[i]) {\n      case \"offset\":\n        var offArgIndex = proc.offsetArgIndex.indexOf(i)\n        var offArg = proc.offsetArgs[offArgIndex]\n        arrNum = offArg.array\n        ptrStr = \"+q\" + offArgIndex\n      case \"array\":\n        ptrStr = \"p\" + arrNum + ptrStr\n        var localStr = \"l\" + i\n        var arrStr = \"a\" + arrNum\n        if(carg.count === 1) {\n          if(dtypes[arrNum] === \"generic\") {\n            if(carg.lvalue) {\n              pre.push([\"var \", localStr, \"=\", arrStr, \".get(\", ptrStr, \")\"].join(\"\"))\n              code = code.replace(re, localStr)\n              post.push([arrStr, \".set(\", ptrStr, \",\", localStr,\")\"].join(\"\"))\n            } else {\n              code = code.replace(re, [arrStr, \".get(\", ptrStr, \")\"].join(\"\"))\n            }\n          } else {\n            code = code.replace(re, [arrStr, \"[\", ptrStr, \"]\"].join(\"\"))\n          }\n        } else if(dtypes[arrNum] === \"generic\") {\n          pre.push([\"var \", localStr, \"=\", arrStr, \".get(\", ptrStr, \")\"].join(\"\"))\n          code = code.replace(re, localStr)\n          if(carg.lvalue) {\n            post.push([arrStr, \".set(\", ptrStr, \",\", localStr,\")\"].join(\"\"))\n          }\n        } else {\n          pre.push([\"var \", localStr, \"=\", arrStr, \"[\", ptrStr, \"]\"].join(\"\"))\n          code = code.replace(re, localStr)\n          if(carg.lvalue) {\n            post.push([arrStr, \"[\", ptrStr, \"]=\", localStr].join(\"\"))\n          }\n        }\n      break\n      case \"scalar\":\n        code = code.replace(re, \"Y\" + proc.scalarArgs.indexOf(i))\n      break\n      case \"index\":\n        code = code.replace(re, \"index\")\n      break\n      case \"shape\":\n        code = code.replace(re, \"shape\")\n      break\n    }\n  }\n  return [pre.join(\"\\n\"), code, post.join(\"\\n\")].join(\"\\n\").trim()\n}\n\nfunction typeSummary(dtypes) {\n  var summary = new Array(dtypes.length)\n  var allEqual = true\n  for(var i=0; i<dtypes.length; ++i) {\n    var t = dtypes[i]\n    var digits = t.match(/\\d+/)\n    if(!digits) {\n      digits = \"\"\n    } else {\n      digits = digits[0]\n    }\n    if(t.charAt(0) === 0) {\n      summary[i] = \"u\" + t.charAt(1) + digits\n    } else {\n      summary[i] = t.charAt(0) + digits\n    }\n    if(i > 0) {\n      allEqual = allEqual && summary[i] === summary[i-1]\n    }\n  }\n  if(allEqual) {\n    return summary[0]\n  }\n  return summary.join(\"\")\n}\n\n//Generates a cwise operator\nfunction generateCWiseOp(proc, typesig) {\n\n  //Compute dimension\n  var dimension = typesig[1].length|0\n  var orders = new Array(proc.arrayArgs.length)\n  var dtypes = new Array(proc.arrayArgs.length)\n\n  //First create arguments for procedure\n  var arglist = [\"SS\"]\n  var code = [\"'use strict'\"]\n  var vars = []\n  \n  for(var j=0; j<dimension; ++j) {\n    vars.push([\"s\", j, \"=SS[\", j, \"]\"].join(\"\"))\n  }\n  for(var i=0; i<proc.arrayArgs.length; ++i) {\n    arglist.push(\"a\"+i)\n    arglist.push(\"t\"+i)\n    arglist.push(\"p\"+i)\n    dtypes[i] = typesig[2*i]\n    orders[i] = typesig[2*i+1]\n  }\n  for(var i=0; i<proc.scalarArgs.length; ++i) {\n    arglist.push(\"Y\" + i)\n  }\n  if(proc.shapeArgs.length > 0) {\n    vars.push(\"shape=SS.slice(0)\")\n  }\n  if(proc.indexArgs.length > 0) {\n    var zeros = new Array(dimension)\n    for(var i=0; i<dimension; ++i) {\n      zeros[i] = \"0\"\n    }\n    vars.push([\"index=[\", zeros.join(\",\"), \"]\"].join(\"\"))\n  }\n  for(var i=0; i<proc.offsetArgs.length; ++i) {\n    var off_arg = proc.offsetArgs[i]\n    var init_string = []\n    for(var j=0; j<off_arg.offset.length; ++j) {\n      if(off_arg.offset[j] === 0) {\n        continue\n      } else if(off_arg.offset[j] === 1) {\n        init_string.push([\"t\", off_arg.array, \"[\", j, \"]\"].join(\"\"))      \n      } else {\n        init_string.push([off_arg.offset[j], \"*t\", off_arg.array, \"[\", j, \"]\"].join(\"\"))\n      }\n    }\n    if(init_string.length === 0) {\n      vars.push(\"q\" + i + \"=0\")\n    } else {\n      vars.push([\"q\", i, \"=(\", init_string.join(\"+\"),\")|0\"].join(\"\"))\n    }\n  }\n\n  //Prepare this variables\n  var thisVars = uniq([].concat(proc.pre.thisVars)\n                      .concat(proc.body.thisVars)\n                      .concat(proc.post.thisVars))\n  vars = vars.concat(thisVars)\n  code.push(\"var \" + vars.join(\",\"))\n  for(var i=0; i<proc.arrayArgs.length; ++i) {\n    code.push(\"p\"+i+\"|=0\")\n  }\n  \n  //Inline prelude\n  if(proc.pre.body.length > 3) {\n    code.push(processBlock(proc.pre, proc, dtypes))\n  }\n\n  //Process body\n  var body = processBlock(proc.body, proc, dtypes)\n  var matched = countMatches(orders)\n  if(matched < dimension) {\n    code.push(outerFill(matched, orders[0], proc, body))\n  } else {\n    code.push(innerFill(orders[0], proc, body))\n  }\n\n  //Inline epilog\n  if(proc.post.body.length > 3) {\n    code.push(processBlock(proc.post, proc, dtypes))\n  }\n  \n  if(proc.debug) {\n    console.log(\"Generated cwise routine for \", typesig, \":\\n\\n\", code.join(\"\\n\"))\n  }\n  \n  var loopName = [(proc.funcName||\"unnamed\"), \"_cwise_loop_\", orders[0].join(\"s\"),\"m\",matched,typeSummary(dtypes)].join(\"\")\n  var f = new Function([\"function \",loopName,\"(\", arglist.join(\",\"),\"){\", code.join(\"\\n\"),\"} return \", loopName].join(\"\"))\n  return f()\n}\nmodule.exports = generateCWiseOp\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/cwise-compiler/lib/compile.js\n ** module id = 20\n ** module chunks = 0\n **/","\"use strict\"\n\nfunction unique_pred(list, compare) {\n  var ptr = 1\n    , len = list.length\n    , a=list[0], b=list[0]\n  for(var i=1; i<len; ++i) {\n    b = a\n    a = list[i]\n    if(compare(a, b)) {\n      if(i === ptr) {\n        ptr++\n        continue\n      }\n      list[ptr++] = a\n    }\n  }\n  list.length = ptr\n  return list\n}\n\nfunction unique_eq(list) {\n  var ptr = 1\n    , len = list.length\n    , a=list[0], b = list[0]\n  for(var i=1; i<len; ++i, b=a) {\n    b = a\n    a = list[i]\n    if(a !== b) {\n      if(i === ptr) {\n        ptr++\n        continue\n      }\n      list[ptr++] = a\n    }\n  }\n  list.length = ptr\n  return list\n}\n\nfunction unique(list, compare, sorted) {\n  if(list.length === 0) {\n    return []\n  }\n  if(compare) {\n    if(!sorted) {\n      list.sort(compare)\n    }\n    return unique_pred(list, compare)\n  }\n  if(!sorted) {\n    list.sort()\n  }\n  return unique_eq(list)\n}\n\nmodule.exports = unique\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/uniq/uniq.js\n ** module id = 21\n ** module chunks = 0\n **/","var Stream = require('stream')\n\n// through\n//\n// a stream that does nothing but re-emit the input.\n// useful for aggregating a series of changing but not ending streams into one stream)\n\nexports = module.exports = through\nthrough.through = through\n\n//create a readable writable stream.\n\nfunction through (write, end, opts) {\n  write = write || function (data) { this.queue(data) }\n  end = end || function () { this.queue(null) }\n\n  var ended = false, destroyed = false, buffer = [], _ended = false\n  var stream = new Stream()\n  stream.readable = stream.writable = true\n  stream.paused = false\n\n//  stream.autoPause   = !(opts && opts.autoPause   === false)\n  stream.autoDestroy = !(opts && opts.autoDestroy === false)\n\n  stream.write = function (data) {\n    write.call(this, data)\n    return !stream.paused\n  }\n\n  function drain() {\n    while(buffer.length && !stream.paused) {\n      var data = buffer.shift()\n      if(null === data)\n        return stream.emit('end')\n      else\n        stream.emit('data', data)\n    }\n  }\n\n  stream.queue = stream.push = function (data) {\n//    console.error(ended)\n    if(_ended) return stream\n    if(data === null) _ended = true\n    buffer.push(data)\n    drain()\n    return stream\n  }\n\n  //this will be registered as the first 'end' listener\n  //must call destroy next tick, to make sure we're after any\n  //stream piped from here.\n  //this is only a problem if end is not emitted synchronously.\n  //a nicer way to do this is to make sure this is the last listener for 'end'\n\n  stream.on('end', function () {\n    stream.readable = false\n    if(!stream.writable && stream.autoDestroy)\n      process.nextTick(function () {\n        stream.destroy()\n      })\n  })\n\n  function _end () {\n    stream.writable = false\n    end.call(stream)\n    if(!stream.readable && stream.autoDestroy)\n      stream.destroy()\n  }\n\n  stream.end = function (data) {\n    if(ended) return\n    ended = true\n    if(arguments.length) stream.write(data)\n    _end() // will emit or queue\n    return stream\n  }\n\n  stream.destroy = function () {\n    if(destroyed) return\n    destroyed = true\n    ended = true\n    buffer.length = 0\n    stream.writable = stream.readable = false\n    stream.emit('close')\n    return stream\n  }\n\n  stream.pause = function () {\n    if(stream.paused) return\n    stream.paused = true\n    return stream\n  }\n\n  stream.resume = function () {\n    if(stream.paused) {\n      stream.paused = false\n      stream.emit('resume')\n    }\n    drain()\n    //may have become paused again,\n    //as drain emits 'data'.\n    if(!stream.paused)\n      stream.emit('drain')\n    return stream\n  }\n  return stream\n}\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/through/index.js\n ** module id = 22\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/readable.js');\nStream.Writable = require('readable-stream/writable.js');\nStream.Duplex = require('readable-stream/duplex.js');\nStream.Transform = require('readable-stream/transform.js');\nStream.PassThrough = require('readable-stream/passthrough.js');\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/stream-browserify/index.js\n ** module id = 23\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/events/events.js\n ** module id = 24\n ** module chunks = 0\n **/","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/inherits/inherits_browser.js\n ** module id = 25\n ** module chunks = 0\n **/","exports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = require('stream');\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/stream-browserify/~/readable-stream/readable.js\n ** module id = 26\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\nvar EE = require('events').EventEmitter;\n\n/*<replacement>*/\nif (!EE.listenerCount) EE.listenerCount = function(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\nvar Stream = require('stream');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar StringDecoder;\n\n\n/*<replacement>*/\nvar debug = require('util');\nif (debug && debug.debuglog) {\n  debug = debug.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\n\nutil.inherits(Readable, Stream);\n\nfunction ReadableState(options, stream) {\n  var Duplex = require('./_stream_duplex');\n\n  options = options || {};\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var defaultHwm = options.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.buffer = [];\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex)\n    this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder)\n      StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n  var state = this._readableState;\n\n  if (util.isString(chunk) && !state.objectMode) {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = new Buffer(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (util.isNullOrUndefined(chunk)) {\n    state.reading = false;\n    if (!state.ended)\n      onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var e = new Error('stream.unshift() after end event');\n      stream.emit('error', e);\n    } else {\n      if (state.decoder && !addToFront && !encoding)\n        chunk = state.decoder.write(chunk);\n\n      if (!addToFront)\n        state.reading = false;\n\n      // if we want the data now, just emit it.\n      if (state.flowing && state.length === 0 && !state.sync) {\n        stream.emit('data', chunk);\n        stream.read(0);\n      } else {\n        // update the buffer info.\n        state.length += state.objectMode ? 1 : chunk.length;\n        if (addToFront)\n          state.buffer.unshift(chunk);\n        else\n          state.buffer.push(chunk);\n\n        if (state.needReadable)\n          emitReadable(stream);\n      }\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended &&\n         (state.needReadable ||\n          state.length < state.highWaterMark ||\n          state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  if (!StringDecoder)\n    StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 128MB\nvar MAX_HWM = 0x800000;\nfunction roundUpToNextPowerOf2(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2\n    n--;\n    for (var p = 1; p < 32; p <<= 1) n |= n >> p;\n    n++;\n  }\n  return n;\n}\n\nfunction howMuchToRead(n, state) {\n  if (state.length === 0 && state.ended)\n    return 0;\n\n  if (state.objectMode)\n    return n === 0 ? 0 : 1;\n\n  if (isNaN(n) || util.isNull(n)) {\n    // only flow one buffer at a time\n    if (state.flowing && state.buffer.length)\n      return state.buffer[0].length;\n    else\n      return state.length;\n  }\n\n  if (n <= 0)\n    return 0;\n\n  // If we're asking for more than the target buffer level,\n  // then raise the water mark.  Bump up to the next highest\n  // power of 2, to prevent increasing it excessively in tiny\n  // amounts.\n  if (n > state.highWaterMark)\n    state.highWaterMark = roundUpToNextPowerOf2(n);\n\n  // don't have that much.  return null, unless we've ended.\n  if (n > state.length) {\n    if (!state.ended) {\n      state.needReadable = true;\n      return 0;\n    } else\n      return state.length;\n  }\n\n  return n;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  debug('read', n);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (!util.isNumber(n) || n > 0)\n    state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended)\n      endReadable(this);\n    else\n      emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0)\n      endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  }\n\n  if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0)\n      state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n  }\n\n  // If _read pushed data synchronously, then `reading` will be false,\n  // and we need to re-evaluate how much data we can return to the user.\n  if (doRead && !state.reading)\n    n = howMuchToRead(nOrig, state);\n\n  var ret;\n  if (n > 0)\n    ret = fromList(n, state);\n  else\n    ret = null;\n\n  if (util.isNull(ret)) {\n    state.needReadable = true;\n    n = 0;\n  }\n\n  state.length -= n;\n\n  // If we have nothing in the buffer, then we want to know\n  // as soon as we *do* get something into the buffer.\n  if (state.length === 0 && !state.ended)\n    state.needReadable = true;\n\n  // If we tried to read() past the EOF, then emit end on the next tick.\n  if (nOrig !== n && state.ended && state.length === 0)\n    endReadable(this);\n\n  if (!util.isNull(ret))\n    this.emit('data', ret);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!util.isBuffer(chunk) &&\n      !util.isString(chunk) &&\n      !util.isNullOrUndefined(chunk) &&\n      !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n\nfunction onEofChunk(stream, state) {\n  if (state.decoder && !state.ended) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync)\n      process.nextTick(function() {\n        emitReadable_(stream);\n      });\n    else\n      emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(function() {\n      maybeReadMore_(stream, state);\n    });\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended &&\n         state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n    else\n      len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  this.emit('error', new Error('not implemented'));\n};\n\nReadable.prototype.pipe = function(dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted)\n    process.nextTick(endFn);\n  else\n    src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    debug('onunpipe');\n    if (readable === src) {\n      cleanup();\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', cleanup);\n    src.removeListener('data', ondata);\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain &&\n        (!dest._writableState || dest._writableState.needDrain))\n      ondrain();\n  }\n\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    if (false === ret) {\n      debug('false write response, pause',\n            src._readableState.awaitDrain);\n      src._readableState.awaitDrain++;\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EE.listenerCount(dest, 'error') === 0)\n      dest.emit('error', er);\n  }\n  // This is a brutally ugly hack to make sure that our error handler\n  // is attached before any userland ones.  NEVER DO THIS.\n  if (!dest._events || !dest._events.error)\n    dest.on('error', onerror);\n  else if (isArray(dest._events.error))\n    dest._events.error.unshift(onerror);\n  else\n    dest._events.error = [onerror, dest._events.error];\n\n\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain)\n      state.awaitDrain--;\n    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0)\n    return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes)\n      return this;\n\n    if (!dest)\n      dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest)\n      dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++)\n      dests[i].emit('unpipe', this);\n    return this;\n  }\n\n  // try to find the right one.\n  var i = indexOf(state.pipes, dest);\n  if (i === -1)\n    return this;\n\n  state.pipes.splice(i, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1)\n    state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  // If listening to data, and it has not explicitly been paused,\n  // then call resume to start the flow of data on the next tick.\n  if (ev === 'data' && false !== this._readableState.flowing) {\n    this.resume();\n  }\n\n  if (ev === 'readable' && this.readable) {\n    var state = this._readableState;\n    if (!state.readableListening) {\n      state.readableListening = true;\n      state.emittedReadable = false;\n      state.needReadable = true;\n      if (!state.reading) {\n        var self = this;\n        process.nextTick(function() {\n          debug('readable nexttick read 0');\n          self.read(0);\n        });\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    if (!state.reading) {\n      debug('resume read 0');\n      this.read(0);\n    }\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(function() {\n      resume_(stream, state);\n    });\n  }\n}\n\nfunction resume_(stream, state) {\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading)\n    stream.read(0);\n}\n\nReadable.prototype.pause = function() {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  if (state.flowing) {\n    do {\n      var chunk = stream.read();\n    } while (null !== chunk && state.flowing);\n  }\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function() {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length)\n        self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function(chunk) {\n    debug('wrapped data');\n    if (state.decoder)\n      chunk = state.decoder.write(chunk);\n    if (!chunk || !state.objectMode && !chunk.length)\n      return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {\n      this[i] = function(method) { return function() {\n        return stream[method].apply(stream, arguments);\n      }}(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n  forEach(events, function(ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function(n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n  var list = state.buffer;\n  var length = state.length;\n  var stringMode = !!state.decoder;\n  var objectMode = !!state.objectMode;\n  var ret;\n\n  // nothing in the list, definitely empty.\n  if (list.length === 0)\n    return null;\n\n  if (length === 0)\n    ret = null;\n  else if (objectMode)\n    ret = list.shift();\n  else if (!n || n >= length) {\n    // read it all, truncate the array.\n    if (stringMode)\n      ret = list.join('');\n    else\n      ret = Buffer.concat(list, length);\n    list.length = 0;\n  } else {\n    // read just some of it.\n    if (n < list[0].length) {\n      // just take a part of the first list item.\n      // slice is the same for buffers and strings.\n      var buf = list[0];\n      ret = buf.slice(0, n);\n      list[0] = buf.slice(n);\n    } else if (n === list[0].length) {\n      // first list is a perfect match\n      ret = list.shift();\n    } else {\n      // complex case.\n      // we have enough to cover it, but it spans past the first buffer.\n      if (stringMode)\n        ret = '';\n      else\n        ret = new Buffer(n);\n\n      var c = 0;\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\n        var buf = list[0];\n        var cpy = Math.min(n - c, buf.length);\n\n        if (stringMode)\n          ret += buf.slice(0, cpy);\n        else\n          buf.copy(ret, c, 0, cpy);\n\n        if (cpy < buf.length)\n          list[0] = buf.slice(cpy);\n        else\n          list.shift();\n\n        c += cpy;\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0)\n    throw new Error('endReadable called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(function() {\n      // Check that we didn't get one last unshift.\n      if (!state.endEmitted && state.length === 0) {\n        state.endEmitted = true;\n        stream.readable = false;\n        stream.emit('end');\n      }\n    });\n  }\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf (xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/stream-browserify/~/readable-stream/lib/_stream_readable.js\n ** module id = 27\n ** module chunks = 0\n **/","module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/isarray/index.js\n ** module id = 28\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/core-util-is/lib/util.js\n ** module id = 29\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nforEach(objectKeys(Writable.prototype), function(method) {\n  if (!Duplex.prototype[method])\n    Duplex.prototype[method] = Writable.prototype[method];\n});\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false)\n    this.readable = false;\n\n  if (options && options.writable === false)\n    this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false)\n    this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended)\n    return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(this.end.bind(this));\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/stream-browserify/~/readable-stream/lib/_stream_duplex.js\n ** module id = 31\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, cb), and it'll handle all\n// the drain event emission and buffering.\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Stream = require('stream');\n\nutil.inherits(Writable, Stream);\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n}\n\nfunction WritableState(options, stream) {\n  var Duplex = require('./_stream_duplex');\n\n  options = options || {};\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = options.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex)\n    this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function(er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.buffer = [];\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n}\n\nfunction Writable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex))\n    return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\n\nfunction writeAfterEnd(stream, state, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  process.nextTick(function() {\n    cb(er);\n  });\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  if (!util.isBuffer(chunk) &&\n      !util.isString(chunk) &&\n      !util.isNullOrUndefined(chunk) &&\n      !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');\n    stream.emit('error', er);\n    process.nextTick(function() {\n      cb(er);\n    });\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function(chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (util.isFunction(encoding)) {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (util.isBuffer(chunk))\n    encoding = 'buffer';\n  else if (!encoding)\n    encoding = state.defaultEncoding;\n\n  if (!util.isFunction(cb))\n    cb = function() {};\n\n  if (state.ended)\n    writeAfterEnd(this, state, cb);\n  else if (validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function() {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function() {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing &&\n        !state.corked &&\n        !state.finished &&\n        !state.bufferProcessing &&\n        state.buffer.length)\n      clearBuffer(this, state);\n  }\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode &&\n      state.decodeStrings !== false &&\n      util.isString(chunk)) {\n    chunk = new Buffer(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n  if (util.isBuffer(chunk))\n    encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing || state.corked)\n    state.buffer.push(new WriteReq(chunk, encoding, cb));\n  else\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev)\n    stream._writev(chunk, state.onwrite);\n  else\n    stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  if (sync)\n    process.nextTick(function() {\n      state.pendingcb--;\n      cb(er);\n    });\n  else {\n    state.pendingcb--;\n    cb(er);\n  }\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er)\n    onwriteError(stream, state, sync, er, cb);\n  else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(stream, state);\n\n    if (!finished &&\n        !state.corked &&\n        !state.bufferProcessing &&\n        state.buffer.length) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(function() {\n        afterWrite(stream, state, finished, cb);\n      });\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished)\n    onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n\n  if (stream._writev && state.buffer.length > 1) {\n    // Fast case, write everything using _writev()\n    var cbs = [];\n    for (var c = 0; c < state.buffer.length; c++)\n      cbs.push(state.buffer[c].callback);\n\n    // count the one we are adding, as well.\n    // TODO(isaacs) clean this up\n    state.pendingcb++;\n    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {\n      for (var i = 0; i < cbs.length; i++) {\n        state.pendingcb--;\n        cbs[i](err);\n      }\n    });\n\n    // Clear buffer\n    state.buffer = [];\n  } else {\n    // Slow case, write chunks one-by-one\n    for (var c = 0; c < state.buffer.length; c++) {\n      var entry = state.buffer[c];\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        c++;\n        break;\n      }\n    }\n\n    if (c < state.buffer.length)\n      state.buffer = state.buffer.slice(c);\n    else\n      state.buffer.length = 0;\n  }\n\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function(chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function(chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (util.isFunction(chunk)) {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (util.isFunction(encoding)) {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (!util.isNullOrUndefined(chunk))\n    this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished)\n    endWritable(this, state, cb);\n};\n\n\nfunction needFinish(stream, state) {\n  return (state.ending &&\n          state.length === 0 &&\n          !state.finished &&\n          !state.writing);\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished) {\n    state.prefinished = true;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(stream, state);\n  if (need) {\n    if (state.pendingcb === 0) {\n      prefinish(stream, state);\n      state.finished = true;\n      stream.emit('finish');\n    } else\n      prefinish(stream, state);\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished)\n      process.nextTick(cb);\n    else\n      stream.once('finish', cb);\n  }\n  state.ended = true;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/stream-browserify/~/readable-stream/lib/_stream_writable.js\n ** module id = 32\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Buffer = require('buffer').Buffer;\n\nvar isBufferEncoding = Buffer.isEncoding\n  || function(encoding) {\n       switch (encoding && encoding.toLowerCase()) {\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n         default: return false;\n       }\n     }\n\n\nfunction assertEncoding(encoding) {\n  if (encoding && !isBufferEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);\n  }\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\n//\n// @TODO Handling all encodings inside a single object makes it very difficult\n// to reason about this code, so it should be split up in the future.\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n// points as used by CESU-8.\nvar StringDecoder = exports.StringDecoder = function(encoding) {\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case 'utf8':\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\n      this.surrogateSize = 3;\n      break;\n    case 'ucs2':\n    case 'utf16le':\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case 'base64':\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;\n  }\n\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n  this.charBuffer = new Buffer(6);\n  // Number of bytes received for the current incomplete multi-byte character.\n  this.charReceived = 0;\n  // Number of bytes expected for the current incomplete multi-byte character.\n  this.charLength = 0;\n};\n\n\n// write decodes the given buffer and returns it as JS string that is\n// guaranteed to not contain any partial multi-byte characters. Any partial\n// character found at the end of the buffer is buffered up, and will be\n// returned when calling write again with the remaining bytes.\n//\n// Note: Converting a Buffer containing an orphan surrogate to a String\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\n// Buffer#write) will replace incomplete surrogates with the unicode\n// replacement character. See https://codereview.chromium.org/121173009/ .\nStringDecoder.prototype.write = function(buffer) {\n  var charStr = '';\n  // if our last write ended with an incomplete multibyte character\n  while (this.charLength) {\n    // determine how many remaining bytes this buffer has to offer for this char\n    var available = (buffer.length >= this.charLength - this.charReceived) ?\n        this.charLength - this.charReceived :\n        buffer.length;\n\n    // add the new bytes to the char buffer\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n    this.charReceived += available;\n\n    if (this.charReceived < this.charLength) {\n      // still not enough chars in this buffer? wait for more ...\n      return '';\n    }\n\n    // remove bytes belonging to the current character from the buffer\n    buffer = buffer.slice(available, buffer.length);\n\n    // get the character that was split\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = '';\n      continue;\n    }\n    this.charReceived = this.charLength = 0;\n\n    // if there are no more bytes in this buffer, just emit our char\n    if (buffer.length === 0) {\n      return charStr;\n    }\n    break;\n  }\n\n  // determine and set charLength / charReceived\n  this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    // buffer the incomplete character bytes we got\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n    end -= this.charReceived;\n  }\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    buffer.copy(this.charBuffer, 0, 0, size);\n    return charStr.substring(0, end);\n  }\n\n  // or just emit the charStr\n  return charStr;\n};\n\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n// the end of the given buffer. If so, it sets this.charLength to the byte\n// length that character, and sets this.charReceived to the number of bytes\n// that are available for this character.\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n  // determine how many bytes we have to check at the end of this buffer\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n  // Figure out if one of the last i bytes of our buffer announces an\n  // incomplete char.\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n    // 110XXXXX\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;\n    }\n\n    // 1110XXXX\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;\n    }\n\n    // 11110XXX\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;\n    }\n  }\n  this.charReceived = i;\n};\n\nStringDecoder.prototype.end = function(buffer) {\n  var res = '';\n  if (buffer && buffer.length)\n    res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);\n  }\n\n  return res;\n};\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);\n}\n\nfunction utf16DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 2;\n  this.charLength = this.charReceived ? 2 : 0;\n}\n\nfunction base64DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 3;\n  this.charLength = this.charReceived ? 3 : 0;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/string_decoder/index.js\n ** module id = 33\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\n\nfunction TransformState(options, stream) {\n  this.afterTransform = function(er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb)\n    return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (!util.isNullOrUndefined(data))\n    stream.push(data);\n\n  if (cb)\n    cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\n\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(options, this);\n\n  // when the writable side finishes, then flush out anything remaining.\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  this.once('prefinish', function() {\n    if (util.isFunction(this._flush))\n      this._flush(function(er) {\n        done(stream, er);\n      });\n    else\n      done(stream);\n  });\n}\n\nTransform.prototype.push = function(chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n  throw new Error('not implemented');\n};\n\nTransform.prototype._write = function(chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform ||\n        rs.needReadable ||\n        rs.length < rs.highWaterMark)\n      this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n  var ts = this._transformState;\n\n  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\n\nfunction done(stream, er) {\n  if (er)\n    return stream.emit('error', er);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length)\n    throw new Error('calling transform done when ws.length != 0');\n\n  if (ts.transforming)\n    throw new Error('calling transform done when still transforming');\n\n  return stream.push(null);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/stream-browserify/~/readable-stream/lib/_stream_transform.js\n ** module id = 34\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough))\n    return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/stream-browserify/~/readable-stream/lib/_stream_passthrough.js\n ** module id = 35\n ** module chunks = 0\n **/","module.exports = require(\"./lib/_stream_writable.js\")\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/stream-browserify/~/readable-stream/writable.js\n ** module id = 36\n ** module chunks = 0\n **/","module.exports = require(\"./lib/_stream_duplex.js\")\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/stream-browserify/~/readable-stream/duplex.js\n ** module id = 37\n ** module chunks = 0\n **/","module.exports = require(\"./lib/_stream_transform.js\")\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/stream-browserify/~/readable-stream/transform.js\n ** module id = 38\n ** module chunks = 0\n **/","module.exports = require(\"./lib/_stream_passthrough.js\")\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/stream-browserify/~/readable-stream/passthrough.js\n ** module id = 39\n ** module chunks = 0\n **/","\n/**\n * Module exports.\n */\n\nmodule.exports = dataUriToBuffer;\n\n/**\n * Returns a `Buffer` instance from the given data URI `uri`.\n *\n * @param {String} uri Data URI to turn into a Buffer instance\n * @return {Buffer} Buffer instance from Data URI\n * @api public\n */\n\nfunction dataUriToBuffer (uri) {\n  if (!/^data\\:/i.test(uri)) {\n    throw new TypeError('`uri` does not appear to be a Data URI (must begin with \"data:\")');\n  }\n\n  // strip newlines\n  uri = uri.replace(/\\r?\\n/g, '');\n\n  // split the URI up into the \"metadata\" and the \"data\" portions\n  var firstComma = uri.indexOf(',');\n  if (-1 === firstComma || firstComma <= 4) throw new TypeError('malformed data: URI');\n\n  // remove the \"data:\" scheme and parse the metadata\n  var meta = uri.substring(5, firstComma).split(';');\n\n  var base64 = false;\n  var charset = 'US-ASCII';\n  for (var i = 0; i < meta.length; i++) {\n    if ('base64' == meta[i]) {\n      base64 = true;\n    } else if (0 == meta[i].indexOf('charset=')) {\n      charset = meta[i].substring(8);\n    }\n  }\n\n  // get the encoded data portion and decode URI-encoded chars\n  var data = unescape(uri.substring(firstComma + 1));\n\n  var encoding = base64 ? 'base64' : 'ascii';\n  var buffer = new Buffer(data, encoding);\n\n  // set `.type` property to MIME type\n  buffer.type = meta[0] || 'text/plain';\n\n  // set the `.charset` property\n  buffer.charset = charset;\n\n  return buffer;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/data-uri-to-buffer/index.js\n ** module id = 40\n ** module chunks = 0\n **/","\"use strict\"\n\nconst ndarray = require('ndarray')\n\nconst getRows = (array,  X, Y) => {\n  const arr = ndarray(array, [X, Y])\n  let res = []\n\n  for (let y = 0; y < Y; y++) {\n    let row = []\n    for (let x = 0; x < X; x++) {\n      row.push(arr.get(x, y))\n    }\n    res.push(row.join(''))\n  }\n  return res\n}\n\nmodule.exports = getRows\n\n\n\n/** WEBPACK FOOTER **\n ** ./getRows.js\n **/"],"sourceRoot":""}